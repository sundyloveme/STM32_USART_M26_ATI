; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\stm32f10x_can.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\stm32f10x_can.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\startup\arm -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\Libraries\STM32F10x_StdPeriph_Driver\src -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\USER -I..\MDK-ARM -IC:\Users\Administrator\Desktop\stm32-uart-chenlong\stm32-uart-chenlong\MDK-ARM\RTE -I"D:\Program Files\keil5\ARM\PACK\ARM\CMSIS\4.2.0\CMSIS\Include" -I"D:\Program Files\keil5\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0" -D__MICROLIB -D__UVISION_VERSION=514 -D_RTE_ -DSTM32F10X_MD --omf_browse=.\obj\stm32f10x_can.crf ..\Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_can.c]
                          THUMB

                          AREA ||i.CAN_CancelTransmit||, CODE, READONLY, ALIGN=1

                  CAN_CancelTransmit PROC
;;;584      */
;;;585    void CAN_CancelTransmit(CAN_TypeDef* CANx, uint8_t Mailbox)
000000  b121              CBZ      r1,|L1.12|
;;;586    {
;;;587      /* Check the parameters */
;;;588      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;589      assert_param(IS_CAN_TRANSMITMAILBOX(Mailbox));
;;;590      /* abort transmission */
;;;591      switch (Mailbox)
000002  2901              CMP      r1,#1
000004  d007              BEQ      |L1.22|
000006  2902              CMP      r1,#2
000008  d10f              BNE      |L1.42|
00000a  e009              B        |L1.32|
                  |L1.12|
;;;592      {
;;;593        case (0): CANx->TSR |= CAN_TSR_ABRQ0;
00000c  6882              LDR      r2,[r0,#8]
00000e  f0420280          ORR      r2,r2,#0x80
000012  6082              STR      r2,[r0,#8]
;;;594          break;
000014  e00a              B        |L1.44|
                  |L1.22|
;;;595        case (1): CANx->TSR |= CAN_TSR_ABRQ1;
000016  6882              LDR      r2,[r0,#8]
000018  f4424200          ORR      r2,r2,#0x8000
00001c  6082              STR      r2,[r0,#8]
;;;596          break;
00001e  e005              B        |L1.44|
                  |L1.32|
;;;597        case (2): CANx->TSR |= CAN_TSR_ABRQ2;
000020  6882              LDR      r2,[r0,#8]
000022  f4420200          ORR      r2,r2,#0x800000
000026  6082              STR      r2,[r0,#8]
;;;598          break;
000028  e000              B        |L1.44|
                  |L1.42|
;;;599        default:
;;;600          break;
00002a  bf00              NOP      
                  |L1.44|
00002c  bf00              NOP                            ;594
;;;601      }
;;;602    }
00002e  4770              BX       lr
;;;603    
                          ENDP


                          AREA ||i.CAN_ClearFlag||, CODE, READONLY, ALIGN=2

                  CAN_ClearFlag PROC
;;;897      */
;;;898    void CAN_ClearFlag(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
000000  2200              MOVS     r2,#0
;;;899    {
;;;900      uint32_t flagtmp=0;
;;;901      /* Check the parameters */
;;;902      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;903      assert_param(IS_CAN_CLEAR_FLAG(CAN_FLAG));
;;;904      
;;;905      if (CAN_FLAG == CAN_FLAG_LEC) /* ESR register */
000002  4b0c              LDR      r3,|L2.52|
000004  4299              CMP      r1,r3
000006  d102              BNE      |L2.14|
;;;906      {
;;;907        /* Clear the selected CAN flags */
;;;908        CANx->ESR = (uint32_t)RESET;
000008  2300              MOVS     r3,#0
00000a  6183              STR      r3,[r0,#0x18]
00000c  e011              B        |L2.50|
                  |L2.14|
;;;909      }
;;;910      else /* MSR or TSR or RF0R or RF1R */
;;;911      {
;;;912        flagtmp = CAN_FLAG & 0x000FFFFF;
00000e  f3c10213          UBFX     r2,r1,#0,#20
;;;913    
;;;914        if ((CAN_FLAG & CAN_FLAGS_RF0R)!=(uint32_t)RESET)
000012  f0017300          AND      r3,r1,#0x2000000
000016  b10b              CBZ      r3,|L2.28|
;;;915        {
;;;916          /* Receive Flags */
;;;917          CANx->RF0R = (uint32_t)(flagtmp);
000018  60c2              STR      r2,[r0,#0xc]
00001a  e00a              B        |L2.50|
                  |L2.28|
;;;918        }
;;;919        else if ((CAN_FLAG & CAN_FLAGS_RF1R)!=(uint32_t)RESET)
00001c  f0016380          AND      r3,r1,#0x4000000
000020  b10b              CBZ      r3,|L2.38|
;;;920        {
;;;921          /* Receive Flags */
;;;922          CANx->RF1R = (uint32_t)(flagtmp);
000022  6102              STR      r2,[r0,#0x10]
000024  e005              B        |L2.50|
                  |L2.38|
;;;923        }
;;;924        else if ((CAN_FLAG & CAN_FLAGS_TSR)!=(uint32_t)RESET)
000026  f0016300          AND      r3,r1,#0x8000000
00002a  b10b              CBZ      r3,|L2.48|
;;;925        {
;;;926          /* Transmit Flags */
;;;927          CANx->TSR = (uint32_t)(flagtmp);
00002c  6082              STR      r2,[r0,#8]
00002e  e000              B        |L2.50|
                  |L2.48|
;;;928        }
;;;929        else /* If((CAN_FLAG & CAN_FLAGS_MSR)!=(uint32_t)RESET) */
;;;930        {
;;;931          /* Operating mode Flags */
;;;932          CANx->MSR = (uint32_t)(flagtmp);
000030  6042              STR      r2,[r0,#4]
                  |L2.50|
;;;933        }
;;;934      }
;;;935    }
000032  4770              BX       lr
;;;936    
                          ENDP

                  |L2.52|
                          DCD      0x30f00070

                          AREA ||i.CAN_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  CAN_ClearITPendingBit PROC
;;;1061     */
;;;1062   void CAN_ClearITPendingBit(CAN_TypeDef* CANx, uint32_t CAN_IT)
000000  f5b17f00          CMP      r1,#0x200
;;;1063   {
;;;1064     /* Check the parameters */
;;;1065     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1066     assert_param(IS_CAN_CLEAR_IT(CAN_IT));
;;;1067   
;;;1068     switch (CAN_IT)
000004  d03a              BEQ      |L3.124|
000006  dc0f              BGT      |L3.40|
000008  2920              CMP      r1,#0x20
00000a  d028              BEQ      |L3.94|
00000c  dc06              BGT      |L3.28|
00000e  2901              CMP      r1,#1
000010  d01c              BEQ      |L3.76|
000012  2904              CMP      r1,#4
000014  d01d              BEQ      |L3.82|
000016  2908              CMP      r1,#8
000018  d140              BNE      |L3.156|
00001a  e01d              B        |L3.88|
                  |L3.28|
00001c  2940              CMP      r1,#0x40
00001e  d021              BEQ      |L3.100|
000020  f5b17f80          CMP      r1,#0x100
000024  d13a              BNE      |L3.156|
000026  e026              B        |L3.118|
                  |L3.40|
000028  f5b14f00          CMP      r1,#0x8000
00002c  d031              BEQ      |L3.146|
00002e  dc06              BGT      |L3.62|
000030  f5b16f80          CMP      r1,#0x400
000034  d025              BEQ      |L3.130|
000036  f5b16f00          CMP      r1,#0x800
00003a  d12f              BNE      |L3.156|
00003c  e024              B        |L3.136|
                  |L3.62|
00003e  f5b13f80          CMP      r1,#0x10000
000042  d012              BEQ      |L3.106|
000044  f5b13f00          CMP      r1,#0x20000
000048  d128              BNE      |L3.156|
00004a  e011              B        |L3.112|
                  |L3.76|
;;;1069     {
;;;1070         case CAN_IT_TME:
;;;1071                 /* Clear CAN_TSR_RQCPx (rc_w1)*/
;;;1072   	      CANx->TSR = CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2;  
00004c  4a15              LDR      r2,|L3.164|
00004e  6082              STR      r2,[r0,#8]
;;;1073   	      break;
000050  e025              B        |L3.158|
                  |L3.82|
;;;1074         case CAN_IT_FF0:
;;;1075                 /* Clear CAN_RF0R_FULL0 (rc_w1)*/
;;;1076   	      CANx->RF0R = CAN_RF0R_FULL0; 
000052  2208              MOVS     r2,#8
000054  60c2              STR      r2,[r0,#0xc]
;;;1077   	      break;
000056  e022              B        |L3.158|
                  |L3.88|
;;;1078         case CAN_IT_FOV0:
;;;1079                 /* Clear CAN_RF0R_FOVR0 (rc_w1)*/
;;;1080   	      CANx->RF0R = CAN_RF0R_FOVR0; 
000058  2210              MOVS     r2,#0x10
00005a  60c2              STR      r2,[r0,#0xc]
;;;1081   	      break;
00005c  e01f              B        |L3.158|
                  |L3.94|
;;;1082         case CAN_IT_FF1:
;;;1083                 /* Clear CAN_RF1R_FULL1 (rc_w1)*/
;;;1084   	      CANx->RF1R = CAN_RF1R_FULL1;  
00005e  2208              MOVS     r2,#8
000060  6102              STR      r2,[r0,#0x10]
;;;1085   	      break;
000062  e01c              B        |L3.158|
                  |L3.100|
;;;1086         case CAN_IT_FOV1:
;;;1087                 /* Clear CAN_RF1R_FOVR1 (rc_w1)*/
;;;1088   	      CANx->RF1R = CAN_RF1R_FOVR1; 
000064  2210              MOVS     r2,#0x10
000066  6102              STR      r2,[r0,#0x10]
;;;1089   	      break;
000068  e019              B        |L3.158|
                  |L3.106|
;;;1090         case CAN_IT_WKU:
;;;1091                 /* Clear CAN_MSR_WKUI (rc_w1)*/
;;;1092   	      CANx->MSR = CAN_MSR_WKUI;  
00006a  2208              MOVS     r2,#8
00006c  6042              STR      r2,[r0,#4]
;;;1093   	      break;
00006e  e016              B        |L3.158|
                  |L3.112|
;;;1094         case CAN_IT_SLK:
;;;1095                 /* Clear CAN_MSR_SLAKI (rc_w1)*/ 
;;;1096   	      CANx->MSR = CAN_MSR_SLAKI;   
000070  2210              MOVS     r2,#0x10
000072  6042              STR      r2,[r0,#4]
;;;1097   	      break;
000074  e013              B        |L3.158|
                  |L3.118|
;;;1098         case CAN_IT_EWG:
;;;1099                 /* Clear CAN_MSR_ERRI (rc_w1) */
;;;1100   	      CANx->MSR = CAN_MSR_ERRI;
000076  2204              MOVS     r2,#4
000078  6042              STR      r2,[r0,#4]
;;;1101                 /* Note : the corresponding Flag is cleared by hardware depending of the CAN Bus status*/ 
;;;1102   	      break;
00007a  e010              B        |L3.158|
                  |L3.124|
;;;1103         case CAN_IT_EPV:
;;;1104                 /* Clear CAN_MSR_ERRI (rc_w1) */
;;;1105   	      CANx->MSR = CAN_MSR_ERRI; 
00007c  2204              MOVS     r2,#4
00007e  6042              STR      r2,[r0,#4]
;;;1106                 /* Note : the corresponding Flag is cleared by hardware depending of the CAN Bus status*/
;;;1107   	      break;
000080  e00d              B        |L3.158|
                  |L3.130|
;;;1108         case CAN_IT_BOF:
;;;1109                 /* Clear CAN_MSR_ERRI (rc_w1) */ 
;;;1110   	      CANx->MSR = CAN_MSR_ERRI; 
000082  2204              MOVS     r2,#4
000084  6042              STR      r2,[r0,#4]
;;;1111                 /* Note : the corresponding Flag is cleared by hardware depending of the CAN Bus status*/
;;;1112   	      break;
000086  e00a              B        |L3.158|
                  |L3.136|
;;;1113         case CAN_IT_LEC:
;;;1114                 /*  Clear LEC bits */
;;;1115   	      CANx->ESR = RESET; 
000088  2200              MOVS     r2,#0
00008a  6182              STR      r2,[r0,#0x18]
;;;1116                 /* Clear CAN_MSR_ERRI (rc_w1) */
;;;1117   	      CANx->MSR = CAN_MSR_ERRI; 
00008c  2204              MOVS     r2,#4
00008e  6042              STR      r2,[r0,#4]
;;;1118   	      break;
000090  e005              B        |L3.158|
                  |L3.146|
;;;1119         case CAN_IT_ERR:
;;;1120                 /*Clear LEC bits */
;;;1121   	      CANx->ESR = RESET; 
000092  2200              MOVS     r2,#0
000094  6182              STR      r2,[r0,#0x18]
;;;1122                 /* Clear CAN_MSR_ERRI (rc_w1) */
;;;1123   	      CANx->MSR = CAN_MSR_ERRI; 
000096  2204              MOVS     r2,#4
000098  6042              STR      r2,[r0,#4]
;;;1124   	      /* Note : BOFF, EPVF and EWGF Flags are cleared by hardware depending of the CAN Bus status*/
;;;1125   	      break;
00009a  e000              B        |L3.158|
                  |L3.156|
;;;1126         default :
;;;1127   	      break;
00009c  bf00              NOP      
                  |L3.158|
00009e  bf00              NOP                            ;1073
;;;1128      }
;;;1129   }
0000a0  4770              BX       lr
;;;1130   
                          ENDP

0000a2  0000              DCW      0x0000
                  |L3.164|
                          DCD      0x00010101

                          AREA ||i.CAN_DBGFreeze||, CODE, READONLY, ALIGN=1

                  CAN_DBGFreeze PROC
;;;702      */
;;;703    void CAN_DBGFreeze(CAN_TypeDef* CANx, FunctionalState NewState)
000000  b121              CBZ      r1,|L4.12|
;;;704    {
;;;705      /* Check the parameters */
;;;706      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;707      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;708      
;;;709      if (NewState != DISABLE)
;;;710      {
;;;711        /* Enable Debug Freeze  */
;;;712        CANx->MCR |= MCR_DBF;
000002  6802              LDR      r2,[r0,#0]
000004  f4423280          ORR      r2,r2,#0x10000
000008  6002              STR      r2,[r0,#0]
00000a  e003              B        |L4.20|
                  |L4.12|
;;;713      }
;;;714      else
;;;715      {
;;;716        /* Disable Debug Freeze */
;;;717        CANx->MCR &= ~MCR_DBF;
00000c  6802              LDR      r2,[r0,#0]
00000e  f4223280          BIC      r2,r2,#0x10000
000012  6002              STR      r2,[r0,#0]
                  |L4.20|
;;;718      }
;;;719    }
000014  4770              BX       lr
;;;720    
                          ENDP


                          AREA ||i.CAN_DeInit||, CODE, READONLY, ALIGN=2

                  CAN_DeInit PROC
;;;113      */
;;;114    void CAN_DeInit(CAN_TypeDef* CANx)
000000  b510              PUSH     {r4,lr}
;;;115    {
000002  4604              MOV      r4,r0
;;;116      /* Check the parameters */
;;;117      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;118     
;;;119      if (CANx == CAN1)
000004  480b              LDR      r0,|L5.52|
000006  4284              CMP      r4,r0
000008  d109              BNE      |L5.30|
;;;120      {
;;;121        /* Enable CAN1 reset state */
;;;122        RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, ENABLE);
00000a  2101              MOVS     r1,#1
00000c  0648              LSLS     r0,r1,#25
00000e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;123        /* Release CAN1 from reset state */
;;;124        RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, DISABLE);
000012  2100              MOVS     r1,#0
000014  f04f7000          MOV      r0,#0x2000000
000018  f7fffffe          BL       RCC_APB1PeriphResetCmd
00001c  e008              B        |L5.48|
                  |L5.30|
;;;125      }
;;;126      else
;;;127      {  
;;;128        /* Enable CAN2 reset state */
;;;129        RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, ENABLE);
00001e  2101              MOVS     r1,#1
000020  0688              LSLS     r0,r1,#26
000022  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;130        /* Release CAN2 from reset state */
;;;131        RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, DISABLE);
000026  2100              MOVS     r1,#0
000028  f04f6080          MOV      r0,#0x4000000
00002c  f7fffffe          BL       RCC_APB1PeriphResetCmd
                  |L5.48|
;;;132      }
;;;133    }
000030  bd10              POP      {r4,pc}
;;;134    
                          ENDP

000032  0000              DCW      0x0000
                  |L5.52|
                          DCD      0x40006400

                          AREA ||i.CAN_FIFORelease||, CODE, READONLY, ALIGN=1

                  CAN_FIFORelease PROC
;;;609      */
;;;610    void CAN_FIFORelease(CAN_TypeDef* CANx, uint8_t FIFONumber)
000000  b921              CBNZ     r1,|L6.12|
;;;611    {
;;;612      /* Check the parameters */
;;;613      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;614      assert_param(IS_CAN_FIFO(FIFONumber));
;;;615      /* Release FIFO0 */
;;;616      if (FIFONumber == CAN_FIFO0)
;;;617      {
;;;618        CANx->RF0R |= CAN_RF0R_RFOM0;
000002  68c2              LDR      r2,[r0,#0xc]
000004  f0420220          ORR      r2,r2,#0x20
000008  60c2              STR      r2,[r0,#0xc]
00000a  e003              B        |L6.20|
                  |L6.12|
;;;619      }
;;;620      /* Release FIFO1 */
;;;621      else /* FIFONumber == CAN_FIFO1 */
;;;622      {
;;;623        CANx->RF1R |= CAN_RF1R_RFOM1;
00000c  6902              LDR      r2,[r0,#0x10]
00000e  f0420220          ORR      r2,r2,#0x20
000012  6102              STR      r2,[r0,#0x10]
                  |L6.20|
;;;624      }
;;;625    }
000014  4770              BX       lr
;;;626    
                          ENDP


                          AREA ||i.CAN_FilterInit||, CODE, READONLY, ALIGN=2

                  CAN_FilterInit PROC
;;;278      */
;;;279    void CAN_FilterInit(CAN_FilterInitTypeDef* CAN_FilterInitStruct)
000000  b510              PUSH     {r4,lr}
;;;280    {
;;;281      uint32_t filter_number_bit_pos = 0;
000002  2100              MOVS     r1,#0
;;;282      /* Check the parameters */
;;;283      assert_param(IS_CAN_FILTER_NUMBER(CAN_FilterInitStruct->CAN_FilterNumber));
;;;284      assert_param(IS_CAN_FILTER_MODE(CAN_FilterInitStruct->CAN_FilterMode));
;;;285      assert_param(IS_CAN_FILTER_SCALE(CAN_FilterInitStruct->CAN_FilterScale));
;;;286      assert_param(IS_CAN_FILTER_FIFO(CAN_FilterInitStruct->CAN_FilterFIFOAssignment));
;;;287      assert_param(IS_FUNCTIONAL_STATE(CAN_FilterInitStruct->CAN_FilterActivation));
;;;288    
;;;289      filter_number_bit_pos = ((uint32_t)0x00000001) << CAN_FilterInitStruct->CAN_FilterNumber;
000004  7a83              LDRB     r3,[r0,#0xa]
000006  2201              MOVS     r2,#1
000008  fa02f103          LSL      r1,r2,r3
;;;290    
;;;291      /* Initialisation mode for the filter */
;;;292      CAN1->FMR |= FMR_FINIT;
00000c  4a3d              LDR      r2,|L7.260|
00000e  6812              LDR      r2,[r2,#0]
000010  f0420201          ORR      r2,r2,#1
000014  4b3b              LDR      r3,|L7.260|
000016  601a              STR      r2,[r3,#0]
;;;293    
;;;294      /* Filter Deactivation */
;;;295      CAN1->FA1R &= ~(uint32_t)filter_number_bit_pos;
000018  4a3a              LDR      r2,|L7.260|
00001a  321c              ADDS     r2,r2,#0x1c
00001c  6812              LDR      r2,[r2,#0]
00001e  438a              BICS     r2,r2,r1
000020  4b38              LDR      r3,|L7.260|
000022  331c              ADDS     r3,r3,#0x1c
000024  601a              STR      r2,[r3,#0]
;;;296    
;;;297      /* Filter Scale */
;;;298      if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_16bit)
000026  7b02              LDRB     r2,[r0,#0xc]
000028  b9ca              CBNZ     r2,|L7.94|
;;;299      {
;;;300        /* 16-bit scale for the filter */
;;;301        CAN1->FS1R &= ~(uint32_t)filter_number_bit_pos;
00002a  4a36              LDR      r2,|L7.260|
00002c  320c              ADDS     r2,r2,#0xc
00002e  6812              LDR      r2,[r2,#0]
000030  438a              BICS     r2,r2,r1
000032  4b34              LDR      r3,|L7.260|
000034  330c              ADDS     r3,r3,#0xc
000036  601a              STR      r2,[r3,#0]
;;;302    
;;;303        /* First 16-bit identifier and First 16-bit mask */
;;;304        /* Or First 16-bit identifier and Second 16-bit identifier */
;;;305        CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
000038  8842              LDRH     r2,[r0,#2]
00003a  88c3              LDRH     r3,[r0,#6]
00003c  ea424303          ORR      r3,r2,r3,LSL #16
000040  4a30              LDR      r2,|L7.260|
000042  3240              ADDS     r2,r2,#0x40
000044  7a84              LDRB     r4,[r0,#0xa]
000046  f8423034          STR      r3,[r2,r4,LSL #3]
;;;306        ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow) << 16) |
;;;307            (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
;;;308    
;;;309        /* Second 16-bit identifier and Second 16-bit mask */
;;;310        /* Or Third 16-bit identifier and Fourth 16-bit identifier */
;;;311        CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
00004a  8802              LDRH     r2,[r0,#0]
00004c  8883              LDRH     r3,[r0,#4]
00004e  ea424303          ORR      r3,r2,r3,LSL #16
000052  4a2c              LDR      r2,|L7.260|
000054  3240              ADDS     r2,r2,#0x40
000056  7a84              LDRB     r4,[r0,#0xa]
000058  eb0202c4          ADD      r2,r2,r4,LSL #3
00005c  6053              STR      r3,[r2,#4]
                  |L7.94|
;;;312        ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
;;;313            (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh);
;;;314      }
;;;315    
;;;316      if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_32bit)
00005e  7b02              LDRB     r2,[r0,#0xc]
000060  2a01              CMP      r2,#1
000062  d119              BNE      |L7.152|
;;;317      {
;;;318        /* 32-bit scale for the filter */
;;;319        CAN1->FS1R |= filter_number_bit_pos;
000064  4a27              LDR      r2,|L7.260|
000066  320c              ADDS     r2,r2,#0xc
000068  6812              LDR      r2,[r2,#0]
00006a  430a              ORRS     r2,r2,r1
00006c  4b25              LDR      r3,|L7.260|
00006e  330c              ADDS     r3,r3,#0xc
000070  601a              STR      r2,[r3,#0]
;;;320        /* 32-bit identifier or First 32-bit identifier */
;;;321        CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
000072  8842              LDRH     r2,[r0,#2]
000074  8803              LDRH     r3,[r0,#0]
000076  ea424303          ORR      r3,r2,r3,LSL #16
00007a  4a22              LDR      r2,|L7.260|
00007c  3240              ADDS     r2,r2,#0x40
00007e  7a84              LDRB     r4,[r0,#0xa]
000080  f8423034          STR      r3,[r2,r4,LSL #3]
;;;322        ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh) << 16) |
;;;323            (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
;;;324        /* 32-bit mask or Second 32-bit identifier */
;;;325        CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
000084  88c2              LDRH     r2,[r0,#6]
000086  8883              LDRH     r3,[r0,#4]
000088  ea424303          ORR      r3,r2,r3,LSL #16
00008c  4a1d              LDR      r2,|L7.260|
00008e  3240              ADDS     r2,r2,#0x40
000090  7a84              LDRB     r4,[r0,#0xa]
000092  eb0202c4          ADD      r2,r2,r4,LSL #3
000096  6053              STR      r3,[r2,#4]
                  |L7.152|
;;;326        ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
;;;327            (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow);
;;;328      }
;;;329    
;;;330      /* Filter Mode */
;;;331      if (CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdMask)
000098  7ac2              LDRB     r2,[r0,#0xb]
00009a  b93a              CBNZ     r2,|L7.172|
;;;332      {
;;;333        /*Id/Mask mode for the filter*/
;;;334        CAN1->FM1R &= ~(uint32_t)filter_number_bit_pos;
00009c  4a19              LDR      r2,|L7.260|
00009e  1d12              ADDS     r2,r2,#4
0000a0  6812              LDR      r2,[r2,#0]
0000a2  438a              BICS     r2,r2,r1
0000a4  4b17              LDR      r3,|L7.260|
0000a6  1d1b              ADDS     r3,r3,#4
0000a8  601a              STR      r2,[r3,#0]
0000aa  e006              B        |L7.186|
                  |L7.172|
;;;335      }
;;;336      else /* CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdList */
;;;337      {
;;;338        /*Identifier list mode for the filter*/
;;;339        CAN1->FM1R |= (uint32_t)filter_number_bit_pos;
0000ac  4a15              LDR      r2,|L7.260|
0000ae  1d12              ADDS     r2,r2,#4
0000b0  6812              LDR      r2,[r2,#0]
0000b2  430a              ORRS     r2,r2,r1
0000b4  4b13              LDR      r3,|L7.260|
0000b6  1d1b              ADDS     r3,r3,#4
0000b8  601a              STR      r2,[r3,#0]
                  |L7.186|
;;;340      }
;;;341    
;;;342      /* Filter FIFO assignment */
;;;343      if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_FilterFIFO0)
0000ba  8902              LDRH     r2,[r0,#8]
0000bc  b932              CBNZ     r2,|L7.204|
;;;344      {
;;;345        /* FIFO 0 assignation for the filter */
;;;346        CAN1->FFA1R &= ~(uint32_t)filter_number_bit_pos;
0000be  4a11              LDR      r2,|L7.260|
0000c0  3214              ADDS     r2,r2,#0x14
0000c2  6812              LDR      r2,[r2,#0]
0000c4  438a              BICS     r2,r2,r1
0000c6  4b0f              LDR      r3,|L7.260|
0000c8  3314              ADDS     r3,r3,#0x14
0000ca  601a              STR      r2,[r3,#0]
                  |L7.204|
;;;347      }
;;;348    
;;;349      if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_FilterFIFO1)
0000cc  8902              LDRH     r2,[r0,#8]
0000ce  2a01              CMP      r2,#1
0000d0  d106              BNE      |L7.224|
;;;350      {
;;;351        /* FIFO 1 assignation for the filter */
;;;352        CAN1->FFA1R |= (uint32_t)filter_number_bit_pos;
0000d2  4a0c              LDR      r2,|L7.260|
0000d4  3214              ADDS     r2,r2,#0x14
0000d6  6812              LDR      r2,[r2,#0]
0000d8  430a              ORRS     r2,r2,r1
0000da  4b0a              LDR      r3,|L7.260|
0000dc  3314              ADDS     r3,r3,#0x14
0000de  601a              STR      r2,[r3,#0]
                  |L7.224|
;;;353      }
;;;354      
;;;355      /* Filter activation */
;;;356      if (CAN_FilterInitStruct->CAN_FilterActivation == ENABLE)
0000e0  7b42              LDRB     r2,[r0,#0xd]
0000e2  2a01              CMP      r2,#1
0000e4  d106              BNE      |L7.244|
;;;357      {
;;;358        CAN1->FA1R |= filter_number_bit_pos;
0000e6  4a07              LDR      r2,|L7.260|
0000e8  321c              ADDS     r2,r2,#0x1c
0000ea  6812              LDR      r2,[r2,#0]
0000ec  430a              ORRS     r2,r2,r1
0000ee  4b05              LDR      r3,|L7.260|
0000f0  331c              ADDS     r3,r3,#0x1c
0000f2  601a              STR      r2,[r3,#0]
                  |L7.244|
;;;359      }
;;;360    
;;;361      /* Leave the initialisation mode for the filter */
;;;362      CAN1->FMR &= ~FMR_FINIT;
0000f4  4a03              LDR      r2,|L7.260|
0000f6  6812              LDR      r2,[r2,#0]
0000f8  f0220201          BIC      r2,r2,#1
0000fc  4b01              LDR      r3,|L7.260|
0000fe  601a              STR      r2,[r3,#0]
;;;363    }
000100  bd10              POP      {r4,pc}
;;;364    
                          ENDP

000102  0000              DCW      0x0000
                  |L7.260|
                          DCD      0x40006600

                          AREA ||i.CAN_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  CAN_GetFlagStatus PROC
;;;797      */
;;;798    FlagStatus CAN_GetFlagStatus(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
000000  b510              PUSH     {r4,lr}
;;;799    {
000002  4602              MOV      r2,r0
;;;800      FlagStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;801      
;;;802      /* Check the parameters */
;;;803      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;804      assert_param(IS_CAN_GET_FLAG(CAN_FLAG));
;;;805      
;;;806    
;;;807      if((CAN_FLAG & CAN_FLAGS_ESR) != (uint32_t)RESET)
000006  f4010370          AND      r3,r1,#0xf00000
00000a  b143              CBZ      r3,|L8.30|
;;;808      { 
;;;809        /* Check the status of the specified CAN flag */
;;;810        if ((CANx->ESR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
00000c  6993              LDR      r3,[r2,#0x18]
00000e  f3c10413          UBFX     r4,r1,#0,#20
000012  4023              ANDS     r3,r3,r4
000014  b10b              CBZ      r3,|L8.26|
;;;811        { 
;;;812          /* CAN_FLAG is set */
;;;813          bitstatus = SET;
000016  2001              MOVS     r0,#1
000018  e02d              B        |L8.118|
                  |L8.26|
;;;814        }
;;;815        else
;;;816        { 
;;;817          /* CAN_FLAG is reset */
;;;818          bitstatus = RESET;
00001a  2000              MOVS     r0,#0
00001c  e02b              B        |L8.118|
                  |L8.30|
;;;819        }
;;;820      }
;;;821      else if((CAN_FLAG & CAN_FLAGS_MSR) != (uint32_t)RESET)
00001e  f0017380          AND      r3,r1,#0x1000000
000022  b143              CBZ      r3,|L8.54|
;;;822      { 
;;;823        /* Check the status of the specified CAN flag */
;;;824        if ((CANx->MSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
000024  6853              LDR      r3,[r2,#4]
000026  f3c10413          UBFX     r4,r1,#0,#20
00002a  4023              ANDS     r3,r3,r4
00002c  b10b              CBZ      r3,|L8.50|
;;;825        { 
;;;826          /* CAN_FLAG is set */
;;;827          bitstatus = SET;
00002e  2001              MOVS     r0,#1
000030  e021              B        |L8.118|
                  |L8.50|
;;;828        }
;;;829        else
;;;830        { 
;;;831          /* CAN_FLAG is reset */
;;;832          bitstatus = RESET;
000032  2000              MOVS     r0,#0
000034  e01f              B        |L8.118|
                  |L8.54|
;;;833        }
;;;834      }
;;;835      else if((CAN_FLAG & CAN_FLAGS_TSR) != (uint32_t)RESET)
000036  f0016300          AND      r3,r1,#0x8000000
00003a  b143              CBZ      r3,|L8.78|
;;;836      { 
;;;837        /* Check the status of the specified CAN flag */
;;;838        if ((CANx->TSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
00003c  6893              LDR      r3,[r2,#8]
00003e  f3c10413          UBFX     r4,r1,#0,#20
000042  4023              ANDS     r3,r3,r4
000044  b10b              CBZ      r3,|L8.74|
;;;839        { 
;;;840          /* CAN_FLAG is set */
;;;841          bitstatus = SET;
000046  2001              MOVS     r0,#1
000048  e015              B        |L8.118|
                  |L8.74|
;;;842        }
;;;843        else
;;;844        { 
;;;845          /* CAN_FLAG is reset */
;;;846          bitstatus = RESET;
00004a  2000              MOVS     r0,#0
00004c  e013              B        |L8.118|
                  |L8.78|
;;;847        }
;;;848      }
;;;849      else if((CAN_FLAG & CAN_FLAGS_RF0R) != (uint32_t)RESET)
00004e  f0017300          AND      r3,r1,#0x2000000
000052  b143              CBZ      r3,|L8.102|
;;;850      { 
;;;851        /* Check the status of the specified CAN flag */
;;;852        if ((CANx->RF0R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
000054  68d3              LDR      r3,[r2,#0xc]
000056  f3c10413          UBFX     r4,r1,#0,#20
00005a  4023              ANDS     r3,r3,r4
00005c  b10b              CBZ      r3,|L8.98|
;;;853        { 
;;;854          /* CAN_FLAG is set */
;;;855          bitstatus = SET;
00005e  2001              MOVS     r0,#1
000060  e009              B        |L8.118|
                  |L8.98|
;;;856        }
;;;857        else
;;;858        { 
;;;859          /* CAN_FLAG is reset */
;;;860          bitstatus = RESET;
000062  2000              MOVS     r0,#0
000064  e007              B        |L8.118|
                  |L8.102|
;;;861        }
;;;862      }
;;;863      else /* If(CAN_FLAG & CAN_FLAGS_RF1R != (uint32_t)RESET) */
;;;864      { 
;;;865        /* Check the status of the specified CAN flag */
;;;866        if ((uint32_t)(CANx->RF1R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
000066  6913              LDR      r3,[r2,#0x10]
000068  f3c10413          UBFX     r4,r1,#0,#20
00006c  4023              ANDS     r3,r3,r4
00006e  b10b              CBZ      r3,|L8.116|
;;;867        { 
;;;868          /* CAN_FLAG is set */
;;;869          bitstatus = SET;
000070  2001              MOVS     r0,#1
000072  e000              B        |L8.118|
                  |L8.116|
;;;870        }
;;;871        else
;;;872        { 
;;;873          /* CAN_FLAG is reset */
;;;874          bitstatus = RESET;
000074  2000              MOVS     r0,#0
                  |L8.118|
;;;875        }
;;;876      }
;;;877      /* Return the CAN_FLAG status */
;;;878      return  bitstatus;
;;;879    }
000076  bd10              POP      {r4,pc}
;;;880    
                          ENDP


                          AREA ||i.CAN_GetITStatus||, CODE, READONLY, ALIGN=2

                  CAN_GetITStatus PROC
;;;957      */
;;;958    ITStatus CAN_GetITStatus(CAN_TypeDef* CANx, uint32_t CAN_IT)
000000  b570              PUSH     {r4-r6,lr}
;;;959    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;960      ITStatus itstatus = RESET;
000006  2600              MOVS     r6,#0
;;;961      /* Check the parameters */
;;;962      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;963      assert_param(IS_CAN_IT(CAN_IT));
;;;964      
;;;965      /* check the enable interrupt bit */
;;;966     if((CANx->IER & CAN_IT) != RESET)
000008  6960              LDR      r0,[r4,#0x14]
00000a  4028              ANDS     r0,r0,r5
00000c  2800              CMP      r0,#0
00000e  d071              BEQ      |L9.244|
;;;967     {
;;;968       /* in case the Interrupt is enabled, .... */
;;;969        switch (CAN_IT)
000010  f5b57f80          CMP      r5,#0x100
000014  d05c              BEQ      |L9.208|
000016  dc10              BGT      |L9.58|
000018  2d08              CMP      r5,#8
00001a  d035              BEQ      |L9.136|
00001c  dc06              BGT      |L9.44|
00001e  2d01              CMP      r5,#1
000020  d020              BEQ      |L9.100|
000022  2d02              CMP      r5,#2
000024  d024              BEQ      |L9.112|
000026  2d04              CMP      r5,#4
000028  d177              BNE      |L9.282|
00002a  e027              B        |L9.124|
                  |L9.44|
00002c  2d10              CMP      r5,#0x10
00002e  d031              BEQ      |L9.148|
000030  2d20              CMP      r5,#0x20
000032  d035              BEQ      |L9.160|
000034  2d40              CMP      r5,#0x40
000036  d170              BNE      |L9.282|
000038  e038              B        |L9.172|
                  |L9.58|
00003a  f5b54f00          CMP      r5,#0x8000
00003e  d060              BEQ      |L9.258|
000040  dc09              BGT      |L9.86|
000042  f5b57f00          CMP      r5,#0x200
000046  d049              BEQ      |L9.220|
000048  f5b56f80          CMP      r5,#0x400
00004c  d04c              BEQ      |L9.232|
00004e  f5b56f00          CMP      r5,#0x800
000052  d162              BNE      |L9.282|
000054  e04f              B        |L9.246|
                  |L9.86|
000056  f5b53f80          CMP      r5,#0x10000
00005a  d02d              BEQ      |L9.184|
00005c  f5b53f00          CMP      r5,#0x20000
000060  d15b              BNE      |L9.282|
000062  e02f              B        |L9.196|
                  |L9.100|
;;;970        {
;;;971          case CAN_IT_TME:
;;;972                   /* Check CAN_TSR_RQCPx bits */
;;;973    	      itstatus = CheckITStatus(CANx->TSR, CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2);  
000064  68a0              LDR      r0,[r4,#8]
000066  4930              LDR      r1,|L9.296|
000068  f7fffffe          BL       CheckITStatus
00006c  4606              MOV      r6,r0
;;;974    	      break;
00006e  e056              B        |L9.286|
                  |L9.112|
;;;975          case CAN_IT_FMP0:
;;;976                   /* Check CAN_RF0R_FMP0 bit */
;;;977    	      itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FMP0);  
000070  68e0              LDR      r0,[r4,#0xc]
000072  2103              MOVS     r1,#3
000074  f7fffffe          BL       CheckITStatus
000078  4606              MOV      r6,r0
;;;978    	      break;
00007a  e050              B        |L9.286|
                  |L9.124|
;;;979          case CAN_IT_FF0:
;;;980                   /* Check CAN_RF0R_FULL0 bit */
;;;981                  itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FULL0);  
00007c  68e0              LDR      r0,[r4,#0xc]
00007e  2108              MOVS     r1,#8
000080  f7fffffe          BL       CheckITStatus
000084  4606              MOV      r6,r0
;;;982    	      break;
000086  e04a              B        |L9.286|
                  |L9.136|
;;;983          case CAN_IT_FOV0:
;;;984                   /* Check CAN_RF0R_FOVR0 bit */
;;;985                  itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FOVR0);  
000088  68e0              LDR      r0,[r4,#0xc]
00008a  2110              MOVS     r1,#0x10
00008c  f7fffffe          BL       CheckITStatus
000090  4606              MOV      r6,r0
;;;986    	      break;
000092  e044              B        |L9.286|
                  |L9.148|
;;;987          case CAN_IT_FMP1:
;;;988                   /* Check CAN_RF1R_FMP1 bit */
;;;989                  itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FMP1);  
000094  6920              LDR      r0,[r4,#0x10]
000096  2103              MOVS     r1,#3
000098  f7fffffe          BL       CheckITStatus
00009c  4606              MOV      r6,r0
;;;990    	      break;
00009e  e03e              B        |L9.286|
                  |L9.160|
;;;991          case CAN_IT_FF1:
;;;992                   /* Check CAN_RF1R_FULL1 bit */
;;;993    	      itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FULL1);  
0000a0  6920              LDR      r0,[r4,#0x10]
0000a2  2108              MOVS     r1,#8
0000a4  f7fffffe          BL       CheckITStatus
0000a8  4606              MOV      r6,r0
;;;994    	      break;
0000aa  e038              B        |L9.286|
                  |L9.172|
;;;995          case CAN_IT_FOV1:
;;;996                   /* Check CAN_RF1R_FOVR1 bit */
;;;997    	      itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FOVR1);  
0000ac  6920              LDR      r0,[r4,#0x10]
0000ae  2110              MOVS     r1,#0x10
0000b0  f7fffffe          BL       CheckITStatus
0000b4  4606              MOV      r6,r0
;;;998    	      break;
0000b6  e032              B        |L9.286|
                  |L9.184|
;;;999          case CAN_IT_WKU:
;;;1000                  /* Check CAN_MSR_WKUI bit */
;;;1001                 itstatus = CheckITStatus(CANx->MSR, CAN_MSR_WKUI);  
0000b8  6860              LDR      r0,[r4,#4]
0000ba  2108              MOVS     r1,#8
0000bc  f7fffffe          BL       CheckITStatus
0000c0  4606              MOV      r6,r0
;;;1002   	      break;
0000c2  e02c              B        |L9.286|
                  |L9.196|
;;;1003         case CAN_IT_SLK:
;;;1004                  /* Check CAN_MSR_SLAKI bit */
;;;1005   	      itstatus = CheckITStatus(CANx->MSR, CAN_MSR_SLAKI);  
0000c4  6860              LDR      r0,[r4,#4]
0000c6  2110              MOVS     r1,#0x10
0000c8  f7fffffe          BL       CheckITStatus
0000cc  4606              MOV      r6,r0
;;;1006   	      break;
0000ce  e026              B        |L9.286|
                  |L9.208|
;;;1007         case CAN_IT_EWG:
;;;1008                  /* Check CAN_ESR_EWGF bit */
;;;1009   	      itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EWGF);  
0000d0  69a0              LDR      r0,[r4,#0x18]
0000d2  2101              MOVS     r1,#1
0000d4  f7fffffe          BL       CheckITStatus
0000d8  4606              MOV      r6,r0
;;;1010   	      break;
0000da  e020              B        |L9.286|
                  |L9.220|
;;;1011         case CAN_IT_EPV:
;;;1012                  /* Check CAN_ESR_EPVF bit */
;;;1013   	     itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EPVF);  
0000dc  69a0              LDR      r0,[r4,#0x18]
0000de  2102              MOVS     r1,#2
0000e0  f7fffffe          BL       CheckITStatus
0000e4  4606              MOV      r6,r0
;;;1014   	      break;
0000e6  e01a              B        |L9.286|
                  |L9.232|
;;;1015         case CAN_IT_BOF:
;;;1016                  /* Check CAN_ESR_BOFF bit */
;;;1017   	     itstatus = CheckITStatus(CANx->ESR, CAN_ESR_BOFF);  
0000e8  69a0              LDR      r0,[r4,#0x18]
0000ea  2104              MOVS     r1,#4
0000ec  f7fffffe          BL       CheckITStatus
0000f0  4606              MOV      r6,r0
;;;1018   	      break;
0000f2  e014              B        |L9.286|
                  |L9.244|
0000f4  e014              B        |L9.288|
                  |L9.246|
;;;1019         case CAN_IT_LEC:
;;;1020                  /* Check CAN_ESR_LEC bit */
;;;1021   	     itstatus = CheckITStatus(CANx->ESR, CAN_ESR_LEC);  
0000f6  69a0              LDR      r0,[r4,#0x18]
0000f8  2170              MOVS     r1,#0x70
0000fa  f7fffffe          BL       CheckITStatus
0000fe  4606              MOV      r6,r0
;;;1022   	      break;
000100  e00d              B        |L9.286|
                  |L9.258|
;;;1023         case CAN_IT_ERR:
;;;1024                  /* Check CAN_MSR_ERRI, CAN_ESR_EWGF, CAN_ESR_EPVF, CAN_ESR_BOFF and CAN_ESR_LEC  bits */
;;;1025   	      itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EWGF|CAN_ESR_EPVF|CAN_ESR_BOFF|CAN_ESR_LEC); 
000102  69a0              LDR      r0,[r4,#0x18]
000104  2177              MOVS     r1,#0x77
000106  f7fffffe          BL       CheckITStatus
00010a  4606              MOV      r6,r0
;;;1026                 itstatus |= CheckITStatus(CANx->MSR, CAN_MSR_ERRI); 
00010c  6860              LDR      r0,[r4,#4]
00010e  2104              MOVS     r1,#4
000110  f7fffffe          BL       CheckITStatus
000114  4306              ORRS     r6,r6,r0
;;;1027   	      break;
000116  e002              B        |L9.286|
000118  e7ff              B        |L9.282|
                  |L9.282|
;;;1028         default :
;;;1029                  /* in case of error, return RESET */
;;;1030                 itstatus = RESET;
00011a  2600              MOVS     r6,#0
;;;1031                 break;
00011c  bf00              NOP      
                  |L9.286|
00011e  e000              B        |L9.290|
                  |L9.288|
;;;1032       }
;;;1033     }
;;;1034     else
;;;1035     {
;;;1036      /* in case the Interrupt is not enabled, return RESET */
;;;1037       itstatus  = RESET;
000120  2600              MOVS     r6,#0
                  |L9.290|
;;;1038     }
;;;1039     
;;;1040     /* Return the CAN_IT status */
;;;1041     return  itstatus;
000122  4630              MOV      r0,r6
;;;1042   }
000124  bd70              POP      {r4-r6,pc}
;;;1043   
                          ENDP

000126  0000              DCW      0x0000
                  |L9.296|
                          DCD      0x00010101

                          AREA ||i.CAN_ITConfig||, CODE, READONLY, ALIGN=1

                  CAN_ITConfig PROC
;;;438      */
;;;439    void CAN_ITConfig(CAN_TypeDef* CANx, uint32_t CAN_IT, FunctionalState NewState)
000000  b11a              CBZ      r2,|L10.10|
;;;440    {
;;;441      /* Check the parameters */
;;;442      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;443      assert_param(IS_CAN_IT(CAN_IT));
;;;444      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;445    
;;;446      if (NewState != DISABLE)
;;;447      {
;;;448        /* Enable the selected CANx interrupt */
;;;449        CANx->IER |= CAN_IT;
000002  6943              LDR      r3,[r0,#0x14]
000004  430b              ORRS     r3,r3,r1
000006  6143              STR      r3,[r0,#0x14]
000008  e002              B        |L10.16|
                  |L10.10|
;;;450      }
;;;451      else
;;;452      {
;;;453        /* Disable the selected CANx interrupt */
;;;454        CANx->IER &= ~CAN_IT;
00000a  6943              LDR      r3,[r0,#0x14]
00000c  438b              BICS     r3,r3,r1
00000e  6143              STR      r3,[r0,#0x14]
                  |L10.16|
;;;455      }
;;;456    }
000010  4770              BX       lr
;;;457    
                          ENDP


                          AREA ||i.CAN_Init||, CODE, READONLY, ALIGN=1

                  CAN_Init PROC
;;;143      */
;;;144    uint8_t CAN_Init(CAN_TypeDef* CANx, CAN_InitTypeDef* CAN_InitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;145    {
000002  4602              MOV      r2,r0
;;;146      uint8_t InitStatus = CANINITFAILED;
000004  2000              MOVS     r0,#0
;;;147      uint32_t wait_ack = 0x00000000;
000006  2300              MOVS     r3,#0
;;;148      /* Check the parameters */
;;;149      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;150      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TTCM));
;;;151      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_ABOM));
;;;152      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_AWUM));
;;;153      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_NART));
;;;154      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_RFLM));
;;;155      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TXFP));
;;;156      assert_param(IS_CAN_MODE(CAN_InitStruct->CAN_Mode));
;;;157      assert_param(IS_CAN_SJW(CAN_InitStruct->CAN_SJW));
;;;158      assert_param(IS_CAN_BS1(CAN_InitStruct->CAN_BS1));
;;;159      assert_param(IS_CAN_BS2(CAN_InitStruct->CAN_BS2));
;;;160      assert_param(IS_CAN_PRESCALER(CAN_InitStruct->CAN_Prescaler));
;;;161    
;;;162      /* exit from sleep mode */
;;;163      CANx->MCR &= (~(uint32_t)CAN_MCR_SLEEP);
000008  6814              LDR      r4,[r2,#0]
00000a  f0240402          BIC      r4,r4,#2
00000e  6014              STR      r4,[r2,#0]
;;;164    
;;;165      /* Request initialisation */
;;;166      CANx->MCR |= CAN_MCR_INRQ ;
000010  6814              LDR      r4,[r2,#0]
000012  f0440401          ORR      r4,r4,#1
000016  6014              STR      r4,[r2,#0]
;;;167    
;;;168      /* Wait the acknowledge */
;;;169      while (((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
000018  e000              B        |L11.28|
                  |L11.26|
;;;170      {
;;;171        wait_ack++;
00001a  1c5b              ADDS     r3,r3,#1
                  |L11.28|
00001c  6854              LDR      r4,[r2,#4]            ;169
00001e  f0040401          AND      r4,r4,#1              ;169
000022  b91c              CBNZ     r4,|L11.44|
000024  f64f74ff          MOV      r4,#0xffff            ;169
000028  42a3              CMP      r3,r4                 ;169
00002a  d1f6              BNE      |L11.26|
                  |L11.44|
;;;172      }
;;;173    
;;;174      /* ...and check acknowledged */
;;;175      if ((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK)
00002c  6854              LDR      r4,[r2,#4]
00002e  f0040401          AND      r4,r4,#1
000032  b90c              CBNZ     r4,|L11.56|
;;;176      {
;;;177        InitStatus = CANINITFAILED;
000034  2000              MOVS     r0,#0
000036  e06c              B        |L11.274|
                  |L11.56|
;;;178      }
;;;179      else 
;;;180      {
;;;181        /* Set the time triggered communication mode */
;;;182        if (CAN_InitStruct->CAN_TTCM == ENABLE)
000038  798c              LDRB     r4,[r1,#6]
00003a  2c01              CMP      r4,#1
00003c  d104              BNE      |L11.72|
;;;183        {
;;;184          CANx->MCR |= CAN_MCR_TTCM;
00003e  6814              LDR      r4,[r2,#0]
000040  f0440480          ORR      r4,r4,#0x80
000044  6014              STR      r4,[r2,#0]
000046  e003              B        |L11.80|
                  |L11.72|
;;;185        }
;;;186        else
;;;187        {
;;;188          CANx->MCR &= ~(uint32_t)CAN_MCR_TTCM;
000048  6814              LDR      r4,[r2,#0]
00004a  f0240480          BIC      r4,r4,#0x80
00004e  6014              STR      r4,[r2,#0]
                  |L11.80|
;;;189        }
;;;190    
;;;191        /* Set the automatic bus-off management */
;;;192        if (CAN_InitStruct->CAN_ABOM == ENABLE)
000050  79cc              LDRB     r4,[r1,#7]
000052  2c01              CMP      r4,#1
000054  d104              BNE      |L11.96|
;;;193        {
;;;194          CANx->MCR |= CAN_MCR_ABOM;
000056  6814              LDR      r4,[r2,#0]
000058  f0440440          ORR      r4,r4,#0x40
00005c  6014              STR      r4,[r2,#0]
00005e  e003              B        |L11.104|
                  |L11.96|
;;;195        }
;;;196        else
;;;197        {
;;;198          CANx->MCR &= ~(uint32_t)CAN_MCR_ABOM;
000060  6814              LDR      r4,[r2,#0]
000062  f0240440          BIC      r4,r4,#0x40
000066  6014              STR      r4,[r2,#0]
                  |L11.104|
;;;199        }
;;;200    
;;;201        /* Set the automatic wake-up mode */
;;;202        if (CAN_InitStruct->CAN_AWUM == ENABLE)
000068  7a0c              LDRB     r4,[r1,#8]
00006a  2c01              CMP      r4,#1
00006c  d104              BNE      |L11.120|
;;;203        {
;;;204          CANx->MCR |= CAN_MCR_AWUM;
00006e  6814              LDR      r4,[r2,#0]
000070  f0440420          ORR      r4,r4,#0x20
000074  6014              STR      r4,[r2,#0]
000076  e003              B        |L11.128|
                  |L11.120|
;;;205        }
;;;206        else
;;;207        {
;;;208          CANx->MCR &= ~(uint32_t)CAN_MCR_AWUM;
000078  6814              LDR      r4,[r2,#0]
00007a  f0240420          BIC      r4,r4,#0x20
00007e  6014              STR      r4,[r2,#0]
                  |L11.128|
;;;209        }
;;;210    
;;;211        /* Set the no automatic retransmission */
;;;212        if (CAN_InitStruct->CAN_NART == ENABLE)
000080  7a4c              LDRB     r4,[r1,#9]
000082  2c01              CMP      r4,#1
000084  d104              BNE      |L11.144|
;;;213        {
;;;214          CANx->MCR |= CAN_MCR_NART;
000086  6814              LDR      r4,[r2,#0]
000088  f0440410          ORR      r4,r4,#0x10
00008c  6014              STR      r4,[r2,#0]
00008e  e003              B        |L11.152|
                  |L11.144|
;;;215        }
;;;216        else
;;;217        {
;;;218          CANx->MCR &= ~(uint32_t)CAN_MCR_NART;
000090  6814              LDR      r4,[r2,#0]
000092  f0240410          BIC      r4,r4,#0x10
000096  6014              STR      r4,[r2,#0]
                  |L11.152|
;;;219        }
;;;220    
;;;221        /* Set the receive FIFO locked mode */
;;;222        if (CAN_InitStruct->CAN_RFLM == ENABLE)
000098  7a8c              LDRB     r4,[r1,#0xa]
00009a  2c01              CMP      r4,#1
00009c  d104              BNE      |L11.168|
;;;223        {
;;;224          CANx->MCR |= CAN_MCR_RFLM;
00009e  6814              LDR      r4,[r2,#0]
0000a0  f0440408          ORR      r4,r4,#8
0000a4  6014              STR      r4,[r2,#0]
0000a6  e003              B        |L11.176|
                  |L11.168|
;;;225        }
;;;226        else
;;;227        {
;;;228          CANx->MCR &= ~(uint32_t)CAN_MCR_RFLM;
0000a8  6814              LDR      r4,[r2,#0]
0000aa  f0240408          BIC      r4,r4,#8
0000ae  6014              STR      r4,[r2,#0]
                  |L11.176|
;;;229        }
;;;230    
;;;231        /* Set the transmit FIFO priority */
;;;232        if (CAN_InitStruct->CAN_TXFP == ENABLE)
0000b0  7acc              LDRB     r4,[r1,#0xb]
0000b2  2c01              CMP      r4,#1
0000b4  d104              BNE      |L11.192|
;;;233        {
;;;234          CANx->MCR |= CAN_MCR_TXFP;
0000b6  6814              LDR      r4,[r2,#0]
0000b8  f0440404          ORR      r4,r4,#4
0000bc  6014              STR      r4,[r2,#0]
0000be  e003              B        |L11.200|
                  |L11.192|
;;;235        }
;;;236        else
;;;237        {
;;;238          CANx->MCR &= ~(uint32_t)CAN_MCR_TXFP;
0000c0  6814              LDR      r4,[r2,#0]
0000c2  f0240404          BIC      r4,r4,#4
0000c6  6014              STR      r4,[r2,#0]
                  |L11.200|
;;;239        }
;;;240    
;;;241        /* Set the bit timing register */
;;;242        CANx->BTR = (uint32_t)((uint32_t)CAN_InitStruct->CAN_Mode << 30) | ((uint32_t)CAN_InitStruct->CAN_SJW << 24) |
0000c8  788c              LDRB     r4,[r1,#2]
0000ca  07a4              LSLS     r4,r4,#30
0000cc  78cd              LDRB     r5,[r1,#3]
0000ce  ea446405          ORR      r4,r4,r5,LSL #24
0000d2  790d              LDRB     r5,[r1,#4]
0000d4  ea444405          ORR      r4,r4,r5,LSL #16
0000d8  794d              LDRB     r5,[r1,#5]
0000da  ea445405          ORR      r4,r4,r5,LSL #20
0000de  880d              LDRH     r5,[r1,#0]
0000e0  1e6d              SUBS     r5,r5,#1
0000e2  432c              ORRS     r4,r4,r5
0000e4  61d4              STR      r4,[r2,#0x1c]
;;;243                   ((uint32_t)CAN_InitStruct->CAN_BS1 << 16) | ((uint32_t)CAN_InitStruct->CAN_BS2 << 20) |
;;;244                   ((uint32_t)CAN_InitStruct->CAN_Prescaler - 1);
;;;245    
;;;246        /* Request leave initialisation */
;;;247        CANx->MCR &= ~(uint32_t)CAN_MCR_INRQ;
0000e6  6814              LDR      r4,[r2,#0]
0000e8  f0240401          BIC      r4,r4,#1
0000ec  6014              STR      r4,[r2,#0]
;;;248    
;;;249       /* Wait the acknowledge */
;;;250       wait_ack = 0x00;
0000ee  2300              MOVS     r3,#0
;;;251    
;;;252       while (((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
0000f0  e000              B        |L11.244|
                  |L11.242|
;;;253       {
;;;254         wait_ack++;
0000f2  1c5b              ADDS     r3,r3,#1
                  |L11.244|
0000f4  6854              LDR      r4,[r2,#4]            ;252
0000f6  f0040401          AND      r4,r4,#1              ;252
0000fa  b11c              CBZ      r4,|L11.260|
0000fc  f64f74ff          MOV      r4,#0xffff            ;252
000100  42a3              CMP      r3,r4                 ;252
000102  d1f6              BNE      |L11.242|
                  |L11.260|
;;;255       }
;;;256    
;;;257        /* ...and check acknowledged */
;;;258        if ((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK)
000104  6854              LDR      r4,[r2,#4]
000106  f0040401          AND      r4,r4,#1
00010a  b10c              CBZ      r4,|L11.272|
;;;259        {
;;;260          InitStatus = CANINITFAILED;
00010c  2000              MOVS     r0,#0
00010e  e000              B        |L11.274|
                  |L11.272|
;;;261        }
;;;262        else
;;;263        {
;;;264          InitStatus = CANINITOK ;
000110  2001              MOVS     r0,#1
                  |L11.274|
;;;265        }
;;;266      }
;;;267    
;;;268      /* At this step, return the status of initialization */
;;;269      return InitStatus;
;;;270    }
000112  bd30              POP      {r4,r5,pc}
;;;271    
                          ENDP


                          AREA ||i.CAN_MessagePending||, CODE, READONLY, ALIGN=1

                  CAN_MessagePending PROC
;;;632      */
;;;633    uint8_t CAN_MessagePending(CAN_TypeDef* CANx, uint8_t FIFONumber)
000000  4602              MOV      r2,r0
;;;634    {
;;;635      uint8_t message_pending=0;
000002  2000              MOVS     r0,#0
;;;636      /* Check the parameters */
;;;637      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;638      assert_param(IS_CAN_FIFO(FIFONumber));
;;;639      if (FIFONumber == CAN_FIFO0)
000004  b919              CBNZ     r1,|L12.14|
;;;640      {
;;;641        message_pending = (uint8_t)(CANx->RF0R&(uint32_t)0x03);
000006  68d3              LDR      r3,[r2,#0xc]
000008  f0030003          AND      r0,r3,#3
00000c  e006              B        |L12.28|
                  |L12.14|
;;;642      }
;;;643      else if (FIFONumber == CAN_FIFO1)
00000e  2901              CMP      r1,#1
000010  d103              BNE      |L12.26|
;;;644      {
;;;645        message_pending = (uint8_t)(CANx->RF1R&(uint32_t)0x03);
000012  6913              LDR      r3,[r2,#0x10]
000014  f0030003          AND      r0,r3,#3
000018  e000              B        |L12.28|
                  |L12.26|
;;;646      }
;;;647      else
;;;648      {
;;;649        message_pending = 0;
00001a  2000              MOVS     r0,#0
                  |L12.28|
;;;650      }
;;;651      return message_pending;
;;;652    }
00001c  4770              BX       lr
;;;653    
                          ENDP


                          AREA ||i.CAN_Receive||, CODE, READONLY, ALIGN=1

                  CAN_Receive PROC
;;;661      */
;;;662    void CAN_Receive(CAN_TypeDef* CANx, uint8_t FIFONumber, CanRxMsg* RxMessage)
000000  b530              PUSH     {r4,r5,lr}
;;;663    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
000006  4613              MOV      r3,r2
;;;664      /* Check the parameters */
;;;665      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;666      assert_param(IS_CAN_FIFO(FIFONumber));
;;;667      /* Get the Id */
;;;668      RxMessage->IDE = (uint8_t)0x04 & CANx->sFIFOMailBox[FIFONumber].RIR;
000008  f50570d8          ADD      r0,r5,#0x1b0
00000c  eb001004          ADD      r0,r0,r4,LSL #4
000010  6800              LDR      r0,[r0,#0]
000012  f0000004          AND      r0,r0,#4
000016  7218              STRB     r0,[r3,#8]
;;;669      if (RxMessage->IDE == CAN_ID_STD)
000018  7a18              LDRB     r0,[r3,#8]
00001a  b950              CBNZ     r0,|L13.50|
;;;670      {
;;;671        RxMessage->StdId = (uint32_t)0x000007FF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 21);
00001c  f50570d8          ADD      r0,r5,#0x1b0
000020  eb001004          ADD      r0,r0,r4,LSL #4
000024  6800              LDR      r0,[r0,#0]
000026  f24071ff          MOV      r1,#0x7ff
00002a  ea015050          AND      r0,r1,r0,LSR #21
00002e  6018              STR      r0,[r3,#0]
000030  e009              B        |L13.70|
                  |L13.50|
;;;672      }
;;;673      else
;;;674      {
;;;675        RxMessage->ExtId = (uint32_t)0x1FFFFFFF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 3);
000032  f50570d8          ADD      r0,r5,#0x1b0
000036  eb001004          ADD      r0,r0,r4,LSL #4
00003a  6800              LDR      r0,[r0,#0]
00003c  f06f4160          MVN      r1,#0xe0000000
000040  ea0100d0          AND      r0,r1,r0,LSR #3
000044  6058              STR      r0,[r3,#4]
                  |L13.70|
;;;676      }
;;;677      
;;;678      RxMessage->RTR = (uint8_t)0x02 & CANx->sFIFOMailBox[FIFONumber].RIR;
000046  f50570d8          ADD      r0,r5,#0x1b0
00004a  eb001004          ADD      r0,r0,r4,LSL #4
00004e  6800              LDR      r0,[r0,#0]
000050  f0000002          AND      r0,r0,#2
000054  7258              STRB     r0,[r3,#9]
;;;679      /* Get the DLC */
;;;680      RxMessage->DLC = (uint8_t)0x0F & CANx->sFIFOMailBox[FIFONumber].RDTR;
000056  f50570d8          ADD      r0,r5,#0x1b0
00005a  eb001004          ADD      r0,r0,r4,LSL #4
00005e  6840              LDR      r0,[r0,#4]
000060  f000000f          AND      r0,r0,#0xf
000064  7298              STRB     r0,[r3,#0xa]
;;;681      /* Get the FMI */
;;;682      RxMessage->FMI = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDTR >> 8);
000066  f50570d8          ADD      r0,r5,#0x1b0
00006a  eb001004          ADD      r0,r0,r4,LSL #4
00006e  6840              LDR      r0,[r0,#4]
000070  0a00              LSRS     r0,r0,#8
000072  74d8              STRB     r0,[r3,#0x13]
;;;683      /* Get the data field */
;;;684      RxMessage->Data[0] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDLR;
000074  f50570d8          ADD      r0,r5,#0x1b0
000078  eb001004          ADD      r0,r0,r4,LSL #4
00007c  6880              LDR      r0,[r0,#8]
00007e  72d8              STRB     r0,[r3,#0xb]
;;;685      RxMessage->Data[1] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 8);
000080  f50570d8          ADD      r0,r5,#0x1b0
000084  eb001004          ADD      r0,r0,r4,LSL #4
000088  6880              LDR      r0,[r0,#8]
00008a  0a01              LSRS     r1,r0,#8
00008c  7319              STRB     r1,[r3,#0xc]
;;;686      RxMessage->Data[2] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 16);
00008e  f50570d8          ADD      r0,r5,#0x1b0
000092  eb001004          ADD      r0,r0,r4,LSL #4
000096  6880              LDR      r0,[r0,#8]
000098  0c01              LSRS     r1,r0,#16
00009a  7359              STRB     r1,[r3,#0xd]
;;;687      RxMessage->Data[3] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 24);
00009c  f50570d8          ADD      r0,r5,#0x1b0
0000a0  eb001004          ADD      r0,r0,r4,LSL #4
0000a4  6880              LDR      r0,[r0,#8]
0000a6  0e00              LSRS     r0,r0,#24
0000a8  7398              STRB     r0,[r3,#0xe]
;;;688      RxMessage->Data[4] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDHR;
0000aa  f50570d8          ADD      r0,r5,#0x1b0
0000ae  eb001004          ADD      r0,r0,r4,LSL #4
0000b2  68c0              LDR      r0,[r0,#0xc]
0000b4  73d8              STRB     r0,[r3,#0xf]
;;;689      RxMessage->Data[5] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 8);
0000b6  f50570d8          ADD      r0,r5,#0x1b0
0000ba  eb001004          ADD      r0,r0,r4,LSL #4
0000be  68c0              LDR      r0,[r0,#0xc]
0000c0  0a01              LSRS     r1,r0,#8
0000c2  7419              STRB     r1,[r3,#0x10]
;;;690      RxMessage->Data[6] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 16);
0000c4  f50570d8          ADD      r0,r5,#0x1b0
0000c8  eb001004          ADD      r0,r0,r4,LSL #4
0000cc  68c0              LDR      r0,[r0,#0xc]
0000ce  0c01              LSRS     r1,r0,#16
0000d0  7459              STRB     r1,[r3,#0x11]
;;;691      RxMessage->Data[7] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 24);
0000d2  f50570d8          ADD      r0,r5,#0x1b0
0000d6  eb001004          ADD      r0,r0,r4,LSL #4
0000da  68c0              LDR      r0,[r0,#0xc]
0000dc  0e00              LSRS     r0,r0,#24
0000de  7498              STRB     r0,[r3,#0x12]
;;;692      /* Release the FIFO */
;;;693      CAN_FIFORelease(CANx, FIFONumber);
0000e0  4621              MOV      r1,r4
0000e2  4628              MOV      r0,r5
0000e4  f7fffffe          BL       CAN_FIFORelease
;;;694    }
0000e8  bd30              POP      {r4,r5,pc}
;;;695    
                          ENDP


                          AREA ||i.CAN_SlaveStartBank||, CODE, READONLY, ALIGN=2

                  CAN_SlaveStartBank PROC
;;;403      */
;;;404    void CAN_SlaveStartBank(uint8_t CAN_BankNumber) 
000000  490b              LDR      r1,|L14.48|
;;;405    {
;;;406      /* Check the parameters */
;;;407      assert_param(IS_CAN_BANKNUMBER(CAN_BankNumber));
;;;408      /* enter Initialisation mode for the filter */
;;;409      CAN1->FMR |= FMR_FINIT;
000002  6809              LDR      r1,[r1,#0]
000004  f0410101          ORR      r1,r1,#1
000008  4a09              LDR      r2,|L14.48|
00000a  6011              STR      r1,[r2,#0]
;;;410      /* Select the start slave bank */
;;;411      CAN1->FMR &= (uint32_t)0xFFFFC0F1 ;
00000c  4611              MOV      r1,r2
00000e  6809              LDR      r1,[r1,#0]
000010  f643720e          MOV      r2,#0x3f0e
000014  4391              BICS     r1,r1,r2
000016  4a06              LDR      r2,|L14.48|
000018  6011              STR      r1,[r2,#0]
;;;412      CAN1->FMR |= (uint32_t)(CAN_BankNumber)<<8;
00001a  4611              MOV      r1,r2
00001c  6809              LDR      r1,[r1,#0]
00001e  ea412100          ORR      r1,r1,r0,LSL #8
000022  6011              STR      r1,[r2,#0]
;;;413      /* Leave Initialisation mode for the filter */
;;;414      CAN1->FMR &= ~FMR_FINIT;
000024  4611              MOV      r1,r2
000026  6809              LDR      r1,[r1,#0]
000028  f0210101          BIC      r1,r1,#1
00002c  6011              STR      r1,[r2,#0]
;;;415    }
00002e  4770              BX       lr
;;;416    
                          ENDP

                  |L14.48|
                          DCD      0x40006600

                          AREA ||i.CAN_Sleep||, CODE, READONLY, ALIGN=1

                  CAN_Sleep PROC
;;;725      */
;;;726    uint8_t CAN_Sleep(CAN_TypeDef* CANx)
000000  4601              MOV      r1,r0
;;;727    {
;;;728      uint8_t sleepstatus = CANSLEEPFAILED;
000002  2000              MOVS     r0,#0
;;;729      
;;;730      /* Check the parameters */
;;;731      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;732        
;;;733      /* Request Sleep mode */
;;;734       CANx->MCR = (((CANx->MCR) & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
000004  680a              LDR      r2,[r1,#0]
000006  f0220201          BIC      r2,r2,#1
00000a  f0420202          ORR      r2,r2,#2
00000e  600a              STR      r2,[r1,#0]
;;;735       
;;;736      /* Sleep mode status */
;;;737      if ((CANx->MSR & (CAN_MSR_SLAK|CAN_MSR_INAK)) == CAN_MSR_SLAK)
000010  684a              LDR      r2,[r1,#4]
000012  f0020203          AND      r2,r2,#3
000016  2a02              CMP      r2,#2
000018  d100              BNE      |L15.28|
;;;738      {
;;;739        /* Sleep mode not entered */
;;;740        sleepstatus =  CANSLEEPOK;
00001a  2001              MOVS     r0,#1
                  |L15.28|
;;;741      }
;;;742      /* At this step, sleep mode status */
;;;743       return (uint8_t)sleepstatus;
;;;744    }
00001c  4770              BX       lr
;;;745    
                          ENDP


                          AREA ||i.CAN_StructInit||, CODE, READONLY, ALIGN=1

                  CAN_StructInit PROC
;;;370      */
;;;371    void CAN_StructInit(CAN_InitTypeDef* CAN_InitStruct)
000000  2100              MOVS     r1,#0
;;;372    {
;;;373      /* Reset CAN init structure parameters values */
;;;374      /* Initialize the time triggered communication mode */
;;;375      CAN_InitStruct->CAN_TTCM = DISABLE;
000002  7181              STRB     r1,[r0,#6]
;;;376      /* Initialize the automatic bus-off management */
;;;377      CAN_InitStruct->CAN_ABOM = DISABLE;
000004  71c1              STRB     r1,[r0,#7]
;;;378      /* Initialize the automatic wake-up mode */
;;;379      CAN_InitStruct->CAN_AWUM = DISABLE;
000006  7201              STRB     r1,[r0,#8]
;;;380      /* Initialize the no automatic retransmission */
;;;381      CAN_InitStruct->CAN_NART = DISABLE;
000008  7241              STRB     r1,[r0,#9]
;;;382      /* Initialize the receive FIFO locked mode */
;;;383      CAN_InitStruct->CAN_RFLM = DISABLE;
00000a  7281              STRB     r1,[r0,#0xa]
;;;384      /* Initialize the transmit FIFO priority */
;;;385      CAN_InitStruct->CAN_TXFP = DISABLE;
00000c  72c1              STRB     r1,[r0,#0xb]
;;;386      /* Initialize the CAN_Mode member */
;;;387      CAN_InitStruct->CAN_Mode = CAN_Mode_Normal;
00000e  7081              STRB     r1,[r0,#2]
;;;388      /* Initialize the CAN_SJW member */
;;;389      CAN_InitStruct->CAN_SJW = CAN_SJW_1tq;
000010  70c1              STRB     r1,[r0,#3]
;;;390      /* Initialize the CAN_BS1 member */
;;;391      CAN_InitStruct->CAN_BS1 = CAN_BS1_4tq;
000012  2103              MOVS     r1,#3
000014  7101              STRB     r1,[r0,#4]
;;;392      /* Initialize the CAN_BS2 member */
;;;393      CAN_InitStruct->CAN_BS2 = CAN_BS2_3tq;
000016  2102              MOVS     r1,#2
000018  7141              STRB     r1,[r0,#5]
;;;394      /* Initialize the CAN_Prescaler member */
;;;395      CAN_InitStruct->CAN_Prescaler = 1;
00001a  2101              MOVS     r1,#1
00001c  8001              STRH     r1,[r0,#0]
;;;396    }
00001e  4770              BX       lr
;;;397    
                          ENDP


                          AREA ||i.CAN_Transmit||, CODE, READONLY, ALIGN=1

                  CAN_Transmit PROC
;;;465      */
;;;466    uint8_t CAN_Transmit(CAN_TypeDef* CANx, CanTxMsg* TxMessage)
000000  b510              PUSH     {r4,lr}
;;;467    {
000002  4602              MOV      r2,r0
;;;468      uint8_t transmit_mailbox = 0;
000004  2000              MOVS     r0,#0
;;;469      /* Check the parameters */
;;;470      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;471      assert_param(IS_CAN_IDTYPE(TxMessage->IDE));
;;;472      assert_param(IS_CAN_RTR(TxMessage->RTR));
;;;473      assert_param(IS_CAN_DLC(TxMessage->DLC));
;;;474    
;;;475      /* Select one empty transmit mailbox */
;;;476      if ((CANx->TSR&CAN_TSR_TME0) == CAN_TSR_TME0)
000006  6893              LDR      r3,[r2,#8]
000008  f0036380          AND      r3,r3,#0x4000000
00000c  f1b36f80          CMP      r3,#0x4000000
000010  d100              BNE      |L17.20|
;;;477      {
;;;478        transmit_mailbox = 0;
000012  e010              B        |L17.54|
                  |L17.20|
;;;479      }
;;;480      else if ((CANx->TSR&CAN_TSR_TME1) == CAN_TSR_TME1)
000014  6893              LDR      r3,[r2,#8]
000016  f0036300          AND      r3,r3,#0x8000000
00001a  f1b36f00          CMP      r3,#0x8000000
00001e  d101              BNE      |L17.36|
;;;481      {
;;;482        transmit_mailbox = 1;
000020  2001              MOVS     r0,#1
000022  e008              B        |L17.54|
                  |L17.36|
;;;483      }
;;;484      else if ((CANx->TSR&CAN_TSR_TME2) == CAN_TSR_TME2)
000024  6893              LDR      r3,[r2,#8]
000026  f0035380          AND      r3,r3,#0x10000000
00002a  f1b35f80          CMP      r3,#0x10000000
00002e  d101              BNE      |L17.52|
;;;485      {
;;;486        transmit_mailbox = 2;
000030  2002              MOVS     r0,#2
000032  e000              B        |L17.54|
                  |L17.52|
;;;487      }
;;;488      else
;;;489      {
;;;490        transmit_mailbox = CAN_NO_MB;
000034  2004              MOVS     r0,#4
                  |L17.54|
;;;491      }
;;;492    
;;;493      if (transmit_mailbox != CAN_NO_MB)
000036  2804              CMP      r0,#4
000038  d074              BEQ      |L17.292|
;;;494      {
;;;495        /* Set up the Id */
;;;496        CANx->sTxMailBox[transmit_mailbox].TIR &= TMIDxR_TXRQ;
00003a  f50273c0          ADD      r3,r2,#0x180
00003e  eb031300          ADD      r3,r3,r0,LSL #4
000042  681b              LDR      r3,[r3,#0]
000044  f0030401          AND      r4,r3,#1
000048  f50273c0          ADD      r3,r2,#0x180
00004c  eb031300          ADD      r3,r3,r0,LSL #4
000050  601c              STR      r4,[r3,#0]
;;;497        if (TxMessage->IDE == CAN_ID_STD)
000052  7a0b              LDRB     r3,[r1,#8]
000054  b97b              CBNZ     r3,|L17.118|
;;;498        {
;;;499          assert_param(IS_CAN_STDID(TxMessage->StdId));  
;;;500          CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->StdId << 21) | TxMessage->RTR);
000056  7a4b              LDRB     r3,[r1,#9]
000058  880c              LDRH     r4,[r1,#0]
00005a  ea435344          ORR      r3,r3,r4,LSL #21
00005e  f50274c0          ADD      r4,r2,#0x180
000062  eb041400          ADD      r4,r4,r0,LSL #4
000066  6824              LDR      r4,[r4,#0]
000068  4323              ORRS     r3,r3,r4
00006a  f50274c0          ADD      r4,r2,#0x180
00006e  eb041400          ADD      r4,r4,r0,LSL #4
000072  6023              STR      r3,[r4,#0]
000074  e010              B        |L17.152|
                  |L17.118|
;;;501        }
;;;502        else
;;;503        {
;;;504          assert_param(IS_CAN_EXTID(TxMessage->ExtId));
;;;505          CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->ExtId<<3) | TxMessage->IDE | 
000076  7a0b              LDRB     r3,[r1,#8]
000078  684c              LDR      r4,[r1,#4]
00007a  ea4303c4          ORR      r3,r3,r4,LSL #3
00007e  7a4c              LDRB     r4,[r1,#9]
000080  4323              ORRS     r3,r3,r4
000082  f50274c0          ADD      r4,r2,#0x180
000086  eb041400          ADD      r4,r4,r0,LSL #4
00008a  6824              LDR      r4,[r4,#0]
00008c  4323              ORRS     r3,r3,r4
00008e  f50274c0          ADD      r4,r2,#0x180
000092  eb041400          ADD      r4,r4,r0,LSL #4
000096  6023              STR      r3,[r4,#0]
                  |L17.152|
;;;506                                                   TxMessage->RTR);
;;;507        }
;;;508        
;;;509    
;;;510        /* Set up the DLC */
;;;511        TxMessage->DLC &= (uint8_t)0x0000000F;
000098  7a8b              LDRB     r3,[r1,#0xa]
00009a  f003030f          AND      r3,r3,#0xf
00009e  728b              STRB     r3,[r1,#0xa]
;;;512        CANx->sTxMailBox[transmit_mailbox].TDTR &= (uint32_t)0xFFFFFFF0;
0000a0  f50273c0          ADD      r3,r2,#0x180
0000a4  eb031300          ADD      r3,r3,r0,LSL #4
0000a8  685b              LDR      r3,[r3,#4]
0000aa  f023040f          BIC      r4,r3,#0xf
0000ae  f50273c0          ADD      r3,r2,#0x180
0000b2  eb031300          ADD      r3,r3,r0,LSL #4
0000b6  605c              STR      r4,[r3,#4]
;;;513        CANx->sTxMailBox[transmit_mailbox].TDTR |= TxMessage->DLC;
0000b8  f50273c0          ADD      r3,r2,#0x180
0000bc  eb031300          ADD      r3,r3,r0,LSL #4
0000c0  685b              LDR      r3,[r3,#4]
0000c2  7a8c              LDRB     r4,[r1,#0xa]
0000c4  4323              ORRS     r3,r3,r4
0000c6  f50274c0          ADD      r4,r2,#0x180
0000ca  eb041400          ADD      r4,r4,r0,LSL #4
0000ce  6063              STR      r3,[r4,#4]
;;;514    
;;;515        /* Set up the data field */
;;;516        CANx->sTxMailBox[transmit_mailbox].TDLR = (((uint32_t)TxMessage->Data[3] << 24) | 
0000d0  7b8b              LDRB     r3,[r1,#0xe]
0000d2  061c              LSLS     r4,r3,#24
0000d4  7b4b              LDRB     r3,[r1,#0xd]
0000d6  ea444403          ORR      r4,r4,r3,LSL #16
0000da  7b0b              LDRB     r3,[r1,#0xc]
0000dc  ea442303          ORR      r3,r4,r3,LSL #8
0000e0  7acc              LDRB     r4,[r1,#0xb]
0000e2  4323              ORRS     r3,r3,r4
0000e4  f50274c0          ADD      r4,r2,#0x180
0000e8  eb041400          ADD      r4,r4,r0,LSL #4
0000ec  60a3              STR      r3,[r4,#8]
;;;517                                                 ((uint32_t)TxMessage->Data[2] << 16) |
;;;518                                                 ((uint32_t)TxMessage->Data[1] << 8) | 
;;;519                                                 ((uint32_t)TxMessage->Data[0]));
;;;520        CANx->sTxMailBox[transmit_mailbox].TDHR = (((uint32_t)TxMessage->Data[7] << 24) | 
0000ee  7c8b              LDRB     r3,[r1,#0x12]
0000f0  061c              LSLS     r4,r3,#24
0000f2  7c4b              LDRB     r3,[r1,#0x11]
0000f4  ea444403          ORR      r4,r4,r3,LSL #16
0000f8  7c0b              LDRB     r3,[r1,#0x10]
0000fa  ea442303          ORR      r3,r4,r3,LSL #8
0000fe  7bcc              LDRB     r4,[r1,#0xf]
000100  4323              ORRS     r3,r3,r4
000102  f50274c0          ADD      r4,r2,#0x180
000106  eb041400          ADD      r4,r4,r0,LSL #4
00010a  60e3              STR      r3,[r4,#0xc]
;;;521                                                 ((uint32_t)TxMessage->Data[6] << 16) |
;;;522                                                 ((uint32_t)TxMessage->Data[5] << 8) |
;;;523                                                 ((uint32_t)TxMessage->Data[4]));
;;;524        /* Request transmission */
;;;525        CANx->sTxMailBox[transmit_mailbox].TIR |= TMIDxR_TXRQ;
00010c  f50273c0          ADD      r3,r2,#0x180
000110  eb031300          ADD      r3,r3,r0,LSL #4
000114  681b              LDR      r3,[r3,#0]
000116  f0430401          ORR      r4,r3,#1
00011a  f50273c0          ADD      r3,r2,#0x180
00011e  eb031300          ADD      r3,r3,r0,LSL #4
000122  601c              STR      r4,[r3,#0]
                  |L17.292|
;;;526      }
;;;527      return transmit_mailbox;
;;;528    }
000124  bd10              POP      {r4,pc}
;;;529    
                          ENDP


                          AREA ||i.CAN_TransmitStatus||, CODE, READONLY, ALIGN=1

                  CAN_TransmitStatus PROC
;;;535      */
;;;536    uint8_t CAN_TransmitStatus(CAN_TypeDef* CANx, uint8_t TransmitMailbox)
000000  4602              MOV      r2,r0
;;;537    {
;;;538      /* RQCP, TXOK and TME bits */
;;;539      uint8_t state = 0;
000002  2000              MOVS     r0,#0
;;;540      /* Check the parameters */
;;;541      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;542      assert_param(IS_CAN_TRANSMITMAILBOX(TransmitMailbox));
;;;543      switch (TransmitMailbox)
000004  b121              CBZ      r1,|L18.16|
000006  2901              CMP      r1,#1
000008  d010              BEQ      |L18.44|
00000a  2902              CMP      r1,#2
00000c  d12c              BNE      |L18.104|
00000e  e01c              B        |L18.74|
                  |L18.16|
;;;544      {
;;;545        case (0): state |= (uint8_t)((CANx->TSR & CAN_TSR_RQCP0) << 2);
000010  6893              LDR      r3,[r2,#8]
000012  f0030301          AND      r3,r3,#1
000016  ea400083          ORR      r0,r0,r3,LSL #2
;;;546          state |= (uint8_t)((CANx->TSR & CAN_TSR_TXOK0) >> 0);
00001a  6893              LDR      r3,[r2,#8]
00001c  f0030302          AND      r3,r3,#2
000020  4318              ORRS     r0,r0,r3
;;;547          state |= (uint8_t)((CANx->TSR & CAN_TSR_TME0) >> 26);
000022  6893              LDR      r3,[r2,#8]
000024  f3c36380          UBFX     r3,r3,#26,#1
000028  4318              ORRS     r0,r0,r3
;;;548          break;
00002a  e01f              B        |L18.108|
                  |L18.44|
;;;549        case (1): state |= (uint8_t)((CANx->TSR & CAN_TSR_RQCP1) >> 6);
00002c  6893              LDR      r3,[r2,#8]
00002e  f4037380          AND      r3,r3,#0x100
000032  ea401093          ORR      r0,r0,r3,LSR #6
;;;550          state |= (uint8_t)((CANx->TSR & CAN_TSR_TXOK1) >> 8);
000036  6893              LDR      r3,[r2,#8]
000038  f4037300          AND      r3,r3,#0x200
00003c  ea402013          ORR      r0,r0,r3,LSR #8
;;;551          state |= (uint8_t)((CANx->TSR & CAN_TSR_TME1) >> 27);
000040  6893              LDR      r3,[r2,#8]
000042  f3c363c0          UBFX     r3,r3,#27,#1
000046  4318              ORRS     r0,r0,r3
;;;552          break;
000048  e010              B        |L18.108|
                  |L18.74|
;;;553        case (2): state |= (uint8_t)((CANx->TSR & CAN_TSR_RQCP2) >> 14);
00004a  6893              LDR      r3,[r2,#8]
00004c  f4033380          AND      r3,r3,#0x10000
000050  ea403093          ORR      r0,r0,r3,LSR #14
;;;554          state |= (uint8_t)((CANx->TSR & CAN_TSR_TXOK2) >> 16);
000054  6893              LDR      r3,[r2,#8]
000056  f4033300          AND      r3,r3,#0x20000
00005a  ea404013          ORR      r0,r0,r3,LSR #16
;;;555          state |= (uint8_t)((CANx->TSR & CAN_TSR_TME2) >> 28);
00005e  6893              LDR      r3,[r2,#8]
000060  f3c37300          UBFX     r3,r3,#28,#1
000064  4318              ORRS     r0,r0,r3
;;;556          break;
000066  e001              B        |L18.108|
                  |L18.104|
;;;557        default:
;;;558          state = CANTXFAILED;
000068  2000              MOVS     r0,#0
;;;559          break;
00006a  bf00              NOP      
                  |L18.108|
00006c  bf00              NOP                            ;548
;;;560      }
;;;561      switch (state)
00006e  b120              CBZ      r0,|L18.122|
000070  2805              CMP      r0,#5
000072  d004              BEQ      |L18.126|
000074  2807              CMP      r0,#7
000076  d106              BNE      |L18.134|
000078  e003              B        |L18.130|
                  |L18.122|
;;;562      {
;;;563          /* transmit pending  */
;;;564        case (0x0): state = CANTXPENDING;
00007a  2002              MOVS     r0,#2
;;;565          break;
00007c  e005              B        |L18.138|
                  |L18.126|
;;;566          /* transmit failed  */
;;;567        case (0x5): state = CANTXFAILED;
00007e  2000              MOVS     r0,#0
;;;568          break;
000080  e003              B        |L18.138|
                  |L18.130|
;;;569          /* transmit succedeed  */
;;;570        case (0x7): state = CANTXOK;
000082  2001              MOVS     r0,#1
;;;571          break;
000084  e001              B        |L18.138|
                  |L18.134|
;;;572        default:
;;;573          state = CANTXFAILED;
000086  2000              MOVS     r0,#0
;;;574          break;
000088  bf00              NOP      
                  |L18.138|
00008a  bf00              NOP                            ;565
;;;575      }
;;;576      return state;
;;;577    }
00008c  4770              BX       lr
;;;578    
                          ENDP


                          AREA ||i.CAN_WakeUp||, CODE, READONLY, ALIGN=1

                  CAN_WakeUp PROC
;;;750      */
;;;751    uint8_t CAN_WakeUp(CAN_TypeDef* CANx)
000000  4601              MOV      r1,r0
;;;752    {
;;;753      uint32_t wait_slak = SLAK_TIMEOUT;
000002  f64f72ff          MOV      r2,#0xffff
;;;754      uint8_t wakeupstatus = CANWAKEUPFAILED;
000006  2000              MOVS     r0,#0
;;;755      
;;;756      /* Check the parameters */
;;;757      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;758        
;;;759      /* Wake up request */
;;;760      CANx->MCR &= ~(uint32_t)CAN_MCR_SLEEP;
000008  680b              LDR      r3,[r1,#0]
00000a  f0230302          BIC      r3,r3,#2
00000e  600b              STR      r3,[r1,#0]
;;;761        
;;;762      /* Sleep mode status */
;;;763      while(((CANx->MSR & CAN_MSR_SLAK) == CAN_MSR_SLAK)&&(wait_slak!=0x00))
000010  e000              B        |L19.20|
                  |L19.18|
;;;764      {
;;;765       wait_slak--;
000012  1e52              SUBS     r2,r2,#1
                  |L19.20|
000014  684b              LDR      r3,[r1,#4]            ;763
000016  f0030302          AND      r3,r3,#2              ;763
00001a  2b02              CMP      r3,#2                 ;763
00001c  d101              BNE      |L19.34|
00001e  2a00              CMP      r2,#0                 ;763
000020  d1f7              BNE      |L19.18|
                  |L19.34|
;;;766      }
;;;767      if((CANx->MSR & CAN_MSR_SLAK) != CAN_MSR_SLAK)
000022  684b              LDR      r3,[r1,#4]
000024  f0030302          AND      r3,r3,#2
000028  2b02              CMP      r3,#2
00002a  d000              BEQ      |L19.46|
;;;768      {
;;;769       /* Sleep mode exited */
;;;770        wakeupstatus = CANWAKEUPOK;
00002c  2001              MOVS     r0,#1
                  |L19.46|
;;;771      }
;;;772      /* At this step, sleep mode status */
;;;773      return (uint8_t)wakeupstatus;
;;;774    }
00002e  4770              BX       lr
;;;775    
                          ENDP


                          AREA ||i.CheckITStatus||, CODE, READONLY, ALIGN=1

                  CheckITStatus PROC
;;;1136     */
;;;1137   static ITStatus CheckITStatus(uint32_t CAN_Reg, uint32_t It_Bit)
000000  4602              MOV      r2,r0
;;;1138   {
;;;1139     ITStatus pendingbitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1140     
;;;1141     if ((CAN_Reg & It_Bit) != (uint32_t)RESET)
000004  ea020301          AND      r3,r2,r1
000008  b10b              CBZ      r3,|L20.14|
;;;1142     {
;;;1143       /* CAN_IT is set */
;;;1144       pendingbitstatus = SET;
00000a  2001              MOVS     r0,#1
00000c  e000              B        |L20.16|
                  |L20.14|
;;;1145     }
;;;1146     else
;;;1147     {
;;;1148       /* CAN_IT is reset */
;;;1149       pendingbitstatus = RESET;
00000e  2000              MOVS     r0,#0
                  |L20.16|
;;;1150     }
;;;1151     return pendingbitstatus;
;;;1152   }
000010  4770              BX       lr
;;;1153   
                          ENDP

