; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\m26_striped.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\m26_striped.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\startup\arm -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\Libraries\STM32F10x_StdPeriph_Driver\src -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\USER -I..\MDK-ARM -IC:\Users\Administrator\Desktop\stm32-uart-chenlong\stm32-uart-chenlong\MDK-ARM\RTE -I"D:\Program Files\keil5\ARM\PACK\ARM\CMSIS\4.2.0\CMSIS\Include" -I"D:\Program Files\keil5\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0" -D__MICROLIB -D__UVISION_VERSION=514 -D_RTE_ -DSTM32F10X_MD --omf_browse=.\obj\m26_striped.crf ..\USER\M26_striped.c]
                          THUMB

                          AREA ||i.M26_GPIO_Enable||, CODE, READONLY, ALIGN=2

                  M26_GPIO_Enable PROC
;;;36      */
;;;37     void M26_GPIO_Enable(void)
000000  b508              PUSH     {r3,lr}
;;;38     {
;;;39         GPIO_InitTypeDef GPIO_InitStructure;
;;;40     
;;;41         RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB,ENABLE);
000002  2101              MOVS     r1,#1
000004  200c              MOVS     r0,#0xc
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;42     
;;;43         /* 主MCU的TX  gprs的rx */
;;;44         GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_2;
00000a  2004              MOVS     r0,#4
00000c  f8ad0000          STRH     r0,[sp,#0]
;;;45         GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF_PP;
000010  2018              MOVS     r0,#0x18
000012  f88d0003          STRB     r0,[sp,#3]
;;;46         GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000016  2003              MOVS     r0,#3
000018  f88d0002          STRB     r0,[sp,#2]
;;;47         GPIO_Init(GPIOA,&GPIO_InitStructure);
00001c  4669              MOV      r1,sp
00001e  4816              LDR      r0,|L1.120|
000020  f7fffffe          BL       GPIO_Init
;;;48     
;;;49         /* 主MCU的RX  gprs的Tx */
;;;50         GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_3;
000024  2008              MOVS     r0,#8
000026  f8ad0000          STRH     r0,[sp,#0]
;;;51         GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IN_FLOATING;	
00002a  2004              MOVS     r0,#4
00002c  f88d0003          STRB     r0,[sp,#3]
;;;52         GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;  	
000030  2003              MOVS     r0,#3
000032  f88d0002          STRB     r0,[sp,#2]
;;;53         GPIO_Init(GPIOA,&GPIO_InitStructure);  
000036  4669              MOV      r1,sp
000038  480f              LDR      r0,|L1.120|
00003a  f7fffffe          BL       GPIO_Init
;;;54     
;;;55         /* GSM_STUTAS */
;;;56         GPIO_InitStructure.GPIO_Pin   = GSM_STUTAS;
00003e  f44f7080          MOV      r0,#0x100
000042  f8ad0000          STRH     r0,[sp,#0]
;;;57         /* 上拉输ru */
;;;58         GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IPU;
000046  2048              MOVS     r0,#0x48
000048  f88d0003          STRB     r0,[sp,#3]
;;;59         GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00004c  2003              MOVS     r0,#3
00004e  f88d0002          STRB     r0,[sp,#2]
;;;60         GPIO_Init(GPIOB, &GPIO_InitStructure);
000052  4669              MOV      r1,sp
000054  4809              LDR      r0,|L1.124|
000056  f7fffffe          BL       GPIO_Init
;;;61     
;;;62         GPIO_InitStructure.GPIO_Pin = GSM_PWRKEY;// GSM_PWRKEY  
00005a  f44f7000          MOV      r0,#0x200
00005e  f8ad0000          STRH     r0,[sp,#0]
;;;63         GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
000062  2010              MOVS     r0,#0x10
000064  f88d0003          STRB     r0,[sp,#3]
;;;64         GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000068  2003              MOVS     r0,#3
00006a  f88d0002          STRB     r0,[sp,#2]
;;;65         GPIO_Init(GPIOB, &GPIO_InitStructure); 
00006e  4669              MOV      r1,sp
000070  4802              LDR      r0,|L1.124|
000072  f7fffffe          BL       GPIO_Init
;;;66     
;;;67      /*    GPIO_InitStructure.GPIO_Pin = GSM_PWR;
;;;68         GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;69         GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
;;;70         GPIO_Init(GPIOA, &GPIO_InitStructure);	 */
;;;71     
;;;72     }
000076  bd08              POP      {r3,pc}
;;;73     
                          ENDP

                  |L1.120|
                          DCD      0x40010800
                  |L1.124|
                          DCD      0x40010c00

                          AREA ||i.M26_Init||, CODE, READONLY, ALIGN=2

                  M26_Init PROC
;;;225     */
;;;226    int M26_Init(void)
000000  b570              PUSH     {r4-r6,lr}
;;;227    {
;;;228        uint32_t retry   = 0; // M26 开机重试次数
000002  2400              MOVS     r4,#0
;;;229        uint32_t timeout = 0; // 等待关机的时间计数，单位 100 ms
000004  2600              MOVS     r6,#0
;;;230        int init_cmpl    = 0; // 初始化完成
000006  2500              MOVS     r5,#0
;;;231    
;;;232        M26_GPIO_Enable();
000008  f7fffffe          BL       M26_GPIO_Enable
;;;233        M26_UART_Cfg();
00000c  f7fffffe          BL       M26_UART_Cfg
;;;234        NVIC_UART2_M26_Configuration();
000010  f7fffffe          BL       NVIC_UART2_M26_Configuration
;;;235    
;;;236        //dbg_printf("[M26] start up\r\n");
;;;237    		
;;;238    
;;;239        do
000014  bf00              NOP      
                  |L2.22|
;;;240        {
;;;241            retry++;
000016  1c64              ADDS     r4,r4,#1
;;;242            /* 当前 M26 已经关机，执行开机流程 */
;;;243            if(GPIO_ReadInputDataBit(GPIOB, GSM_STUTAS)==0)//关机状态
000018  f44f7180          MOV      r1,#0x100
00001c  4811              LDR      r0,|L2.100|
00001e  f7fffffe          BL       GPIO_ReadInputDataBit
000022  b9a0              CBNZ     r0,|L2.78|
;;;244            {
;;;245                /* 拉高 300ms */
;;;246                GPIO_ResetBits(GPIOB, GSM_PWRKEY);
000024  f44f7100          MOV      r1,#0x200
000028  480e              LDR      r0,|L2.100|
00002a  f7fffffe          BL       GPIO_ResetBits
;;;247                delay_ms(300);
00002e  f44f7096          MOV      r0,#0x12c
000032  f7fffffe          BL       delay_ms
;;;248    						
;;;249                /* 拉低 5s，M26 在开机后4-5s才能响应 AT。直到正常响应 AT 指令，再拉高 */
;;;250                GPIO_SetBits(GPIOB, GSM_PWRKEY);
000036  f44f7100          MOV      r1,#0x200
00003a  480a              LDR      r0,|L2.100|
00003c  f7fffffe          BL       GPIO_SetBits
;;;251                delay_ms(5000);
000040  f2413088          MOV      r0,#0x1388
000044  f7fffffe          BL       delay_ms
;;;252    						
;;;253                // TODO 发送 AT 自适应
;;;254                M26_SendStr("ATI\r\n");
000048  a007              ADR      r0,|L2.104|
00004a  f7fffffe          BL       M26_SendStr
                  |L2.78|
;;;255                //dbg_printf("\n");
;;;256            }
;;;257        } while((init_cmpl == 0) && retry < 3); // AT 自适应不成功
00004e  b90d              CBNZ     r5,|L2.84|
000050  2c03              CMP      r4,#3
000052  d3e0              BCC      |L2.22|
                  |L2.84|
;;;258    
;;;259        /* 拉高 */
;;;260        GPIO_ResetBits(GPIOB, GSM_PWRKEY);
000054  f44f7100          MOV      r1,#0x200
000058  4802              LDR      r0,|L2.100|
00005a  f7fffffe          BL       GPIO_ResetBits
;;;261    
;;;262        return init_cmpl;
00005e  4628              MOV      r0,r5
;;;263    }
000060  bd70              POP      {r4-r6,pc}
                          ENDP

000062  0000              DCW      0x0000
                  |L2.100|
                          DCD      0x40010c00
                  |L2.104|
000068  4154490d          DCB      "ATI\r\n",0
00006c  0a00    
00006e  00                DCB      0
00006f  00                DCB      0

                          AREA ||i.M26_SendByte||, CODE, READONLY, ALIGN=2

                  M26_SendByte PROC
;;;202     */
;;;203    uint8_t M26_SendByte(uint16_t Data)
000000  b570              PUSH     {r4-r6,lr}
;;;204    {
000002  4604              MOV      r4,r0
;;;205        uint32_t retry=0;
000004  2500              MOVS     r5,#0
;;;206        USART_SendData(USART2, Data);                            
000006  4621              MOV      r1,r4
000008  4808              LDR      r0,|L3.44|
00000a  f7fffffe          BL       USART_SendData
;;;207        while(USART_GetFlagStatus(USART2, USART_FLAG_TC) == RESET)
00000e  e005              B        |L3.28|
                  |L3.16|
;;;208        {
;;;209            retry++;
000010  1c6d              ADDS     r5,r5,#1
;;;210            if(retry>2000)
000012  f5b56ffa          CMP      r5,#0x7d0
000016  d901              BLS      |L3.28|
;;;211            {
;;;212                return 1;  
000018  2001              MOVS     r0,#1
                  |L3.26|
;;;213            }            
;;;214        }
;;;215        return 0;
;;;216    }
00001a  bd70              POP      {r4-r6,pc}
                  |L3.28|
00001c  2140              MOVS     r1,#0x40              ;207
00001e  4803              LDR      r0,|L3.44|
000020  f7fffffe          BL       USART_GetFlagStatus
000024  2800              CMP      r0,#0                 ;207
000026  d0f3              BEQ      |L3.16|
000028  2000              MOVS     r0,#0                 ;215
00002a  e7f6              B        |L3.26|
;;;217    
                          ENDP

                  |L3.44|
                          DCD      0x40004400

                          AREA ||i.M26_SendStr||, CODE, READONLY, ALIGN=2

                  M26_SendStr PROC
;;;175     */
;;;176    void M26_SendStr(const char * str)
000000  b570              PUSH     {r4-r6,lr}
;;;177    {
000002  4604              MOV      r4,r0
;;;178        uint32_t retry=0;	  
000004  2500              MOVS     r5,#0
;;;179        while(*str)  
000006  e012              B        |L4.46|
                  |L4.8|
;;;180        {   
;;;181            retry=0;        
000008  2500              MOVS     r5,#0
;;;182            USART_SendData(USART2, *str);  		
00000a  7821              LDRB     r1,[r4,#0]
00000c  480a              LDR      r0,|L4.56|
00000e  f7fffffe          BL       USART_SendData
;;;183    	    str++;
000012  1c64              ADDS     r4,r4,#1
;;;184            while(USART_GetFlagStatus(USART2, USART_FLAG_TC) == RESET)
000014  e004              B        |L4.32|
                  |L4.22|
;;;185            {
;;;186                retry++;
000016  1c6d              ADDS     r5,r5,#1
;;;187                if(retry>2000)
000018  f5b56ffa          CMP      r5,#0x7d0
00001c  d900              BLS      |L4.32|
;;;188                {
;;;189                    break;   
00001e  e005              B        |L4.44|
                  |L4.32|
000020  2140              MOVS     r1,#0x40              ;184
000022  4805              LDR      r0,|L4.56|
000024  f7fffffe          BL       USART_GetFlagStatus
000028  2800              CMP      r0,#0                 ;184
00002a  d0f4              BEQ      |L4.22|
                  |L4.44|
00002c  bf00              NOP      
                  |L4.46|
00002e  7820              LDRB     r0,[r4,#0]            ;179
000030  2800              CMP      r0,#0                 ;179
000032  d1e9              BNE      |L4.8|
;;;190                }                
;;;191            }            
;;;192        }
;;;193    }
000034  bd70              POP      {r4-r6,pc}
;;;194    
                          ENDP

000036  0000              DCW      0x0000
                  |L4.56|
                          DCD      0x40004400

                          AREA ||i.M26_UART_Cfg||, CODE, READONLY, ALIGN=2

                  M26_UART_Cfg PROC
;;;115     */
;;;116    void M26_UART_Cfg(void)
000000  b51f              PUSH     {r0-r4,lr}
;;;117    {
;;;118        uint32_t retry=0;
000002  2400              MOVS     r4,#0
;;;119        USART_InitTypeDef USART_InitStructure;
;;;120    
;;;121        RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);
000004  2101              MOVS     r1,#1
000006  4608              MOV      r0,r1
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;122    
;;;123       	// GPIO_PinRemapConfig(GPIO_Remap_USART2, ENABLE);
;;;124        RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2,ENABLE);
00000c  2101              MOVS     r1,#1
00000e  0448              LSLS     r0,r1,#17
000010  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;125    
;;;126        USART_InitStructure.USART_BaudRate              = 9600;
000014  f44f5016          MOV      r0,#0x2580
000018  9000              STR      r0,[sp,#0]
;;;127        USART_InitStructure.USART_WordLength            = USART_WordLength_8b;
00001a  2000              MOVS     r0,#0
00001c  f8ad0004          STRH     r0,[sp,#4]
;;;128        USART_InitStructure.USART_StopBits              = USART_StopBits_1;
000020  f8ad0006          STRH     r0,[sp,#6]
;;;129        USART_InitStructure.USART_Parity                = USART_Parity_No;
000024  f8ad0008          STRH     r0,[sp,#8]
;;;130        USART_InitStructure.USART_HardwareFlowControl   = USART_HardwareFlowControl_None;
000028  f8ad000c          STRH     r0,[sp,#0xc]
;;;131        USART_InitStructure.USART_Mode                  = USART_Mode_Rx | USART_Mode_Tx;
00002c  200c              MOVS     r0,#0xc
00002e  f8ad000a          STRH     r0,[sp,#0xa]
;;;132    
;;;133        USART_Init(USART2,&USART_InitStructure);
000032  4669              MOV      r1,sp
000034  480d              LDR      r0,|L5.108|
000036  f7fffffe          BL       USART_Init
;;;134        USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);
00003a  2201              MOVS     r2,#1
00003c  f2405125          MOV      r1,#0x525
000040  480a              LDR      r0,|L5.108|
000042  f7fffffe          BL       USART_ITConfig
;;;135    
;;;136        /* 默认为接收模式 */
;;;137        USART_Cmd(USART2,ENABLE);
000046  2101              MOVS     r1,#1
000048  4808              LDR      r0,|L5.108|
00004a  f7fffffe          BL       USART_Cmd
;;;138    
;;;139        while(USART_GetFlagStatus(USART2, USART_FLAG_TXE) == RESET)
00004e  e004              B        |L5.90|
                  |L5.80|
;;;140        {
;;;141            retry++;
000050  1c64              ADDS     r4,r4,#1
;;;142            if(retry>2000)
000052  f5b46ffa          CMP      r4,#0x7d0
000056  d900              BLS      |L5.90|
;;;143            {
;;;144                break;
000058  e005              B        |L5.102|
                  |L5.90|
00005a  2180              MOVS     r1,#0x80              ;139
00005c  4803              LDR      r0,|L5.108|
00005e  f7fffffe          BL       USART_GetFlagStatus
000062  2800              CMP      r0,#0                 ;139
000064  d0f4              BEQ      |L5.80|
                  |L5.102|
000066  bf00              NOP      
;;;145            }
;;;146        }        
;;;147    }
000068  bd1f              POP      {r0-r4,pc}
;;;148    
                          ENDP

00006a  0000              DCW      0x0000
                  |L5.108|
                          DCD      0x40004400

                          AREA ||i.NVIC_UART2_M26_Configuration||, CODE, READONLY, ALIGN=1

                  NVIC_UART2_M26_Configuration PROC
;;;156     */
;;;157    void NVIC_UART2_M26_Configuration(void) 
000000  b508              PUSH     {r3,lr}
;;;158    { 
;;;159        NVIC_InitTypeDef NVIC_InitStructure;
;;;160        /* NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);  */
;;;161        NVIC_InitStructure.NVIC_IRQChannel                      = USART2_IRQn;
000002  2026              MOVS     r0,#0x26
000004  f88d0000          STRB     r0,[sp,#0]
;;;162        NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority    = 0; 
000008  2000              MOVS     r0,#0
00000a  f88d0001          STRB     r0,[sp,#1]
;;;163        NVIC_InitStructure.NVIC_IRQChannelSubPriority           = 1; 
00000e  2001              MOVS     r0,#1
000010  f88d0002          STRB     r0,[sp,#2]
;;;164        NVIC_InitStructure.NVIC_IRQChannelCmd                   = ENABLE; 
000014  f88d0003          STRB     r0,[sp,#3]
;;;165        NVIC_Init(&NVIC_InitStructure); 
000018  4668              MOV      r0,sp
00001a  f7fffffe          BL       NVIC_Init
;;;166    }
00001e  bd08              POP      {r3,pc}
;;;167    
                          ENDP

