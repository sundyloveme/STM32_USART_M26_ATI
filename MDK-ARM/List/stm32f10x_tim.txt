; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\stm32f10x_tim.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\stm32f10x_tim.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\startup\arm -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\Libraries\STM32F10x_StdPeriph_Driver\src -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\USER -I..\MDK-ARM -IC:\Users\Administrator\Desktop\stm32-uart-chenlong\stm32-uart-chenlong\MDK-ARM\RTE -I"D:\Program Files\keil5\ARM\PACK\ARM\CMSIS\4.2.0\CMSIS\Include" -I"D:\Program Files\keil5\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0" -D__MICROLIB -D__UVISION_VERSION=514 -D_RTE_ -DSTM32F10X_MD --omf_browse=.\obj\stm32f10x_tim.crf ..\Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_tim.c]
                          THUMB

                          AREA ||i.TI1_Config||, CODE, READONLY, ALIGN=2

                  TI1_Config PROC
;;;2698     */
;;;2699   static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
000000  b5f0              PUSH     {r4-r7,lr}
;;;2700                          uint16_t TIM_ICFilter)
;;;2701   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
;;;2702     uint16_t tmpccmr1 = 0, tmpccer = 0;
000006  2200              MOVS     r2,#0
000008  2100              MOVS     r1,#0
;;;2703     /* Disable the Channel 1: Reset the CC1E Bit */
;;;2704     TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC1E);
00000a  8c06              LDRH     r6,[r0,#0x20]
00000c  f64f77fe          MOV      r7,#0xfffe
000010  403e              ANDS     r6,r6,r7
000012  8406              STRH     r6,[r0,#0x20]
;;;2705     tmpccmr1 = TIMx->CCMR1;
000014  8b02              LDRH     r2,[r0,#0x18]
;;;2706     tmpccer = TIMx->CCER;
000016  8c01              LDRH     r1,[r0,#0x20]
;;;2707     /* Select the Input and set the filter */
;;;2708     tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC1F)));
000018  f64f760c          MOV      r6,#0xff0c
00001c  4032              ANDS     r2,r2,r6
;;;2709     tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
00001e  1c7e              ADDS     r6,r7,#1
000020  ea061603          AND      r6,r6,r3,LSL #4
000024  432e              ORRS     r6,r6,r5
000026  4332              ORRS     r2,r2,r6
;;;2710     
;;;2711     if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) ||
000028  4e10              LDR      r6,|L1.108|
00002a  42b0              CMP      r0,r6
00002c  d00e              BEQ      |L1.76|
00002e  4e10              LDR      r6,|L1.112|
000030  42b0              CMP      r0,r6
000032  d00b              BEQ      |L1.76|
000034  f1b04f80          CMP      r0,#0x40000000
000038  d008              BEQ      |L1.76|
00003a  4e0e              LDR      r6,|L1.116|
00003c  42b0              CMP      r0,r6
00003e  d005              BEQ      |L1.76|
;;;2712        (TIMx == TIM4) ||(TIMx == TIM5))
000040  4e0d              LDR      r6,|L1.120|
000042  42b0              CMP      r0,r6
000044  d002              BEQ      |L1.76|
000046  4e0d              LDR      r6,|L1.124|
000048  42b0              CMP      r0,r6
00004a  d106              BNE      |L1.90|
                  |L1.76|
;;;2713     {
;;;2714       /* Select the Polarity and set the CC1E Bit */
;;;2715       tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC1P));
00004c  f64f76fd          MOV      r6,#0xfffd
000050  4031              ANDS     r1,r1,r6
;;;2716       tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
000052  f0440601          ORR      r6,r4,#1
000056  4331              ORRS     r1,r1,r6
000058  e005              B        |L1.102|
                  |L1.90|
;;;2717     }
;;;2718     else
;;;2719     {
;;;2720       /* Select the Polarity and set the CC1E Bit */
;;;2721       tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC1P | TIM_CCER_CC1NP));
00005a  f64f76f5          MOV      r6,#0xfff5
00005e  4031              ANDS     r1,r1,r6
;;;2722       tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
000060  f0440601          ORR      r6,r4,#1
000064  4331              ORRS     r1,r1,r6
                  |L1.102|
;;;2723     }
;;;2724   
;;;2725     /* Write to TIMx CCMR1 and CCER registers */
;;;2726     TIMx->CCMR1 = tmpccmr1;
000066  8302              STRH     r2,[r0,#0x18]
;;;2727     TIMx->CCER = tmpccer;
000068  8401              STRH     r1,[r0,#0x20]
;;;2728   }
00006a  bdf0              POP      {r4-r7,pc}
;;;2729   
                          ENDP

                  |L1.108|
                          DCD      0x40012c00
                  |L1.112|
                          DCD      0x40013400
                  |L1.116|
                          DCD      0x40000400
                  |L1.120|
                          DCD      0x40000800
                  |L1.124|
                          DCD      0x40000c00

                          AREA ||i.TI2_Config||, CODE, READONLY, ALIGN=2

                  TI2_Config PROC
;;;2745     */
;;;2746   static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
000000  b5f0              PUSH     {r4-r7,lr}
;;;2747                          uint16_t TIM_ICFilter)
;;;2748   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
;;;2749     uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
000006  2200              MOVS     r2,#0
000008  2100              MOVS     r1,#0
00000a  2600              MOVS     r6,#0
;;;2750     /* Disable the Channel 2: Reset the CC2E Bit */
;;;2751     TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC2E);
00000c  8c07              LDRH     r7,[r0,#0x20]
00000e  f64f7cef          MOV      r12,#0xffef
000012  ea07070c          AND      r7,r7,r12
000016  8407              STRH     r7,[r0,#0x20]
;;;2752     tmpccmr1 = TIMx->CCMR1;
000018  8b02              LDRH     r2,[r0,#0x18]
;;;2753     tmpccer = TIMx->CCER;
00001a  8c01              LDRH     r1,[r0,#0x20]
;;;2754     tmp = (uint16_t)(TIM_ICPolarity << 4);
00001c  f64f77ff          MOV      r7,#0xffff
000020  ea071604          AND      r6,r7,r4,LSL #4
;;;2755     /* Select the Input and set the filter */
;;;2756     tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC2S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC2F)));
000024  f64047ff          MOV      r7,#0xcff
000028  403a              ANDS     r2,r2,r7
;;;2757     tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
00002a  f64f77ff          MOV      r7,#0xffff
00002e  ea073703          AND      r7,r7,r3,LSL #12
000032  433a              ORRS     r2,r2,r7
;;;2758     tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8);
000034  f64f77ff          MOV      r7,#0xffff
000038  ea072705          AND      r7,r7,r5,LSL #8
00003c  433a              ORRS     r2,r2,r7
;;;2759     
;;;2760     if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) ||
00003e  4f11              LDR      r7,|L2.132|
000040  42b8              CMP      r0,r7
000042  d00e              BEQ      |L2.98|
000044  4f10              LDR      r7,|L2.136|
000046  42b8              CMP      r0,r7
000048  d00b              BEQ      |L2.98|
00004a  f1b04f80          CMP      r0,#0x40000000
00004e  d008              BEQ      |L2.98|
000050  4f0e              LDR      r7,|L2.140|
000052  42b8              CMP      r0,r7
000054  d005              BEQ      |L2.98|
;;;2761        (TIMx == TIM4) ||(TIMx == TIM5))
000056  4f0e              LDR      r7,|L2.144|
000058  42b8              CMP      r0,r7
00005a  d002              BEQ      |L2.98|
00005c  4f0d              LDR      r7,|L2.148|
00005e  42b8              CMP      r0,r7
000060  d106              BNE      |L2.112|
                  |L2.98|
;;;2762     {
;;;2763       /* Select the Polarity and set the CC2E Bit */
;;;2764       tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC2P));
000062  f64f77df          MOV      r7,#0xffdf
000066  4039              ANDS     r1,r1,r7
;;;2765       tmpccer |=  (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);
000068  f0460710          ORR      r7,r6,#0x10
00006c  4339              ORRS     r1,r1,r7
00006e  e005              B        |L2.124|
                  |L2.112|
;;;2766     }
;;;2767     else
;;;2768     {
;;;2769       /* Select the Polarity and set the CC2E Bit */
;;;2770       tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC2P | TIM_CCER_CC2NP));
000070  f64f775f          MOV      r7,#0xff5f
000074  4039              ANDS     r1,r1,r7
;;;2771       tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC2E);
000076  f0440710          ORR      r7,r4,#0x10
00007a  4339              ORRS     r1,r1,r7
                  |L2.124|
;;;2772     }
;;;2773     
;;;2774     /* Write to TIMx CCMR1 and CCER registers */
;;;2775     TIMx->CCMR1 = tmpccmr1 ;
00007c  8302              STRH     r2,[r0,#0x18]
;;;2776     TIMx->CCER = tmpccer;
00007e  8401              STRH     r1,[r0,#0x20]
;;;2777   }
000080  bdf0              POP      {r4-r7,pc}
;;;2778   
                          ENDP

000082  0000              DCW      0x0000
                  |L2.132|
                          DCD      0x40012c00
                  |L2.136|
                          DCD      0x40013400
                  |L2.140|
                          DCD      0x40000400
                  |L2.144|
                          DCD      0x40000800
                  |L2.148|
                          DCD      0x40000c00

                          AREA ||i.TI3_Config||, CODE, READONLY, ALIGN=2

                  TI3_Config PROC
;;;2794     */
;;;2795   static void TI3_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
000000  b5f0              PUSH     {r4-r7,lr}
;;;2796                          uint16_t TIM_ICFilter)
;;;2797   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
;;;2798     uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
000006  2200              MOVS     r2,#0
000008  2100              MOVS     r1,#0
00000a  2600              MOVS     r6,#0
;;;2799     /* Disable the Channel 3: Reset the CC3E Bit */
;;;2800     TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC3E);
00000c  8c07              LDRH     r7,[r0,#0x20]
00000e  f64f6cff          MOV      r12,#0xfeff
000012  ea07070c          AND      r7,r7,r12
000016  8407              STRH     r7,[r0,#0x20]
;;;2801     tmpccmr2 = TIMx->CCMR2;
000018  8b82              LDRH     r2,[r0,#0x1c]
;;;2802     tmpccer = TIMx->CCER;
00001a  8c01              LDRH     r1,[r0,#0x20]
;;;2803     tmp = (uint16_t)(TIM_ICPolarity << 8);
00001c  f64f77ff          MOV      r7,#0xffff
000020  ea072604          AND      r6,r7,r4,LSL #8
;;;2804     /* Select the Input and set the filter */
;;;2805     tmpccmr2 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR2_CC3S)) & ((uint16_t)~((uint16_t)TIM_CCMR2_IC3F)));
000024  f64f770c          MOV      r7,#0xff0c
000028  403a              ANDS     r2,r2,r7
;;;2806     tmpccmr2 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
00002a  f64f77ff          MOV      r7,#0xffff
00002e  ea071703          AND      r7,r7,r3,LSL #4
000032  432f              ORRS     r7,r7,r5
000034  433a              ORRS     r2,r2,r7
;;;2807       
;;;2808     if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) ||
000036  4f11              LDR      r7,|L3.124|
000038  42b8              CMP      r0,r7
00003a  d00e              BEQ      |L3.90|
00003c  4f10              LDR      r7,|L3.128|
00003e  42b8              CMP      r0,r7
000040  d00b              BEQ      |L3.90|
000042  f1b04f80          CMP      r0,#0x40000000
000046  d008              BEQ      |L3.90|
000048  4f0e              LDR      r7,|L3.132|
00004a  42b8              CMP      r0,r7
00004c  d005              BEQ      |L3.90|
;;;2809        (TIMx == TIM4) ||(TIMx == TIM5))
00004e  4f0e              LDR      r7,|L3.136|
000050  42b8              CMP      r0,r7
000052  d002              BEQ      |L3.90|
000054  4f0d              LDR      r7,|L3.140|
000056  42b8              CMP      r0,r7
000058  d106              BNE      |L3.104|
                  |L3.90|
;;;2810     {
;;;2811       /* Select the Polarity and set the CC3E Bit */
;;;2812       tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC3P));
00005a  f64f57ff          MOV      r7,#0xfdff
00005e  4039              ANDS     r1,r1,r7
;;;2813       tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC3E);
000060  f4467780          ORR      r7,r6,#0x100
000064  4339              ORRS     r1,r1,r7
000066  e005              B        |L3.116|
                  |L3.104|
;;;2814     }
;;;2815     else
;;;2816     {
;;;2817       /* Select the Polarity and set the CC3E Bit */
;;;2818       tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC3P | TIM_CCER_CC3NP));
000068  f24f57ff          MOV      r7,#0xf5ff
00006c  4039              ANDS     r1,r1,r7
;;;2819       tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC3E);
00006e  f4447780          ORR      r7,r4,#0x100
000072  4339              ORRS     r1,r1,r7
                  |L3.116|
;;;2820     }
;;;2821     
;;;2822     /* Write to TIMx CCMR2 and CCER registers */
;;;2823     TIMx->CCMR2 = tmpccmr2;
000074  8382              STRH     r2,[r0,#0x1c]
;;;2824     TIMx->CCER = tmpccer;
000076  8401              STRH     r1,[r0,#0x20]
;;;2825   }
000078  bdf0              POP      {r4-r7,pc}
;;;2826   
                          ENDP

00007a  0000              DCW      0x0000
                  |L3.124|
                          DCD      0x40012c00
                  |L3.128|
                          DCD      0x40013400
                  |L3.132|
                          DCD      0x40000400
                  |L3.136|
                          DCD      0x40000800
                  |L3.140|
                          DCD      0x40000c00

                          AREA ||i.TI4_Config||, CODE, READONLY, ALIGN=2

                  TI4_Config PROC
;;;2842     */
;;;2843   static void TI4_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
000000  b5f0              PUSH     {r4-r7,lr}
;;;2844                          uint16_t TIM_ICFilter)
;;;2845   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
;;;2846     uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
000006  2200              MOVS     r2,#0
000008  2100              MOVS     r1,#0
00000a  2600              MOVS     r6,#0
;;;2847   
;;;2848      /* Disable the Channel 4: Reset the CC4E Bit */
;;;2849     TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC4E);
00000c  8c07              LDRH     r7,[r0,#0x20]
00000e  f64e7cff          MOV      r12,#0xefff
000012  ea07070c          AND      r7,r7,r12
000016  8407              STRH     r7,[r0,#0x20]
;;;2850     tmpccmr2 = TIMx->CCMR2;
000018  8b82              LDRH     r2,[r0,#0x1c]
;;;2851     tmpccer = TIMx->CCER;
00001a  8c01              LDRH     r1,[r0,#0x20]
;;;2852     tmp = (uint16_t)(TIM_ICPolarity << 12);
00001c  f64f77ff          MOV      r7,#0xffff
000020  ea073604          AND      r6,r7,r4,LSL #12
;;;2853     /* Select the Input and set the filter */
;;;2854     tmpccmr2 &= (uint16_t)((uint16_t)(~(uint16_t)TIM_CCMR2_CC4S) & ((uint16_t)~((uint16_t)TIM_CCMR2_IC4F)));
000024  f64047ff          MOV      r7,#0xcff
000028  403a              ANDS     r2,r2,r7
;;;2855     tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
00002a  f64f77ff          MOV      r7,#0xffff
00002e  ea072705          AND      r7,r7,r5,LSL #8
000032  433a              ORRS     r2,r2,r7
;;;2856     tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);
000034  f64f77ff          MOV      r7,#0xffff
000038  ea073703          AND      r7,r7,r3,LSL #12
00003c  433a              ORRS     r2,r2,r7
;;;2857     
;;;2858     if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) ||
00003e  4f11              LDR      r7,|L4.132|
000040  42b8              CMP      r0,r7
000042  d00e              BEQ      |L4.98|
000044  4f10              LDR      r7,|L4.136|
000046  42b8              CMP      r0,r7
000048  d00b              BEQ      |L4.98|
00004a  f1b04f80          CMP      r0,#0x40000000
00004e  d008              BEQ      |L4.98|
000050  4f0e              LDR      r7,|L4.140|
000052  42b8              CMP      r0,r7
000054  d005              BEQ      |L4.98|
;;;2859        (TIMx == TIM4) ||(TIMx == TIM5))
000056  4f0e              LDR      r7,|L4.144|
000058  42b8              CMP      r0,r7
00005a  d002              BEQ      |L4.98|
00005c  4f0d              LDR      r7,|L4.148|
00005e  42b8              CMP      r0,r7
000060  d106              BNE      |L4.112|
                  |L4.98|
;;;2860     {
;;;2861       /* Select the Polarity and set the CC4E Bit */
;;;2862       tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC4P));
000062  f64d77ff          MOV      r7,#0xdfff
000066  4039              ANDS     r1,r1,r7
;;;2863       tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC4E);
000068  f4465780          ORR      r7,r6,#0x1000
00006c  4339              ORRS     r1,r1,r7
00006e  e005              B        |L4.124|
                  |L4.112|
;;;2864     }
;;;2865     else
;;;2866     {
;;;2867       /* Select the Polarity and set the CC4E Bit */
;;;2868       tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC3P | TIM_CCER_CC4NP));
000070  f64757ff          MOV      r7,#0x7dff
000074  4039              ANDS     r1,r1,r7
;;;2869       tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC4E);
000076  f4445780          ORR      r7,r4,#0x1000
00007a  4339              ORRS     r1,r1,r7
                  |L4.124|
;;;2870     }
;;;2871     /* Write to TIMx CCMR2 and CCER registers */
;;;2872     TIMx->CCMR2 = tmpccmr2;
00007c  8382              STRH     r2,[r0,#0x1c]
;;;2873     TIMx->CCER = tmpccer;
00007e  8401              STRH     r1,[r0,#0x20]
;;;2874   }
000080  bdf0              POP      {r4-r7,pc}
;;;2875   
                          ENDP

000082  0000              DCW      0x0000
                  |L4.132|
                          DCD      0x40012c00
                  |L4.136|
                          DCD      0x40013400
                  |L4.140|
                          DCD      0x40000400
                  |L4.144|
                          DCD      0x40000800
                  |L4.148|
                          DCD      0x40000c00

                          AREA ||i.TIM_ARRPreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_ARRPreloadConfig PROC
;;;1406     */
;;;1407   void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L5.12|
;;;1408   {
;;;1409     /* Check the parameters */
;;;1410     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;1411     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1412     if (NewState != DISABLE)
;;;1413     {
;;;1414       /* Set the ARR Preload Bit */
;;;1415       TIMx->CR1 |= TIM_CR1_ARPE;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420280          ORR      r2,r2,#0x80
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L5.22|
                  |L5.12|
;;;1416     }
;;;1417     else
;;;1418     {
;;;1419       /* Reset the ARR Preload Bit */
;;;1420       TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_ARPE);
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64f737f          MOV      r3,#0xff7f
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L5.22|
;;;1421     }
;;;1422   }
000016  4770              BX       lr
;;;1423   
                          ENDP


                          AREA ||i.TIM_BDTRConfig||, CODE, READONLY, ALIGN=1

                  TIM_BDTRConfig PROC
;;;709      */
;;;710    void TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct)
000000  880a              LDRH     r2,[r1,#0]
;;;711    {
;;;712      /* Check the parameters */
;;;713      assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;714      assert_param(IS_TIM_OSSR_STATE(TIM_BDTRInitStruct->TIM_OSSRState));
;;;715      assert_param(IS_TIM_OSSI_STATE(TIM_BDTRInitStruct->TIM_OSSIState));
;;;716      assert_param(IS_TIM_LOCK_LEVEL(TIM_BDTRInitStruct->TIM_LOCKLevel));
;;;717      assert_param(IS_TIM_BREAK_STATE(TIM_BDTRInitStruct->TIM_Break));
;;;718      assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
;;;719      assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));
;;;720      /* Set the Lock level, the Break enable Bit and the Ploarity, the OSSR State,
;;;721         the OSSI State, the dead time value and the Automatic Output Enable Bit */
;;;722      TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
000002  884b              LDRH     r3,[r1,#2]
000004  431a              ORRS     r2,r2,r3
000006  888b              LDRH     r3,[r1,#4]
000008  431a              ORRS     r2,r2,r3
00000a  88cb              LDRH     r3,[r1,#6]
00000c  431a              ORRS     r2,r2,r3
00000e  890b              LDRH     r3,[r1,#8]
000010  431a              ORRS     r2,r2,r3
000012  894b              LDRH     r3,[r1,#0xa]
000014  431a              ORRS     r2,r2,r3
000016  898b              LDRH     r3,[r1,#0xc]
000018  431a              ORRS     r2,r2,r3
00001a  f8a02044          STRH     r2,[r0,#0x44]
;;;723                 TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
;;;724                 TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
;;;725                 TIM_BDTRInitStruct->TIM_AutomaticOutput;
;;;726    }
00001e  4770              BX       lr
;;;727    
                          ENDP


                          AREA ||i.TIM_BDTRStructInit||, CODE, READONLY, ALIGN=1

                  TIM_BDTRStructInit PROC
;;;784      */
;;;785    void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)
000000  2100              MOVS     r1,#0
;;;786    {
;;;787      /* Set the default configuration */
;;;788      TIM_BDTRInitStruct->TIM_OSSRState = TIM_OSSRState_Disable;
000002  8001              STRH     r1,[r0,#0]
;;;789      TIM_BDTRInitStruct->TIM_OSSIState = TIM_OSSIState_Disable;
000004  8041              STRH     r1,[r0,#2]
;;;790      TIM_BDTRInitStruct->TIM_LOCKLevel = TIM_LOCKLevel_OFF;
000006  8081              STRH     r1,[r0,#4]
;;;791      TIM_BDTRInitStruct->TIM_DeadTime = 0x00;
000008  80c1              STRH     r1,[r0,#6]
;;;792      TIM_BDTRInitStruct->TIM_Break = TIM_Break_Disable;
00000a  8101              STRH     r1,[r0,#8]
;;;793      TIM_BDTRInitStruct->TIM_BreakPolarity = TIM_BreakPolarity_Low;
00000c  8141              STRH     r1,[r0,#0xa]
;;;794      TIM_BDTRInitStruct->TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
00000e  8181              STRH     r1,[r0,#0xc]
;;;795    }
000010  4770              BX       lr
;;;796    
                          ENDP


                          AREA ||i.TIM_CCPreloadControl||, CODE, READONLY, ALIGN=1

                  TIM_CCPreloadControl PROC
;;;1480     */
;;;1481   void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L8.12|
;;;1482   { 
;;;1483     /* Check the parameters */
;;;1484     assert_param(IS_TIM_LIST5_PERIPH(TIMx));
;;;1485     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1486     if (NewState != DISABLE)
;;;1487     {
;;;1488       /* Set the CCPC Bit */
;;;1489       TIMx->CR2 |= TIM_CR2_CCPC;
000002  8882              LDRH     r2,[r0,#4]
000004  f0420201          ORR      r2,r2,#1
000008  8082              STRH     r2,[r0,#4]
00000a  e004              B        |L8.22|
                  |L8.12|
;;;1490     }
;;;1491     else
;;;1492     {
;;;1493       /* Reset the CCPC Bit */
;;;1494       TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_CCPC);
00000c  8882              LDRH     r2,[r0,#4]
00000e  f64f73fe          MOV      r3,#0xfffe
000012  401a              ANDS     r2,r2,r3
000014  8082              STRH     r2,[r0,#4]
                  |L8.22|
;;;1495     }
;;;1496   }
000016  4770              BX       lr
;;;1497   
                          ENDP


                          AREA ||i.TIM_CCxCmd||, CODE, READONLY, ALIGN=1

                  TIM_CCxCmd PROC
;;;1971     */
;;;1972   void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx)
000000  b530              PUSH     {r4,r5,lr}
;;;1973   {
;;;1974     uint16_t tmp = 0;
000002  2300              MOVS     r3,#0
;;;1975   
;;;1976     /* Check the parameters */
;;;1977     assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;1978     assert_param(IS_TIM_CHANNEL(TIM_Channel));
;;;1979     assert_param(IS_TIM_CCX(TIM_CCx));
;;;1980   
;;;1981     tmp = CCER_CCE_Set << TIM_Channel;
000004  2401              MOVS     r4,#1
000006  408c              LSLS     r4,r4,r1
000008  b2a3              UXTH     r3,r4
;;;1982   
;;;1983     /* Reset the CCxE Bit */
;;;1984     TIMx->CCER &= (uint16_t)~ tmp;
00000a  8c04              LDRH     r4,[r0,#0x20]
00000c  439c              BICS     r4,r4,r3
00000e  8404              STRH     r4,[r0,#0x20]
;;;1985   
;;;1986     /* Set or reset the CCxE Bit */ 
;;;1987     TIMx->CCER |=  (uint16_t)(TIM_CCx << TIM_Channel);
000010  8c04              LDRH     r4,[r0,#0x20]
000012  fa02f501          LSL      r5,r2,r1
000016  b2ad              UXTH     r5,r5
000018  432c              ORRS     r4,r4,r5
00001a  8404              STRH     r4,[r0,#0x20]
;;;1988   }
00001c  bd30              POP      {r4,r5,pc}
;;;1989   
                          ENDP


                          AREA ||i.TIM_CCxNCmd||, CODE, READONLY, ALIGN=1

                  TIM_CCxNCmd PROC
;;;2001     */
;;;2002   void TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN)
000000  b530              PUSH     {r4,r5,lr}
;;;2003   {
;;;2004     uint16_t tmp = 0;
000002  2300              MOVS     r3,#0
;;;2005   
;;;2006     /* Check the parameters */
;;;2007     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2008     assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
;;;2009     assert_param(IS_TIM_CCXN(TIM_CCxN));
;;;2010   
;;;2011     tmp = CCER_CCNE_Set << TIM_Channel;
000004  2404              MOVS     r4,#4
000006  408c              LSLS     r4,r4,r1
000008  b2a3              UXTH     r3,r4
;;;2012   
;;;2013     /* Reset the CCxNE Bit */
;;;2014     TIMx->CCER &= (uint16_t) ~tmp;
00000a  8c04              LDRH     r4,[r0,#0x20]
00000c  439c              BICS     r4,r4,r3
00000e  8404              STRH     r4,[r0,#0x20]
;;;2015   
;;;2016     /* Set or reset the CCxNE Bit */ 
;;;2017     TIMx->CCER |=  (uint16_t)(TIM_CCxN << TIM_Channel);
000010  8c04              LDRH     r4,[r0,#0x20]
000012  fa02f501          LSL      r5,r2,r1
000016  b2ad              UXTH     r5,r5
000018  432c              ORRS     r4,r4,r5
00001a  8404              STRH     r4,[r0,#0x20]
;;;2018   }
00001c  bd30              POP      {r4,r5,pc}
;;;2019   
                          ENDP


                          AREA ||i.TIM_ClearFlag||, CODE, READONLY, ALIGN=1

                  TIM_ClearFlag PROC
;;;2597     */
;;;2598   void TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
000000  43ca              MVNS     r2,r1
;;;2599   {  
;;;2600     /* Check the parameters */
;;;2601     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2602     assert_param(IS_TIM_CLEAR_FLAG(TIM_FLAG));
;;;2603      
;;;2604     /* Clear the flags */
;;;2605     TIMx->SR = (uint16_t)~TIM_FLAG;
000002  8202              STRH     r2,[r0,#0x10]
;;;2606   }
000004  4770              BX       lr
;;;2607   
                          ENDP


                          AREA ||i.TIM_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  TIM_ClearITPendingBit PROC
;;;2673     */
;;;2674   void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT)
000000  43ca              MVNS     r2,r1
;;;2675   {
;;;2676     /* Check the parameters */
;;;2677     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2678     assert_param(IS_TIM_IT(TIM_IT));
;;;2679     /* Clear the IT pending Bit */
;;;2680     TIMx->SR = (uint16_t)~TIM_IT;
000002  8202              STRH     r2,[r0,#0x10]
;;;2681   }
000004  4770              BX       lr
;;;2682   
                          ENDP


                          AREA ||i.TIM_ClearOC1Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC1Ref PROC
;;;1704     */
;;;1705   void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  460a              MOV      r2,r1
;;;1706   {
;;;1707     uint16_t tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1708     /* Check the parameters */
;;;1709     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1710     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1711   
;;;1712     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1713   
;;;1714     /* Reset the OC1CE Bit */
;;;1715     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1CE);
000006  f64f737f          MOV      r3,#0xff7f
00000a  4019              ANDS     r1,r1,r3
;;;1716     /* Enable or Disable the Output Compare Clear Bit */
;;;1717     tmpccmr1 |= TIM_OCClear;
00000c  4311              ORRS     r1,r1,r2
;;;1718     /* Write to TIMx CCMR1 register */
;;;1719     TIMx->CCMR1 = tmpccmr1;
00000e  8301              STRH     r1,[r0,#0x18]
;;;1720   }
000010  4770              BX       lr
;;;1721   
                          ENDP


                          AREA ||i.TIM_ClearOC2Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC2Ref PROC
;;;1730     */
;;;1731   void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  460a              MOV      r2,r1
;;;1732   {
;;;1733     uint16_t tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1734     /* Check the parameters */
;;;1735     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1736     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1737     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1738     /* Reset the OC2CE Bit */
;;;1739     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2CE);
000006  f3c1010e          UBFX     r1,r1,#0,#15
;;;1740     /* Enable or Disable the Output Compare Clear Bit */
;;;1741     tmpccmr1 |= (uint16_t)(TIM_OCClear << 8);
00000a  f64f73ff          MOV      r3,#0xffff
00000e  ea032302          AND      r3,r3,r2,LSL #8
000012  4319              ORRS     r1,r1,r3
;;;1742     /* Write to TIMx CCMR1 register */
;;;1743     TIMx->CCMR1 = tmpccmr1;
000014  8301              STRH     r1,[r0,#0x18]
;;;1744   }
000016  4770              BX       lr
;;;1745   
                          ENDP


                          AREA ||i.TIM_ClearOC3Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC3Ref PROC
;;;1754     */
;;;1755   void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  460a              MOV      r2,r1
;;;1756   {
;;;1757     uint16_t tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1758     /* Check the parameters */
;;;1759     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1760     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1761     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1762     /* Reset the OC3CE Bit */
;;;1763     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3CE);
000006  f64f737f          MOV      r3,#0xff7f
00000a  4019              ANDS     r1,r1,r3
;;;1764     /* Enable or Disable the Output Compare Clear Bit */
;;;1765     tmpccmr2 |= TIM_OCClear;
00000c  4311              ORRS     r1,r1,r2
;;;1766     /* Write to TIMx CCMR2 register */
;;;1767     TIMx->CCMR2 = tmpccmr2;
00000e  8381              STRH     r1,[r0,#0x1c]
;;;1768   }
000010  4770              BX       lr
;;;1769   
                          ENDP


                          AREA ||i.TIM_ClearOC4Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC4Ref PROC
;;;1778     */
;;;1779   void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  460a              MOV      r2,r1
;;;1780   {
;;;1781     uint16_t tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1782     /* Check the parameters */
;;;1783     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1784     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1785     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1786     /* Reset the OC4CE Bit */
;;;1787     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4CE);
000006  f3c1010e          UBFX     r1,r1,#0,#15
;;;1788     /* Enable or Disable the Output Compare Clear Bit */
;;;1789     tmpccmr2 |= (uint16_t)(TIM_OCClear << 8);
00000a  f64f73ff          MOV      r3,#0xffff
00000e  ea032302          AND      r3,r3,r2,LSL #8
000012  4319              ORRS     r1,r1,r3
;;;1790     /* Write to TIMx CCMR2 register */
;;;1791     TIMx->CCMR2 = tmpccmr2;
000014  8381              STRH     r1,[r0,#0x1c]
;;;1792   }
000016  4770              BX       lr
;;;1793   
                          ENDP


                          AREA ||i.TIM_Cmd||, CODE, READONLY, ALIGN=1

                  TIM_Cmd PROC
;;;803      */
;;;804    void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L17.12|
;;;805    {
;;;806      /* Check the parameters */
;;;807      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;808      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;809      
;;;810      if (NewState != DISABLE)
;;;811      {
;;;812        /* Enable the TIM Counter */
;;;813        TIMx->CR1 |= TIM_CR1_CEN;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420201          ORR      r2,r2,#1
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L17.22|
                  |L17.12|
;;;814      }
;;;815      else
;;;816      {
;;;817        /* Disable the TIM Counter */
;;;818        TIMx->CR1 &= (uint16_t)(~((uint16_t)TIM_CR1_CEN));
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64f73fe          MOV      r3,#0xfffe
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L17.22|
;;;819      }
;;;820    }
000016  4770              BX       lr
;;;821    
                          ENDP


                          AREA ||i.TIM_CounterModeConfig||, CODE, READONLY, ALIGN=1

                  TIM_CounterModeConfig PROC
;;;1196     */
;;;1197   void TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode)
000000  460a              MOV      r2,r1
;;;1198   {
;;;1199     uint16_t tmpcr1 = 0;
000002  2100              MOVS     r1,#0
;;;1200     /* Check the parameters */
;;;1201     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1202     assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));
;;;1203     tmpcr1 = TIMx->CR1;
000004  8801              LDRH     r1,[r0,#0]
;;;1204     /* Reset the CMS and DIR Bits */
;;;1205     tmpcr1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));
000006  f64f738f          MOV      r3,#0xff8f
00000a  4019              ANDS     r1,r1,r3
;;;1206     /* Set the Counter Mode */
;;;1207     tmpcr1 |= TIM_CounterMode;
00000c  4311              ORRS     r1,r1,r2
;;;1208     /* Write to TIMx CR1 register */
;;;1209     TIMx->CR1 = tmpcr1;
00000e  8001              STRH     r1,[r0,#0]
;;;1210   }
000010  4770              BX       lr
;;;1211   
                          ENDP


                          AREA ||i.TIM_CtrlPWMOutputs||, CODE, READONLY, ALIGN=1

                  TIM_CtrlPWMOutputs PROC
;;;828      */
;;;829    void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b131              CBZ      r1,|L19.16|
;;;830    {
;;;831      /* Check the parameters */
;;;832      assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;833      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;834      if (NewState != DISABLE)
;;;835      {
;;;836        /* Enable the TIM Main Output */
;;;837        TIMx->BDTR |= TIM_BDTR_MOE;
000002  f8b02044          LDRH     r2,[r0,#0x44]
000006  f4424200          ORR      r2,r2,#0x8000
00000a  f8a02044          STRH     r2,[r0,#0x44]
00000e  e005              B        |L19.28|
                  |L19.16|
;;;838      }
;;;839      else
;;;840      {
;;;841        /* Disable the TIM Main Output */
;;;842        TIMx->BDTR &= (uint16_t)(~((uint16_t)TIM_BDTR_MOE));
000010  f8b02044          LDRH     r2,[r0,#0x44]
000014  f3c2020e          UBFX     r2,r2,#0,#15
000018  f8a02044          STRH     r2,[r0,#0x44]
                  |L19.28|
;;;843      }  
;;;844    }
00001c  4770              BX       lr
;;;845    
                          ENDP


                          AREA ||i.TIM_DMACmd||, CODE, READONLY, ALIGN=1

                  TIM_DMACmd PROC
;;;961      */
;;;962    void TIM_DMACmd(TIM_TypeDef* TIMx, uint16_t TIM_DMASource, FunctionalState NewState)
000000  b11a              CBZ      r2,|L20.10|
;;;963    { 
;;;964      /* Check the parameters */
;;;965      assert_param(IS_TIM_LIST9_PERIPH(TIMx));
;;;966      assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
;;;967      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;968      
;;;969      if (NewState != DISABLE)
;;;970      {
;;;971        /* Enable the DMA sources */
;;;972        TIMx->DIER |= TIM_DMASource; 
000002  8983              LDRH     r3,[r0,#0xc]
000004  430b              ORRS     r3,r3,r1
000006  8183              STRH     r3,[r0,#0xc]
000008  e002              B        |L20.16|
                  |L20.10|
;;;973      }
;;;974      else
;;;975      {
;;;976        /* Disable the DMA sources */
;;;977        TIMx->DIER &= (uint16_t)~TIM_DMASource;
00000a  8983              LDRH     r3,[r0,#0xc]
00000c  438b              BICS     r3,r3,r1
00000e  8183              STRH     r3,[r0,#0xc]
                  |L20.16|
;;;978      }
;;;979    }
000010  4770              BX       lr
;;;980    
                          ENDP


                          AREA ||i.TIM_DMAConfig||, CODE, READONLY, ALIGN=1

                  TIM_DMAConfig PROC
;;;934      */
;;;935    void TIM_DMAConfig(TIM_TypeDef* TIMx, uint16_t TIM_DMABase, uint16_t TIM_DMABurstLength)
000000  ea410302          ORR      r3,r1,r2
;;;936    {
;;;937      /* Check the parameters */
;;;938      assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;939      assert_param(IS_TIM_DMA_BASE(TIM_DMABase));
;;;940      assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));
;;;941      /* Set the DMA Base and the DMA Burst Length */
;;;942      TIMx->DCR = TIM_DMABase | TIM_DMABurstLength;
000004  f8a03048          STRH     r3,[r0,#0x48]
;;;943    }
000008  4770              BX       lr
;;;944    
                          ENDP


                          AREA ||i.TIM_DeInit||, CODE, READONLY, ALIGN=2

                  TIM_DeInit PROC
;;;120      */
;;;121    void TIM_DeInit(TIM_TypeDef* TIMx)
000000  b510              PUSH     {r4,lr}
;;;122    {
000002  4604              MOV      r4,r0
;;;123      /* Check the parameters */
;;;124      assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
;;;125     
;;;126      if (TIMx == TIM1)
000004  4868              LDR      r0,|L22.424|
000006  4284              CMP      r4,r0
000008  d108              BNE      |L22.28|
;;;127      {
;;;128        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
00000a  2101              MOVS     r1,#1
00000c  14c0              ASRS     r0,r0,#19
00000e  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;129        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
000012  2100              MOVS     r1,#0
000014  14e0              ASRS     r0,r4,#19
000016  f7fffffe          BL       RCC_APB2PeriphResetCmd
00001a  e0c4              B        |L22.422|
                  |L22.28|
;;;130      }     
;;;131      else if (TIMx == TIM2)
00001c  f1b44f80          CMP      r4,#0x40000000
000020  d108              BNE      |L22.52|
;;;132      {
;;;133        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
000022  2101              MOVS     r1,#1
000024  4608              MOV      r0,r1
000026  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;134        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
00002a  2100              MOVS     r1,#0
00002c  2001              MOVS     r0,#1
00002e  f7fffffe          BL       RCC_APB1PeriphResetCmd
000032  e0b8              B        |L22.422|
                  |L22.52|
;;;135      }
;;;136      else if (TIMx == TIM3)
000034  485d              LDR      r0,|L22.428|
000036  4284              CMP      r4,r0
000038  d108              BNE      |L22.76|
;;;137      {
;;;138        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
00003a  2101              MOVS     r1,#1
00003c  2002              MOVS     r0,#2
00003e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;139        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
000042  2100              MOVS     r1,#0
000044  2002              MOVS     r0,#2
000046  f7fffffe          BL       RCC_APB1PeriphResetCmd
00004a  e0ac              B        |L22.422|
                  |L22.76|
;;;140      }
;;;141      else if (TIMx == TIM4)
00004c  4858              LDR      r0,|L22.432|
00004e  4284              CMP      r4,r0
000050  d108              BNE      |L22.100|
;;;142      {
;;;143        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
000052  2101              MOVS     r1,#1
000054  2004              MOVS     r0,#4
000056  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;144        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
00005a  2100              MOVS     r1,#0
00005c  2004              MOVS     r0,#4
00005e  f7fffffe          BL       RCC_APB1PeriphResetCmd
000062  e0a0              B        |L22.422|
                  |L22.100|
;;;145      } 
;;;146      else if (TIMx == TIM5)
000064  4853              LDR      r0,|L22.436|
000066  4284              CMP      r4,r0
000068  d108              BNE      |L22.124|
;;;147      {
;;;148        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, ENABLE);
00006a  2101              MOVS     r1,#1
00006c  2008              MOVS     r0,#8
00006e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;149        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, DISABLE);
000072  2100              MOVS     r1,#0
000074  2008              MOVS     r0,#8
000076  f7fffffe          BL       RCC_APB1PeriphResetCmd
00007a  e094              B        |L22.422|
                  |L22.124|
;;;150      } 
;;;151      else if (TIMx == TIM6)
00007c  484e              LDR      r0,|L22.440|
00007e  4284              CMP      r4,r0
000080  d108              BNE      |L22.148|
;;;152      {
;;;153        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
000082  2101              MOVS     r1,#1
000084  2010              MOVS     r0,#0x10
000086  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;154        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
00008a  2100              MOVS     r1,#0
00008c  2010              MOVS     r0,#0x10
00008e  f7fffffe          BL       RCC_APB1PeriphResetCmd
000092  e088              B        |L22.422|
                  |L22.148|
;;;155      } 
;;;156      else if (TIMx == TIM7)
000094  4849              LDR      r0,|L22.444|
000096  4284              CMP      r4,r0
000098  d108              BNE      |L22.172|
;;;157      {
;;;158        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
00009a  2101              MOVS     r1,#1
00009c  2020              MOVS     r0,#0x20
00009e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;159        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
0000a2  2100              MOVS     r1,#0
0000a4  2020              MOVS     r0,#0x20
0000a6  f7fffffe          BL       RCC_APB1PeriphResetCmd
0000aa  e07c              B        |L22.422|
                  |L22.172|
;;;160      } 
;;;161      else if (TIMx == TIM8)
0000ac  4844              LDR      r0,|L22.448|
0000ae  4284              CMP      r4,r0
0000b0  d108              BNE      |L22.196|
;;;162      {
;;;163        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);
0000b2  2101              MOVS     r1,#1
0000b4  1440              ASRS     r0,r0,#17
0000b6  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;164        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);
0000ba  2100              MOVS     r1,#0
0000bc  1460              ASRS     r0,r4,#17
0000be  f7fffffe          BL       RCC_APB2PeriphResetCmd
0000c2  e070              B        |L22.422|
                  |L22.196|
;;;165      }
;;;166      else if (TIMx == TIM9)
0000c4  483f              LDR      r0,|L22.452|
0000c6  4284              CMP      r4,r0
0000c8  d109              BNE      |L22.222|
;;;167      {      
;;;168        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, ENABLE);
0000ca  2101              MOVS     r1,#1
0000cc  04c8              LSLS     r0,r1,#19
0000ce  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;169        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, DISABLE);  
0000d2  2100              MOVS     r1,#0
0000d4  f44f2000          MOV      r0,#0x80000
0000d8  f7fffffe          BL       RCC_APB2PeriphResetCmd
0000dc  e063              B        |L22.422|
                  |L22.222|
;;;170       }  
;;;171      else if (TIMx == TIM10)
0000de  483a              LDR      r0,|L22.456|
0000e0  4284              CMP      r4,r0
0000e2  d109              BNE      |L22.248|
;;;172      {      
;;;173        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, ENABLE);
0000e4  2101              MOVS     r1,#1
0000e6  0508              LSLS     r0,r1,#20
0000e8  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;174        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, DISABLE);  
0000ec  2100              MOVS     r1,#0
0000ee  f44f1080          MOV      r0,#0x100000
0000f2  f7fffffe          BL       RCC_APB2PeriphResetCmd
0000f6  e056              B        |L22.422|
                  |L22.248|
;;;175      }  
;;;176      else if (TIMx == TIM11) 
0000f8  4834              LDR      r0,|L22.460|
0000fa  4284              CMP      r4,r0
0000fc  d109              BNE      |L22.274|
;;;177      {     
;;;178        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, ENABLE);
0000fe  2101              MOVS     r1,#1
000100  0548              LSLS     r0,r1,#21
000102  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;179        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, DISABLE);  
000106  2100              MOVS     r1,#0
000108  f44f1000          MOV      r0,#0x200000
00010c  f7fffffe          BL       RCC_APB2PeriphResetCmd
000110  e049              B        |L22.422|
                  |L22.274|
;;;180      }  
;;;181      else if (TIMx == TIM12)
000112  482f              LDR      r0,|L22.464|
000114  4284              CMP      r4,r0
000116  d108              BNE      |L22.298|
;;;182      {      
;;;183        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, ENABLE);
000118  2101              MOVS     r1,#1
00011a  2040              MOVS     r0,#0x40
00011c  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;184        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, DISABLE);  
000120  2100              MOVS     r1,#0
000122  2040              MOVS     r0,#0x40
000124  f7fffffe          BL       RCC_APB1PeriphResetCmd
000128  e03d              B        |L22.422|
                  |L22.298|
;;;185      }  
;;;186      else if (TIMx == TIM13) 
00012a  482a              LDR      r0,|L22.468|
00012c  4284              CMP      r4,r0
00012e  d108              BNE      |L22.322|
;;;187      {       
;;;188        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, ENABLE);
000130  2101              MOVS     r1,#1
000132  2080              MOVS     r0,#0x80
000134  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;189        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, DISABLE);  
000138  2100              MOVS     r1,#0
00013a  2080              MOVS     r0,#0x80
00013c  f7fffffe          BL       RCC_APB1PeriphResetCmd
000140  e031              B        |L22.422|
                  |L22.322|
;;;190      }
;;;191      else if (TIMx == TIM14) 
000142  4825              LDR      r0,|L22.472|
000144  4284              CMP      r4,r0
000146  d108              BNE      |L22.346|
;;;192      {       
;;;193        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, ENABLE);
000148  2101              MOVS     r1,#1
00014a  1580              ASRS     r0,r0,#22
00014c  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;194        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, DISABLE);  
000150  2100              MOVS     r1,#0
000152  15a0              ASRS     r0,r4,#22
000154  f7fffffe          BL       RCC_APB1PeriphResetCmd
000158  e025              B        |L22.422|
                  |L22.346|
;;;195      }        
;;;196      else if (TIMx == TIM15)
00015a  4820              LDR      r0,|L22.476|
00015c  4284              CMP      r4,r0
00015e  d109              BNE      |L22.372|
;;;197      {
;;;198        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM15, ENABLE);
000160  2101              MOVS     r1,#1
000162  0408              LSLS     r0,r1,#16
000164  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;199        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM15, DISABLE);
000168  2100              MOVS     r1,#0
00016a  f44f3080          MOV      r0,#0x10000
00016e  f7fffffe          BL       RCC_APB2PeriphResetCmd
000172  e018              B        |L22.422|
                  |L22.372|
;;;200      } 
;;;201      else if (TIMx == TIM16)
000174  481a              LDR      r0,|L22.480|
000176  4284              CMP      r4,r0
000178  d109              BNE      |L22.398|
;;;202      {
;;;203        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM16, ENABLE);
00017a  2101              MOVS     r1,#1
00017c  0448              LSLS     r0,r1,#17
00017e  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;204        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM16, DISABLE);
000182  2100              MOVS     r1,#0
000184  f44f3000          MOV      r0,#0x20000
000188  f7fffffe          BL       RCC_APB2PeriphResetCmd
00018c  e00b              B        |L22.422|
                  |L22.398|
;;;205      } 
;;;206      else
;;;207      {
;;;208        if (TIMx == TIM17)
00018e  4815              LDR      r0,|L22.484|
000190  4284              CMP      r4,r0
000192  d108              BNE      |L22.422|
;;;209        {
;;;210          RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM17, ENABLE);
000194  2101              MOVS     r1,#1
000196  0488              LSLS     r0,r1,#18
000198  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;211          RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM17, DISABLE);
00019c  2100              MOVS     r1,#0
00019e  f44f2080          MOV      r0,#0x40000
0001a2  f7fffffe          BL       RCC_APB2PeriphResetCmd
                  |L22.422|
;;;212        }  
;;;213      }
;;;214    }
0001a6  bd10              POP      {r4,pc}
;;;215    
                          ENDP

                  |L22.424|
                          DCD      0x40012c00
                  |L22.428|
                          DCD      0x40000400
                  |L22.432|
                          DCD      0x40000800
                  |L22.436|
                          DCD      0x40000c00
                  |L22.440|
                          DCD      0x40001000
                  |L22.444|
                          DCD      0x40001400
                  |L22.448|
                          DCD      0x40013400
                  |L22.452|
                          DCD      0x40014c00
                  |L22.456|
                          DCD      0x40015000
                  |L22.460|
                          DCD      0x40015400
                  |L22.464|
                          DCD      0x40001800
                  |L22.468|
                          DCD      0x40001c00
                  |L22.472|
                          DCD      0x40002000
                  |L22.476|
                          DCD      0x40014000
                  |L22.480|
                          DCD      0x40014400
                  |L22.484|
                          DCD      0x40014800

                          AREA ||i.TIM_ETRClockMode1Config||, CODE, READONLY, ALIGN=1

                  TIM_ETRClockMode1Config PROC
;;;1072     */
;;;1073   void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1074                                uint16_t ExtTRGFilter)
;;;1075   {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;1076     uint16_t tmpsmcr = 0;
00000c  2400              MOVS     r4,#0
;;;1077     /* Check the parameters */
;;;1078     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1079     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;1080     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;1081     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;1082     /* Configure the ETR Clock source */
;;;1083     TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
00000e  4643              MOV      r3,r8
000010  463a              MOV      r2,r7
000012  4631              MOV      r1,r6
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       TIM_ETRConfig
;;;1084     
;;;1085     /* Get the TIMx SMCR register value */
;;;1086     tmpsmcr = TIMx->SMCR;
00001a  892c              LDRH     r4,[r5,#8]
;;;1087     /* Reset the SMS Bits */
;;;1088     tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
00001c  f64f70f8          MOV      r0,#0xfff8
000020  4004              ANDS     r4,r4,r0
;;;1089     /* Select the External clock mode1 */
;;;1090     tmpsmcr |= TIM_SlaveMode_External1;
000022  f0440407          ORR      r4,r4,#7
;;;1091     /* Select the Trigger selection : ETRF */
;;;1092     tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_TS));
000026  f64f708f          MOV      r0,#0xff8f
00002a  4004              ANDS     r4,r4,r0
;;;1093     tmpsmcr |= TIM_TS_ETRF;
00002c  f0440470          ORR      r4,r4,#0x70
;;;1094     /* Write to TIMx SMCR */
;;;1095     TIMx->SMCR = tmpsmcr;
000030  812c              STRH     r4,[r5,#8]
;;;1096   }
000032  e8bd81f0          POP      {r4-r8,pc}
;;;1097   
                          ENDP


                          AREA ||i.TIM_ETRClockMode2Config||, CODE, READONLY, ALIGN=1

                  TIM_ETRClockMode2Config PROC
;;;1114     */
;;;1115   void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, 
000000  b5f0              PUSH     {r4-r7,lr}
;;;1116                                uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
;;;1117   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
000008  461f              MOV      r7,r3
;;;1118     /* Check the parameters */
;;;1119     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1120     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;1121     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;1122     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;1123     /* Configure the ETR Clock source */
;;;1124     TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
00000a  463b              MOV      r3,r7
00000c  4632              MOV      r2,r6
00000e  4629              MOV      r1,r5
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       TIM_ETRConfig
;;;1125     /* Enable the External clock mode2 */
;;;1126     TIMx->SMCR |= TIM_SMCR_ECE;
000016  8920              LDRH     r0,[r4,#8]
000018  f4404080          ORR      r0,r0,#0x4000
00001c  8120              STRH     r0,[r4,#8]
;;;1127   }
00001e  bdf0              POP      {r4-r7,pc}
;;;1128   
                          ENDP


                          AREA ||i.TIM_ETRConfig||, CODE, READONLY, ALIGN=1

                  TIM_ETRConfig PROC
;;;1145     */
;;;1146   void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
000000  b530              PUSH     {r4,r5,lr}
;;;1147                      uint16_t ExtTRGFilter)
;;;1148   {
000002  460c              MOV      r4,r1
;;;1149     uint16_t tmpsmcr = 0;
000004  2100              MOVS     r1,#0
;;;1150     /* Check the parameters */
;;;1151     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1152     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;1153     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;1154     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;1155     tmpsmcr = TIMx->SMCR;
000006  8901              LDRH     r1,[r0,#8]
;;;1156     /* Reset the ETR Bits */
;;;1157     tmpsmcr &= SMCR_ETR_Mask;
000008  b2c9              UXTB     r1,r1
;;;1158     /* Set the Prescaler, the Filter value and the Polarity */
;;;1159     tmpsmcr |= (uint16_t)(TIM_ExtTRGPrescaler | (uint16_t)(TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << (uint16_t)8)));
00000a  f64f75ff          MOV      r5,#0xffff
00000e  ea052503          AND      r5,r5,r3,LSL #8
000012  4315              ORRS     r5,r5,r2
000014  4325              ORRS     r5,r5,r4
000016  4329              ORRS     r1,r1,r5
;;;1160     /* Write to TIMx SMCR */
;;;1161     TIMx->SMCR = tmpsmcr;
000018  8101              STRH     r1,[r0,#8]
;;;1162   }
00001a  bd30              POP      {r4,r5,pc}
;;;1163   
                          ENDP


                          AREA ||i.TIM_EncoderInterfaceConfig||, CODE, READONLY, ALIGN=1

                  TIM_EncoderInterfaceConfig PROC
;;;1261     */
;;;1262   void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
000000  b5f0              PUSH     {r4-r7,lr}
;;;1263                                   uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity)
;;;1264   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
000006  461e              MOV      r6,r3
;;;1265     uint16_t tmpsmcr = 0;
000008  2100              MOVS     r1,#0
;;;1266     uint16_t tmpccmr1 = 0;
00000a  2200              MOVS     r2,#0
;;;1267     uint16_t tmpccer = 0;
00000c  2300              MOVS     r3,#0
;;;1268       
;;;1269     /* Check the parameters */
;;;1270     assert_param(IS_TIM_LIST5_PERIPH(TIMx));
;;;1271     assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
;;;1272     assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
;;;1273     assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));
;;;1274   
;;;1275     /* Get the TIMx SMCR register value */
;;;1276     tmpsmcr = TIMx->SMCR;
00000e  8901              LDRH     r1,[r0,#8]
;;;1277     
;;;1278     /* Get the TIMx CCMR1 register value */
;;;1279     tmpccmr1 = TIMx->CCMR1;
000010  8b02              LDRH     r2,[r0,#0x18]
;;;1280     
;;;1281     /* Get the TIMx CCER register value */
;;;1282     tmpccer = TIMx->CCER;
000012  8c03              LDRH     r3,[r0,#0x20]
;;;1283     
;;;1284     /* Set the encoder Mode */
;;;1285     tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
000014  f64f77f8          MOV      r7,#0xfff8
000018  4039              ANDS     r1,r1,r7
;;;1286     tmpsmcr |= TIM_EncoderMode;
00001a  4321              ORRS     r1,r1,r4
;;;1287     
;;;1288     /* Select the Capture Compare 1 and the Capture Compare 2 as input */
;;;1289     tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & (uint16_t)(~((uint16_t)TIM_CCMR1_CC2S)));
00001c  f64f47fc          MOV      r7,#0xfcfc
000020  403a              ANDS     r2,r2,r7
;;;1290     tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;
000022  f2401701          MOV      r7,#0x101
000026  433a              ORRS     r2,r2,r7
;;;1291     
;;;1292     /* Set the TI1 and the TI2 Polarities */
;;;1293     tmpccer &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCER_CC1P)) & ((uint16_t)~((uint16_t)TIM_CCER_CC2P)));
000028  f64f77dd          MOV      r7,#0xffdd
00002c  403b              ANDS     r3,r3,r7
;;;1294     tmpccer |= (uint16_t)(TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << (uint16_t)4));
00002e  f64f77ff          MOV      r7,#0xffff
000032  ea071706          AND      r7,r7,r6,LSL #4
000036  432f              ORRS     r7,r7,r5
000038  433b              ORRS     r3,r3,r7
;;;1295     
;;;1296     /* Write to TIMx SMCR */
;;;1297     TIMx->SMCR = tmpsmcr;
00003a  8101              STRH     r1,[r0,#8]
;;;1298     /* Write to TIMx CCMR1 */
;;;1299     TIMx->CCMR1 = tmpccmr1;
00003c  8302              STRH     r2,[r0,#0x18]
;;;1300     /* Write to TIMx CCER */
;;;1301     TIMx->CCER = tmpccer;
00003e  8403              STRH     r3,[r0,#0x20]
;;;1302   }
000040  bdf0              POP      {r4-r7,pc}
;;;1303   
                          ENDP


                          AREA ||i.TIM_ForcedOC1Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC1Config PROC
;;;1312     */
;;;1313   void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  460a              MOV      r2,r1
;;;1314   {
;;;1315     uint16_t tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1316     /* Check the parameters */
;;;1317     assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;1318     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1319     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1320     /* Reset the OC1M Bits */
;;;1321     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1M);
000006  f64f738f          MOV      r3,#0xff8f
00000a  4019              ANDS     r1,r1,r3
;;;1322     /* Configure The Forced output Mode */
;;;1323     tmpccmr1 |= TIM_ForcedAction;
00000c  4311              ORRS     r1,r1,r2
;;;1324     /* Write to TIMx CCMR1 register */
;;;1325     TIMx->CCMR1 = tmpccmr1;
00000e  8301              STRH     r1,[r0,#0x18]
;;;1326   }
000010  4770              BX       lr
;;;1327   
                          ENDP


                          AREA ||i.TIM_ForcedOC2Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC2Config PROC
;;;1336     */
;;;1337   void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  460a              MOV      r2,r1
;;;1338   {
;;;1339     uint16_t tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1340     /* Check the parameters */
;;;1341     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;1342     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1343     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1344     /* Reset the OC2M Bits */
;;;1345     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2M);
000006  f64873ff          MOV      r3,#0x8fff
00000a  4019              ANDS     r1,r1,r3
;;;1346     /* Configure The Forced output Mode */
;;;1347     tmpccmr1 |= (uint16_t)(TIM_ForcedAction << 8);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032302          AND      r3,r3,r2,LSL #8
000014  4319              ORRS     r1,r1,r3
;;;1348     /* Write to TIMx CCMR1 register */
;;;1349     TIMx->CCMR1 = tmpccmr1;
000016  8301              STRH     r1,[r0,#0x18]
;;;1350   }
000018  4770              BX       lr
;;;1351   
                          ENDP


                          AREA ||i.TIM_ForcedOC3Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC3Config PROC
;;;1360     */
;;;1361   void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  460a              MOV      r2,r1
;;;1362   {
;;;1363     uint16_t tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1364     /* Check the parameters */
;;;1365     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1366     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1367     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1368     /* Reset the OC1M Bits */
;;;1369     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3M);
000006  f64f738f          MOV      r3,#0xff8f
00000a  4019              ANDS     r1,r1,r3
;;;1370     /* Configure The Forced output Mode */
;;;1371     tmpccmr2 |= TIM_ForcedAction;
00000c  4311              ORRS     r1,r1,r2
;;;1372     /* Write to TIMx CCMR2 register */
;;;1373     TIMx->CCMR2 = tmpccmr2;
00000e  8381              STRH     r1,[r0,#0x1c]
;;;1374   }
000010  4770              BX       lr
;;;1375   
                          ENDP


                          AREA ||i.TIM_ForcedOC4Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC4Config PROC
;;;1384     */
;;;1385   void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  460a              MOV      r2,r1
;;;1386   {
;;;1387     uint16_t tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1388     /* Check the parameters */
;;;1389     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1390     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1391     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1392     /* Reset the OC2M Bits */
;;;1393     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4M);
000006  f64873ff          MOV      r3,#0x8fff
00000a  4019              ANDS     r1,r1,r3
;;;1394     /* Configure The Forced output Mode */
;;;1395     tmpccmr2 |= (uint16_t)(TIM_ForcedAction << 8);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032302          AND      r3,r3,r2,LSL #8
000014  4319              ORRS     r1,r1,r3
;;;1396     /* Write to TIMx CCMR2 register */
;;;1397     TIMx->CCMR2 = tmpccmr2;
000016  8381              STRH     r1,[r0,#0x1c]
;;;1398   }
000018  4770              BX       lr
;;;1399   
                          ENDP


                          AREA ||i.TIM_GenerateEvent||, CODE, READONLY, ALIGN=1

                  TIM_GenerateEvent PROC
;;;906      */
;;;907    void TIM_GenerateEvent(TIM_TypeDef* TIMx, uint16_t TIM_EventSource)
000000  8281              STRH     r1,[r0,#0x14]
;;;908    { 
;;;909      /* Check the parameters */
;;;910      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;911      assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource));
;;;912      
;;;913      /* Set the event sources */
;;;914      TIMx->EGR = TIM_EventSource;
;;;915    }
000002  4770              BX       lr
;;;916    
                          ENDP


                          AREA ||i.TIM_GetCapture1||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture1 PROC
;;;2454     */
;;;2455   uint16_t TIM_GetCapture1(TIM_TypeDef* TIMx)
000000  4601              MOV      r1,r0
;;;2456   {
;;;2457     /* Check the parameters */
;;;2458     assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;2459     /* Get the Capture 1 Register value */
;;;2460     return TIMx->CCR1;
000002  8e88              LDRH     r0,[r1,#0x34]
;;;2461   }
000004  4770              BX       lr
;;;2462   
                          ENDP


                          AREA ||i.TIM_GetCapture2||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture2 PROC
;;;2467     */
;;;2468   uint16_t TIM_GetCapture2(TIM_TypeDef* TIMx)
000000  4601              MOV      r1,r0
;;;2469   {
;;;2470     /* Check the parameters */
;;;2471     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;2472     /* Get the Capture 2 Register value */
;;;2473     return TIMx->CCR2;
000002  8f08              LDRH     r0,[r1,#0x38]
;;;2474   }
000004  4770              BX       lr
;;;2475   
                          ENDP


                          AREA ||i.TIM_GetCapture3||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture3 PROC
;;;2480     */
;;;2481   uint16_t TIM_GetCapture3(TIM_TypeDef* TIMx)
000000  4601              MOV      r1,r0
;;;2482   {
;;;2483     /* Check the parameters */
;;;2484     assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
;;;2485     /* Get the Capture 3 Register value */
;;;2486     return TIMx->CCR3;
000002  8f88              LDRH     r0,[r1,#0x3c]
;;;2487   }
000004  4770              BX       lr
;;;2488   
                          ENDP


                          AREA ||i.TIM_GetCapture4||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture4 PROC
;;;2493     */
;;;2494   uint16_t TIM_GetCapture4(TIM_TypeDef* TIMx)
000000  4601              MOV      r1,r0
;;;2495   {
;;;2496     /* Check the parameters */
;;;2497     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2498     /* Get the Capture 4 Register value */
;;;2499     return TIMx->CCR4;
000002  f8b10040          LDRH     r0,[r1,#0x40]
;;;2500   }
000006  4770              BX       lr
;;;2501   
                          ENDP


                          AREA ||i.TIM_GetCounter||, CODE, READONLY, ALIGN=1

                  TIM_GetCounter PROC
;;;2506     */
;;;2507   uint16_t TIM_GetCounter(TIM_TypeDef* TIMx)
000000  4601              MOV      r1,r0
;;;2508   {
;;;2509     /* Check the parameters */
;;;2510     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2511     /* Get the Counter Register value */
;;;2512     return TIMx->CNT;
000002  8c88              LDRH     r0,[r1,#0x24]
;;;2513   }
000004  4770              BX       lr
;;;2514   
                          ENDP


                          AREA ||i.TIM_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  TIM_GetFlagStatus PROC
;;;2553     */
;;;2554   FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
000000  4602              MOV      r2,r0
;;;2555   { 
;;;2556     ITStatus bitstatus = RESET;  
000002  2000              MOVS     r0,#0
;;;2557     /* Check the parameters */
;;;2558     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2559     assert_param(IS_TIM_GET_FLAG(TIM_FLAG));
;;;2560     
;;;2561     if ((TIMx->SR & TIM_FLAG) != (uint16_t)RESET)
000004  8a13              LDRH     r3,[r2,#0x10]
000006  400b              ANDS     r3,r3,r1
000008  b10b              CBZ      r3,|L37.14|
;;;2562     {
;;;2563       bitstatus = SET;
00000a  2001              MOVS     r0,#1
00000c  e000              B        |L37.16|
                  |L37.14|
;;;2564     }
;;;2565     else
;;;2566     {
;;;2567       bitstatus = RESET;
00000e  2000              MOVS     r0,#0
                  |L37.16|
;;;2568     }
;;;2569     return bitstatus;
;;;2570   }
000010  4770              BX       lr
;;;2571   
                          ENDP


                          AREA ||i.TIM_GetITStatus||, CODE, READONLY, ALIGN=1

                  TIM_GetITStatus PROC
;;;2629     */
;;;2630   ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT)
000000  b530              PUSH     {r4,r5,lr}
;;;2631   {
000002  4602              MOV      r2,r0
;;;2632     ITStatus bitstatus = RESET;  
000004  2000              MOVS     r0,#0
;;;2633     uint16_t itstatus = 0x0, itenable = 0x0;
000006  2300              MOVS     r3,#0
000008  2400              MOVS     r4,#0
;;;2634     /* Check the parameters */
;;;2635     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2636     assert_param(IS_TIM_GET_IT(TIM_IT));
;;;2637      
;;;2638     itstatus = TIMx->SR & TIM_IT;
00000a  8a15              LDRH     r5,[r2,#0x10]
00000c  ea050301          AND      r3,r5,r1
;;;2639     
;;;2640     itenable = TIMx->DIER & TIM_IT;
000010  8995              LDRH     r5,[r2,#0xc]
000012  ea050401          AND      r4,r5,r1
;;;2641     if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
000016  b113              CBZ      r3,|L38.30|
000018  b10c              CBZ      r4,|L38.30|
;;;2642     {
;;;2643       bitstatus = SET;
00001a  2001              MOVS     r0,#1
00001c  e000              B        |L38.32|
                  |L38.30|
;;;2644     }
;;;2645     else
;;;2646     {
;;;2647       bitstatus = RESET;
00001e  2000              MOVS     r0,#0
                  |L38.32|
;;;2648     }
;;;2649     return bitstatus;
;;;2650   }
000020  bd30              POP      {r4,r5,pc}
;;;2651   
                          ENDP


                          AREA ||i.TIM_GetPrescaler||, CODE, READONLY, ALIGN=1

                  TIM_GetPrescaler PROC
;;;2519     */
;;;2520   uint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx)
000000  4601              MOV      r1,r0
;;;2521   {
;;;2522     /* Check the parameters */
;;;2523     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2524     /* Get the Prescaler Register value */
;;;2525     return TIMx->PSC;
000002  8d08              LDRH     r0,[r1,#0x28]
;;;2526   }
000004  4770              BX       lr
;;;2527   
                          ENDP


                          AREA ||i.TIM_ICInit||, CODE, READONLY, ALIGN=2

                  TIM_ICInit PROC
;;;584      */
;;;585    void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;586    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;587      /* Check the parameters */
;;;588      assert_param(IS_TIM_CHANNEL(TIM_ICInitStruct->TIM_Channel));  
;;;589      assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
;;;590      assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
;;;591      assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
;;;592      
;;;593      if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) ||
000006  4824              LDR      r0,|L40.152|
000008  4285              CMP      r5,r0
00000a  d00e              BEQ      |L40.42|
00000c  4823              LDR      r0,|L40.156|
00000e  4285              CMP      r5,r0
000010  d00b              BEQ      |L40.42|
000012  f1b54f80          CMP      r5,#0x40000000
000016  d008              BEQ      |L40.42|
000018  4821              LDR      r0,|L40.160|
00001a  4285              CMP      r5,r0
00001c  d005              BEQ      |L40.42|
;;;594         (TIMx == TIM4) ||(TIMx == TIM5))
00001e  4821              LDR      r0,|L40.164|
000020  4285              CMP      r5,r0
000022  d002              BEQ      |L40.42|
000024  4820              LDR      r0,|L40.168|
000026  4285              CMP      r5,r0
000028  d100              BNE      |L40.44|
                  |L40.42|
;;;595      {
;;;596        assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
00002a  e000              B        |L40.46|
                  |L40.44|
;;;597      }
;;;598      else
;;;599      {
;;;600        assert_param(IS_TIM_IC_POLARITY_LITE(TIM_ICInitStruct->TIM_ICPolarity));
00002c  bf00              NOP      
                  |L40.46|
;;;601      }
;;;602      if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
00002e  8820              LDRH     r0,[r4,#0]
000030  b950              CBNZ     r0,|L40.72|
;;;603      {
;;;604        assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;605        /* TI1 Configuration */
;;;606        TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
000032  8923              LDRH     r3,[r4,#8]
000034  88a2              LDRH     r2,[r4,#4]
000036  8861              LDRH     r1,[r4,#2]
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       TI1_Config
;;;607                   TIM_ICInitStruct->TIM_ICSelection,
;;;608                   TIM_ICInitStruct->TIM_ICFilter);
;;;609        /* Set the Input Capture Prescaler value */
;;;610        TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
00003e  88e1              LDRH     r1,[r4,#6]
000040  4628              MOV      r0,r5
000042  f7fffffe          BL       TIM_SetIC1Prescaler
000046  e025              B        |L40.148|
                  |L40.72|
;;;611      }
;;;612      else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
000048  8820              LDRH     r0,[r4,#0]
00004a  2804              CMP      r0,#4
00004c  d10a              BNE      |L40.100|
;;;613      {
;;;614        assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;615        /* TI2 Configuration */
;;;616        TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
00004e  8923              LDRH     r3,[r4,#8]
000050  88a2              LDRH     r2,[r4,#4]
000052  8861              LDRH     r1,[r4,#2]
000054  4628              MOV      r0,r5
000056  f7fffffe          BL       TI2_Config
;;;617                   TIM_ICInitStruct->TIM_ICSelection,
;;;618                   TIM_ICInitStruct->TIM_ICFilter);
;;;619        /* Set the Input Capture Prescaler value */
;;;620        TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
00005a  88e1              LDRH     r1,[r4,#6]
00005c  4628              MOV      r0,r5
00005e  f7fffffe          BL       TIM_SetIC2Prescaler
000062  e017              B        |L40.148|
                  |L40.100|
;;;621      }
;;;622      else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
000064  8820              LDRH     r0,[r4,#0]
000066  2808              CMP      r0,#8
000068  d10a              BNE      |L40.128|
;;;623      {
;;;624        assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;625        /* TI3 Configuration */
;;;626        TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
00006a  8923              LDRH     r3,[r4,#8]
00006c  88a2              LDRH     r2,[r4,#4]
00006e  8861              LDRH     r1,[r4,#2]
000070  4628              MOV      r0,r5
000072  f7fffffe          BL       TI3_Config
;;;627                   TIM_ICInitStruct->TIM_ICSelection,
;;;628                   TIM_ICInitStruct->TIM_ICFilter);
;;;629        /* Set the Input Capture Prescaler value */
;;;630        TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000076  88e1              LDRH     r1,[r4,#6]
000078  4628              MOV      r0,r5
00007a  f7fffffe          BL       TIM_SetIC3Prescaler
00007e  e009              B        |L40.148|
                  |L40.128|
;;;631      }
;;;632      else
;;;633      {
;;;634        assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;635        /* TI4 Configuration */
;;;636        TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
000080  8923              LDRH     r3,[r4,#8]
000082  88a2              LDRH     r2,[r4,#4]
000084  8861              LDRH     r1,[r4,#2]
000086  4628              MOV      r0,r5
000088  f7fffffe          BL       TI4_Config
;;;637                   TIM_ICInitStruct->TIM_ICSelection,
;;;638                   TIM_ICInitStruct->TIM_ICFilter);
;;;639        /* Set the Input Capture Prescaler value */
;;;640        TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
00008c  88e1              LDRH     r1,[r4,#6]
00008e  4628              MOV      r0,r5
000090  f7fffffe          BL       TIM_SetIC4Prescaler
                  |L40.148|
;;;641      }
;;;642    }
000094  bd70              POP      {r4-r6,pc}
;;;643    
                          ENDP

000096  0000              DCW      0x0000
                  |L40.152|
                          DCD      0x40012c00
                  |L40.156|
                          DCD      0x40013400
                  |L40.160|
                          DCD      0x40000400
                  |L40.164|
                          DCD      0x40000800
                  |L40.168|
                          DCD      0x40000c00

                          AREA ||i.TIM_ICStructInit||, CODE, READONLY, ALIGN=1

                  TIM_ICStructInit PROC
;;;768      */
;;;769    void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
000000  2100              MOVS     r1,#0
;;;770    {
;;;771      /* Set the default configuration */
;;;772      TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
000002  8001              STRH     r1,[r0,#0]
;;;773      TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
000004  8041              STRH     r1,[r0,#2]
;;;774      TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
000006  2101              MOVS     r1,#1
000008  8081              STRH     r1,[r0,#4]
;;;775      TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
00000a  2100              MOVS     r1,#0
00000c  80c1              STRH     r1,[r0,#6]
;;;776      TIM_ICInitStruct->TIM_ICFilter = 0x00;
00000e  8101              STRH     r1,[r0,#8]
;;;777    }
000010  4770              BX       lr
;;;778    
                          ENDP


                          AREA ||i.TIM_ITConfig||, CODE, READONLY, ALIGN=1

                  TIM_ITConfig PROC
;;;869      */
;;;870    void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState)
000000  b11a              CBZ      r2,|L42.10|
;;;871    {  
;;;872      /* Check the parameters */
;;;873      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;874      assert_param(IS_TIM_IT(TIM_IT));
;;;875      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;876      
;;;877      if (NewState != DISABLE)
;;;878      {
;;;879        /* Enable the Interrupt sources */
;;;880        TIMx->DIER |= TIM_IT;
000002  8983              LDRH     r3,[r0,#0xc]
000004  430b              ORRS     r3,r3,r1
000006  8183              STRH     r3,[r0,#0xc]
000008  e002              B        |L42.16|
                  |L42.10|
;;;881      }
;;;882      else
;;;883      {
;;;884        /* Disable the Interrupt sources */
;;;885        TIMx->DIER &= (uint16_t)~TIM_IT;
00000a  8983              LDRH     r3,[r0,#0xc]
00000c  438b              BICS     r3,r3,r1
00000e  8183              STRH     r3,[r0,#0xc]
                  |L42.16|
;;;886      }
;;;887    }
000010  4770              BX       lr
;;;888    
                          ENDP


                          AREA ||i.TIM_ITRxExternalClockConfig||, CODE, READONLY, ALIGN=1

                  TIM_ITRxExternalClockConfig PROC
;;;1005     */
;;;1006   void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
000000  b530              PUSH     {r4,r5,lr}
;;;1007   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1008     /* Check the parameters */
;;;1009     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;1010     assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));
;;;1011     /* Select the Internal Trigger */
;;;1012     TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
000006  4629              MOV      r1,r5
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       TIM_SelectInputTrigger
;;;1013     /* Select the External clock mode1 */
;;;1014     TIMx->SMCR |= TIM_SlaveMode_External1;
00000e  8920              LDRH     r0,[r4,#8]
000010  f0400007          ORR      r0,r0,#7
000014  8120              STRH     r0,[r4,#8]
;;;1015   }
000016  bd30              POP      {r4,r5,pc}
;;;1016   
                          ENDP


                          AREA ||i.TIM_InternalClockConfig||, CODE, READONLY, ALIGN=1

                  TIM_InternalClockConfig PROC
;;;986      */
;;;987    void TIM_InternalClockConfig(TIM_TypeDef* TIMx)
000000  8901              LDRH     r1,[r0,#8]
;;;988    {
;;;989      /* Check the parameters */
;;;990      assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;991      /* Disable slave mode to clock the prescaler directly with the internal clock */
;;;992      TIMx->SMCR &=  (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
000002  f64f72f8          MOV      r2,#0xfff8
000006  4011              ANDS     r1,r1,r2
000008  8101              STRH     r1,[r0,#8]
;;;993    }
00000a  4770              BX       lr
;;;994    
                          ENDP


                          AREA ||i.TIM_OC1FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1FastConfig PROC
;;;1603     */
;;;1604   void TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  460a              MOV      r2,r1
;;;1605   {
;;;1606     uint16_t tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1607     /* Check the parameters */
;;;1608     assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;1609     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1610     /* Get the TIMx CCMR1 register value */
;;;1611     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1612     /* Reset the OC1FE Bit */
;;;1613     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1FE);
000006  f64f73fb          MOV      r3,#0xfffb
00000a  4019              ANDS     r1,r1,r3
;;;1614     /* Enable or Disable the Output Compare Fast Bit */
;;;1615     tmpccmr1 |= TIM_OCFast;
00000c  4311              ORRS     r1,r1,r2
;;;1616     /* Write to TIMx CCMR1 */
;;;1617     TIMx->CCMR1 = tmpccmr1;
00000e  8301              STRH     r1,[r0,#0x18]
;;;1618   }
000010  4770              BX       lr
;;;1619   
                          ENDP


                          AREA ||i.TIM_OC1Init||, CODE, READONLY, ALIGN=2

                  TIM_OC1Init PROC
;;;276      */
;;;277    void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;278    {
;;;279      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
000002  2400              MOVS     r4,#0
000004  2200              MOVS     r2,#0
000006  2300              MOVS     r3,#0
;;;280       
;;;281      /* Check the parameters */
;;;282      assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;283      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;284      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;285      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;286     /* Disable the Channel 1: Reset the CC1E Bit */
;;;287      TIMx->CCER &= (uint16_t)(~(uint16_t)TIM_CCER_CC1E);
000008  8c05              LDRH     r5,[r0,#0x20]
00000a  f64f76fe          MOV      r6,#0xfffe
00000e  4035              ANDS     r5,r5,r6
000010  8405              STRH     r5,[r0,#0x20]
;;;288      /* Get the TIMx CCER register value */
;;;289      tmpccer = TIMx->CCER;
000012  8c02              LDRH     r2,[r0,#0x20]
;;;290      /* Get the TIMx CR2 register value */
;;;291      tmpcr2 =  TIMx->CR2;
000014  8883              LDRH     r3,[r0,#4]
;;;292      
;;;293      /* Get the TIMx CCMR1 register value */
;;;294      tmpccmrx = TIMx->CCMR1;
000016  8b04              LDRH     r4,[r0,#0x18]
;;;295        
;;;296      /* Reset the Output Compare Mode Bits */
;;;297      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_OC1M));
000018  f64f758f          MOV      r5,#0xff8f
00001c  402c              ANDS     r4,r4,r5
;;;298      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_CC1S));
00001e  1eb5              SUBS     r5,r6,#2
000020  402c              ANDS     r4,r4,r5
;;;299    
;;;300      /* Select the Output Compare Mode */
;;;301      tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
000022  880d              LDRH     r5,[r1,#0]
000024  432c              ORRS     r4,r4,r5
;;;302      
;;;303      /* Reset the Output Polarity level */
;;;304      tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1P));
000026  1e75              SUBS     r5,r6,#1
000028  402a              ANDS     r2,r2,r5
;;;305      /* Set the Output Compare Polarity */
;;;306      tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
00002a  890d              LDRH     r5,[r1,#8]
00002c  432a              ORRS     r2,r2,r5
;;;307      
;;;308      /* Set the Output State */
;;;309      tmpccer |= TIM_OCInitStruct->TIM_OutputState;
00002e  884d              LDRH     r5,[r1,#2]
000030  432a              ORRS     r2,r2,r5
;;;310        
;;;311      if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM15)||
000032  4d14              LDR      r5,|L46.132|
000034  42a8              CMP      r0,r5
000036  d00b              BEQ      |L46.80|
000038  4d13              LDR      r5,|L46.136|
00003a  42a8              CMP      r0,r5
00003c  d008              BEQ      |L46.80|
00003e  4d13              LDR      r5,|L46.140|
000040  42a8              CMP      r0,r5
000042  d005              BEQ      |L46.80|
;;;312         (TIMx == TIM16)|| (TIMx == TIM17))
000044  4d12              LDR      r5,|L46.144|
000046  42a8              CMP      r0,r5
000048  d002              BEQ      |L46.80|
00004a  4d12              LDR      r5,|L46.148|
00004c  42a8              CMP      r0,r5
00004e  d113              BNE      |L46.120|
                  |L46.80|
;;;313      {
;;;314        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;315        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;316        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;317        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;318        
;;;319        /* Reset the Output N Polarity level */
;;;320        tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1NP));
000050  f64f75f7          MOV      r5,#0xfff7
000054  402a              ANDS     r2,r2,r5
;;;321        /* Set the Output N Polarity */
;;;322        tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
000056  894d              LDRH     r5,[r1,#0xa]
000058  432a              ORRS     r2,r2,r5
;;;323        
;;;324        /* Reset the Output N State */
;;;325        tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1NE));    
00005a  f64f75fb          MOV      r5,#0xfffb
00005e  402a              ANDS     r2,r2,r5
;;;326        /* Set the Output N State */
;;;327        tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
000060  888d              LDRH     r5,[r1,#4]
000062  432a              ORRS     r2,r2,r5
;;;328        
;;;329        /* Reset the Ouput Compare and Output Compare N IDLE State */
;;;330        tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS1));
000064  f64f65ff          MOV      r5,#0xfeff
000068  402b              ANDS     r3,r3,r5
;;;331        tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS1N));
00006a  f64f55ff          MOV      r5,#0xfdff
00006e  402b              ANDS     r3,r3,r5
;;;332        
;;;333        /* Set the Output Idle state */
;;;334        tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
000070  898d              LDRH     r5,[r1,#0xc]
000072  432b              ORRS     r3,r3,r5
;;;335        /* Set the Output N Idle state */
;;;336        tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
000074  89cd              LDRH     r5,[r1,#0xe]
000076  432b              ORRS     r3,r3,r5
                  |L46.120|
;;;337      }
;;;338      /* Write to TIMx CR2 */
;;;339      TIMx->CR2 = tmpcr2;
000078  8083              STRH     r3,[r0,#4]
;;;340      
;;;341      /* Write to TIMx CCMR1 */
;;;342      TIMx->CCMR1 = tmpccmrx;
00007a  8304              STRH     r4,[r0,#0x18]
;;;343    
;;;344      /* Set the Capture Compare Register value */
;;;345      TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse; 
00007c  88cd              LDRH     r5,[r1,#6]
00007e  8685              STRH     r5,[r0,#0x34]
;;;346     
;;;347      /* Write to TIMx CCER */
;;;348      TIMx->CCER = tmpccer;
000080  8402              STRH     r2,[r0,#0x20]
;;;349    }
000082  bd70              POP      {r4-r6,pc}
;;;350    
                          ENDP

                  |L46.132|
                          DCD      0x40012c00
                  |L46.136|
                          DCD      0x40013400
                  |L46.140|
                          DCD      0x40014000
                  |L46.144|
                          DCD      0x40014400
                  |L46.148|
                          DCD      0x40014800

                          AREA ||i.TIM_OC1NPolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1NPolarityConfig PROC
;;;1825     */
;;;1826   void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
000000  460a              MOV      r2,r1
;;;1827   {
;;;1828     uint16_t tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;1829     /* Check the parameters */
;;;1830     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1831     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1832      
;;;1833     tmpccer = TIMx->CCER;
000004  8c01              LDRH     r1,[r0,#0x20]
;;;1834     /* Set or Reset the CC1NP Bit */
;;;1835     tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC1NP);
000006  f64f73f7          MOV      r3,#0xfff7
00000a  4019              ANDS     r1,r1,r3
;;;1836     tmpccer |= TIM_OCNPolarity;
00000c  4311              ORRS     r1,r1,r2
;;;1837     /* Write to TIMx CCER register */
;;;1838     TIMx->CCER = tmpccer;
00000e  8401              STRH     r1,[r0,#0x20]
;;;1839   }
000010  4770              BX       lr
;;;1840   
                          ENDP


                          AREA ||i.TIM_OC1PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1PolarityConfig PROC
;;;1802     */
;;;1803   void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  460a              MOV      r2,r1
;;;1804   {
;;;1805     uint16_t tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;1806     /* Check the parameters */
;;;1807     assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;1808     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1809     tmpccer = TIMx->CCER;
000004  8c01              LDRH     r1,[r0,#0x20]
;;;1810     /* Set or Reset the CC1P Bit */
;;;1811     tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC1P);
000006  f64f73fd          MOV      r3,#0xfffd
00000a  4019              ANDS     r1,r1,r3
;;;1812     tmpccer |= TIM_OCPolarity;
00000c  4311              ORRS     r1,r1,r2
;;;1813     /* Write to TIMx CCER register */
;;;1814     TIMx->CCER = tmpccer;
00000e  8401              STRH     r1,[r0,#0x20]
;;;1815   }
000010  4770              BX       lr
;;;1816   
                          ENDP


                          AREA ||i.TIM_OC1PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1PreloadConfig PROC
;;;1506     */
;;;1507   void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  460a              MOV      r2,r1
;;;1508   {
;;;1509     uint16_t tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1510     /* Check the parameters */
;;;1511     assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;1512     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1513     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1514     /* Reset the OC1PE Bit */
;;;1515     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1PE);
000006  f64f73f7          MOV      r3,#0xfff7
00000a  4019              ANDS     r1,r1,r3
;;;1516     /* Enable or Disable the Output Compare Preload feature */
;;;1517     tmpccmr1 |= TIM_OCPreload;
00000c  4311              ORRS     r1,r1,r2
;;;1518     /* Write to TIMx CCMR1 register */
;;;1519     TIMx->CCMR1 = tmpccmr1;
00000e  8301              STRH     r1,[r0,#0x18]
;;;1520   }
000010  4770              BX       lr
;;;1521   
                          ENDP


                          AREA ||i.TIM_OC2FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2FastConfig PROC
;;;1629     */
;;;1630   void TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  460a              MOV      r2,r1
;;;1631   {
;;;1632     uint16_t tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1633     /* Check the parameters */
;;;1634     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;1635     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1636     /* Get the TIMx CCMR1 register value */
;;;1637     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1638     /* Reset the OC2FE Bit */
;;;1639     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2FE);
000006  f64f33ff          MOV      r3,#0xfbff
00000a  4019              ANDS     r1,r1,r3
;;;1640     /* Enable or Disable the Output Compare Fast Bit */
;;;1641     tmpccmr1 |= (uint16_t)(TIM_OCFast << 8);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032302          AND      r3,r3,r2,LSL #8
000014  4319              ORRS     r1,r1,r3
;;;1642     /* Write to TIMx CCMR1 */
;;;1643     TIMx->CCMR1 = tmpccmr1;
000016  8301              STRH     r1,[r0,#0x18]
;;;1644   }
000018  4770              BX       lr
;;;1645   
                          ENDP


                          AREA ||i.TIM_OC2Init||, CODE, READONLY, ALIGN=2

                  TIM_OC2Init PROC
;;;359      */
;;;360    void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;361    {
;;;362      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
000002  2400              MOVS     r4,#0
000004  2200              MOVS     r2,#0
000006  2300              MOVS     r3,#0
;;;363       
;;;364      /* Check the parameters */
;;;365      assert_param(IS_TIM_LIST6_PERIPH(TIMx)); 
;;;366      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;367      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;368      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;369       /* Disable the Channel 2: Reset the CC2E Bit */
;;;370      TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC2E));
000008  8c05              LDRH     r5,[r0,#0x20]
00000a  f64f76ef          MOV      r6,#0xffef
00000e  4035              ANDS     r5,r5,r6
000010  8405              STRH     r5,[r0,#0x20]
;;;371      
;;;372      /* Get the TIMx CCER register value */  
;;;373      tmpccer = TIMx->CCER;
000012  8c02              LDRH     r2,[r0,#0x20]
;;;374      /* Get the TIMx CR2 register value */
;;;375      tmpcr2 =  TIMx->CR2;
000014  8883              LDRH     r3,[r0,#4]
;;;376      
;;;377      /* Get the TIMx CCMR1 register value */
;;;378      tmpccmrx = TIMx->CCMR1;
000016  8b04              LDRH     r4,[r0,#0x18]
;;;379        
;;;380      /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;381      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_OC2M));
000018  f64875ff          MOV      r5,#0x8fff
00001c  402c              ANDS     r4,r4,r5
;;;382      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_CC2S));
00001e  f64f45ff          MOV      r5,#0xfcff
000022  402c              ANDS     r4,r4,r5
;;;383      
;;;384      /* Select the Output Compare Mode */
;;;385      tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
000024  880d              LDRH     r5,[r1,#0]
000026  f64f76ff          MOV      r6,#0xffff
00002a  ea062505          AND      r5,r6,r5,LSL #8
00002e  432c              ORRS     r4,r4,r5
;;;386      
;;;387      /* Reset the Output Polarity level */
;;;388      tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2P));
000030  f64f75df          MOV      r5,#0xffdf
000034  402a              ANDS     r2,r2,r5
;;;389      /* Set the Output Compare Polarity */
;;;390      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
000036  890d              LDRH     r5,[r1,#8]
000038  ea061505          AND      r5,r6,r5,LSL #4
00003c  432a              ORRS     r2,r2,r5
;;;391      
;;;392      /* Set the Output State */
;;;393      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);
00003e  884d              LDRH     r5,[r1,#2]
000040  ea061505          AND      r5,r6,r5,LSL #4
000044  432a              ORRS     r2,r2,r5
;;;394        
;;;395      if((TIMx == TIM1) || (TIMx == TIM8))
000046  4d15              LDR      r5,|L51.156|
000048  42a8              CMP      r0,r5
00004a  d002              BEQ      |L51.82|
00004c  4d14              LDR      r5,|L51.160|
00004e  42a8              CMP      r0,r5
000050  d11d              BNE      |L51.142|
                  |L51.82|
;;;396      {
;;;397        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;398        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;399        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;400        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;401        
;;;402        /* Reset the Output N Polarity level */
;;;403        tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2NP));
000052  f64f757f          MOV      r5,#0xff7f
000056  402a              ANDS     r2,r2,r5
;;;404        /* Set the Output N Polarity */
;;;405        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
000058  894d              LDRH     r5,[r1,#0xa]
00005a  f64f76ff          MOV      r6,#0xffff
00005e  ea061505          AND      r5,r6,r5,LSL #4
000062  432a              ORRS     r2,r2,r5
;;;406        
;;;407        /* Reset the Output N State */
;;;408        tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2NE));    
000064  f64f75bf          MOV      r5,#0xffbf
000068  402a              ANDS     r2,r2,r5
;;;409        /* Set the Output N State */
;;;410        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 4);
00006a  888d              LDRH     r5,[r1,#4]
00006c  ea061505          AND      r5,r6,r5,LSL #4
000070  432a              ORRS     r2,r2,r5
;;;411        
;;;412        /* Reset the Ouput Compare and Output Compare N IDLE State */
;;;413        tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS2));
000072  f64f35ff          MOV      r5,#0xfbff
000076  402b              ANDS     r3,r3,r5
;;;414        tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS2N));
000078  f24f75ff          MOV      r5,#0xf7ff
00007c  402b              ANDS     r3,r3,r5
;;;415        
;;;416        /* Set the Output Idle state */
;;;417        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 2);
00007e  898d              LDRH     r5,[r1,#0xc]
000080  ea060585          AND      r5,r6,r5,LSL #2
000084  432b              ORRS     r3,r3,r5
;;;418        /* Set the Output N Idle state */
;;;419        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 2);
000086  89cd              LDRH     r5,[r1,#0xe]
000088  ea060585          AND      r5,r6,r5,LSL #2
00008c  432b              ORRS     r3,r3,r5
                  |L51.142|
;;;420      }
;;;421      /* Write to TIMx CR2 */
;;;422      TIMx->CR2 = tmpcr2;
00008e  8083              STRH     r3,[r0,#4]
;;;423      
;;;424      /* Write to TIMx CCMR1 */
;;;425      TIMx->CCMR1 = tmpccmrx;
000090  8304              STRH     r4,[r0,#0x18]
;;;426    
;;;427      /* Set the Capture Compare Register value */
;;;428      TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
000092  88cd              LDRH     r5,[r1,#6]
000094  8705              STRH     r5,[r0,#0x38]
;;;429      
;;;430      /* Write to TIMx CCER */
;;;431      TIMx->CCER = tmpccer;
000096  8402              STRH     r2,[r0,#0x20]
;;;432    }
000098  bd70              POP      {r4-r6,pc}
;;;433    
                          ENDP

00009a  0000              DCW      0x0000
                  |L51.156|
                          DCD      0x40012c00
                  |L51.160|
                          DCD      0x40013400

                          AREA ||i.TIM_OC2NPolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2NPolarityConfig PROC
;;;1872     */
;;;1873   void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
000000  460a              MOV      r2,r1
;;;1874   {
;;;1875     uint16_t tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;1876     /* Check the parameters */
;;;1877     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1878     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1879     
;;;1880     tmpccer = TIMx->CCER;
000004  8c01              LDRH     r1,[r0,#0x20]
;;;1881     /* Set or Reset the CC2NP Bit */
;;;1882     tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC2NP);
000006  f64f737f          MOV      r3,#0xff7f
00000a  4019              ANDS     r1,r1,r3
;;;1883     tmpccer |= (uint16_t)(TIM_OCNPolarity << 4);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea031302          AND      r3,r3,r2,LSL #4
000014  4319              ORRS     r1,r1,r3
;;;1884     /* Write to TIMx CCER register */
;;;1885     TIMx->CCER = tmpccer;
000016  8401              STRH     r1,[r0,#0x20]
;;;1886   }
000018  4770              BX       lr
;;;1887   
                          ENDP


                          AREA ||i.TIM_OC2PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2PolarityConfig PROC
;;;1849     */
;;;1850   void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  460a              MOV      r2,r1
;;;1851   {
;;;1852     uint16_t tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;1853     /* Check the parameters */
;;;1854     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;1855     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1856     tmpccer = TIMx->CCER;
000004  8c01              LDRH     r1,[r0,#0x20]
;;;1857     /* Set or Reset the CC2P Bit */
;;;1858     tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC2P);
000006  f64f73df          MOV      r3,#0xffdf
00000a  4019              ANDS     r1,r1,r3
;;;1859     tmpccer |= (uint16_t)(TIM_OCPolarity << 4);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea031302          AND      r3,r3,r2,LSL #4
000014  4319              ORRS     r1,r1,r3
;;;1860     /* Write to TIMx CCER register */
;;;1861     TIMx->CCER = tmpccer;
000016  8401              STRH     r1,[r0,#0x20]
;;;1862   }
000018  4770              BX       lr
;;;1863   
                          ENDP


                          AREA ||i.TIM_OC2PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2PreloadConfig PROC
;;;1531     */
;;;1532   void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  460a              MOV      r2,r1
;;;1533   {
;;;1534     uint16_t tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1535     /* Check the parameters */
;;;1536     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;1537     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1538     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1539     /* Reset the OC2PE Bit */
;;;1540     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2PE);
000006  f24f73ff          MOV      r3,#0xf7ff
00000a  4019              ANDS     r1,r1,r3
;;;1541     /* Enable or Disable the Output Compare Preload feature */
;;;1542     tmpccmr1 |= (uint16_t)(TIM_OCPreload << 8);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032302          AND      r3,r3,r2,LSL #8
000014  4319              ORRS     r1,r1,r3
;;;1543     /* Write to TIMx CCMR1 register */
;;;1544     TIMx->CCMR1 = tmpccmr1;
000016  8301              STRH     r1,[r0,#0x18]
;;;1545   }
000018  4770              BX       lr
;;;1546   
                          ENDP


                          AREA ||i.TIM_OC3FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3FastConfig PROC
;;;1654     */
;;;1655   void TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  460a              MOV      r2,r1
;;;1656   {
;;;1657     uint16_t tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1658     /* Check the parameters */
;;;1659     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1660     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1661     /* Get the TIMx CCMR2 register value */
;;;1662     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1663     /* Reset the OC3FE Bit */
;;;1664     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3FE);
000006  f64f73fb          MOV      r3,#0xfffb
00000a  4019              ANDS     r1,r1,r3
;;;1665     /* Enable or Disable the Output Compare Fast Bit */
;;;1666     tmpccmr2 |= TIM_OCFast;
00000c  4311              ORRS     r1,r1,r2
;;;1667     /* Write to TIMx CCMR2 */
;;;1668     TIMx->CCMR2 = tmpccmr2;
00000e  8381              STRH     r1,[r0,#0x1c]
;;;1669   }
000010  4770              BX       lr
;;;1670   
                          ENDP


                          AREA ||i.TIM_OC3Init||, CODE, READONLY, ALIGN=2

                  TIM_OC3Init PROC
;;;441      */
;;;442    void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;443    {
;;;444      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
000002  2400              MOVS     r4,#0
000004  2200              MOVS     r2,#0
000006  2300              MOVS     r3,#0
;;;445       
;;;446      /* Check the parameters */
;;;447      assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
;;;448      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;449      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;450      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;451      /* Disable the Channel 2: Reset the CC2E Bit */
;;;452      TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC3E));
000008  8c05              LDRH     r5,[r0,#0x20]
00000a  f64f66ff          MOV      r6,#0xfeff
00000e  4035              ANDS     r5,r5,r6
000010  8405              STRH     r5,[r0,#0x20]
;;;453      
;;;454      /* Get the TIMx CCER register value */
;;;455      tmpccer = TIMx->CCER;
000012  8c02              LDRH     r2,[r0,#0x20]
;;;456      /* Get the TIMx CR2 register value */
;;;457      tmpcr2 =  TIMx->CR2;
000014  8883              LDRH     r3,[r0,#4]
;;;458      
;;;459      /* Get the TIMx CCMR2 register value */
;;;460      tmpccmrx = TIMx->CCMR2;
000016  8b84              LDRH     r4,[r0,#0x1c]
;;;461        
;;;462      /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;463      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_OC3M));
000018  f64f758f          MOV      r5,#0xff8f
00001c  402c              ANDS     r4,r4,r5
;;;464      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_CC3S));  
00001e  f64f75fc          MOV      r5,#0xfffc
000022  402c              ANDS     r4,r4,r5
;;;465      /* Select the Output Compare Mode */
;;;466      tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
000024  880d              LDRH     r5,[r1,#0]
000026  432c              ORRS     r4,r4,r5
;;;467      
;;;468      /* Reset the Output Polarity level */
;;;469      tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3P));
000028  f64f55ff          MOV      r5,#0xfdff
00002c  402a              ANDS     r2,r2,r5
;;;470      /* Set the Output Compare Polarity */
;;;471      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
00002e  890d              LDRH     r5,[r1,#8]
000030  f64f76ff          MOV      r6,#0xffff
000034  ea062505          AND      r5,r6,r5,LSL #8
000038  432a              ORRS     r2,r2,r5
;;;472      
;;;473      /* Set the Output State */
;;;474      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 8);
00003a  884d              LDRH     r5,[r1,#2]
00003c  ea062505          AND      r5,r6,r5,LSL #8
000040  432a              ORRS     r2,r2,r5
;;;475        
;;;476      if((TIMx == TIM1) || (TIMx == TIM8))
000042  4d15              LDR      r5,|L56.152|
000044  42a8              CMP      r0,r5
000046  d002              BEQ      |L56.78|
000048  4d14              LDR      r5,|L56.156|
00004a  42a8              CMP      r0,r5
00004c  d11d              BNE      |L56.138|
                  |L56.78|
;;;477      {
;;;478        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;479        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;480        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;481        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;482        
;;;483        /* Reset the Output N Polarity level */
;;;484        tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3NP));
00004e  f24f75ff          MOV      r5,#0xf7ff
000052  402a              ANDS     r2,r2,r5
;;;485        /* Set the Output N Polarity */
;;;486        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
000054  894d              LDRH     r5,[r1,#0xa]
000056  f64f76ff          MOV      r6,#0xffff
00005a  ea062505          AND      r5,r6,r5,LSL #8
00005e  432a              ORRS     r2,r2,r5
;;;487        /* Reset the Output N State */
;;;488        tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3NE));
000060  f64f35ff          MOV      r5,#0xfbff
000064  402a              ANDS     r2,r2,r5
;;;489        
;;;490        /* Set the Output N State */
;;;491        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 8);
000066  888d              LDRH     r5,[r1,#4]
000068  ea062505          AND      r5,r6,r5,LSL #8
00006c  432a              ORRS     r2,r2,r5
;;;492        /* Reset the Ouput Compare and Output Compare N IDLE State */
;;;493        tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS3));
00006e  f64e75ff          MOV      r5,#0xefff
000072  402b              ANDS     r3,r3,r5
;;;494        tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS3N));
000074  f64d75ff          MOV      r5,#0xdfff
000078  402b              ANDS     r3,r3,r5
;;;495        /* Set the Output Idle state */
;;;496        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 4);
00007a  898d              LDRH     r5,[r1,#0xc]
00007c  ea061505          AND      r5,r6,r5,LSL #4
000080  432b              ORRS     r3,r3,r5
;;;497        /* Set the Output N Idle state */
;;;498        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 4);
000082  89cd              LDRH     r5,[r1,#0xe]
000084  ea061505          AND      r5,r6,r5,LSL #4
000088  432b              ORRS     r3,r3,r5
                  |L56.138|
;;;499      }
;;;500      /* Write to TIMx CR2 */
;;;501      TIMx->CR2 = tmpcr2;
00008a  8083              STRH     r3,[r0,#4]
;;;502      
;;;503      /* Write to TIMx CCMR2 */
;;;504      TIMx->CCMR2 = tmpccmrx;
00008c  8384              STRH     r4,[r0,#0x1c]
;;;505    
;;;506      /* Set the Capture Compare Register value */
;;;507      TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
00008e  88cd              LDRH     r5,[r1,#6]
000090  8785              STRH     r5,[r0,#0x3c]
;;;508      
;;;509      /* Write to TIMx CCER */
;;;510      TIMx->CCER = tmpccer;
000092  8402              STRH     r2,[r0,#0x20]
;;;511    }
000094  bd70              POP      {r4-r6,pc}
;;;512    
                          ENDP

000096  0000              DCW      0x0000
                  |L56.152|
                          DCD      0x40012c00
                  |L56.156|
                          DCD      0x40013400

                          AREA ||i.TIM_OC3NPolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3NPolarityConfig PROC
;;;1919     */
;;;1920   void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
000000  460a              MOV      r2,r1
;;;1921   {
;;;1922     uint16_t tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;1923    
;;;1924     /* Check the parameters */
;;;1925     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1926     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1927       
;;;1928     tmpccer = TIMx->CCER;
000004  8c01              LDRH     r1,[r0,#0x20]
;;;1929     /* Set or Reset the CC3NP Bit */
;;;1930     tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC3NP);
000006  f24f73ff          MOV      r3,#0xf7ff
00000a  4019              ANDS     r1,r1,r3
;;;1931     tmpccer |= (uint16_t)(TIM_OCNPolarity << 8);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032302          AND      r3,r3,r2,LSL #8
000014  4319              ORRS     r1,r1,r3
;;;1932     /* Write to TIMx CCER register */
;;;1933     TIMx->CCER = tmpccer;
000016  8401              STRH     r1,[r0,#0x20]
;;;1934   }
000018  4770              BX       lr
;;;1935   
                          ENDP


                          AREA ||i.TIM_OC3PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3PolarityConfig PROC
;;;1896     */
;;;1897   void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  460a              MOV      r2,r1
;;;1898   {
;;;1899     uint16_t tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;1900     /* Check the parameters */
;;;1901     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1902     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1903     tmpccer = TIMx->CCER;
000004  8c01              LDRH     r1,[r0,#0x20]
;;;1904     /* Set or Reset the CC3P Bit */
;;;1905     tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC3P);
000006  f64f53ff          MOV      r3,#0xfdff
00000a  4019              ANDS     r1,r1,r3
;;;1906     tmpccer |= (uint16_t)(TIM_OCPolarity << 8);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032302          AND      r3,r3,r2,LSL #8
000014  4319              ORRS     r1,r1,r3
;;;1907     /* Write to TIMx CCER register */
;;;1908     TIMx->CCER = tmpccer;
000016  8401              STRH     r1,[r0,#0x20]
;;;1909   }
000018  4770              BX       lr
;;;1910   
                          ENDP


                          AREA ||i.TIM_OC3PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3PreloadConfig PROC
;;;1555     */
;;;1556   void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  460a              MOV      r2,r1
;;;1557   {
;;;1558     uint16_t tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1559     /* Check the parameters */
;;;1560     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1561     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1562     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1563     /* Reset the OC3PE Bit */
;;;1564     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3PE);
000006  f64f73f7          MOV      r3,#0xfff7
00000a  4019              ANDS     r1,r1,r3
;;;1565     /* Enable or Disable the Output Compare Preload feature */
;;;1566     tmpccmr2 |= TIM_OCPreload;
00000c  4311              ORRS     r1,r1,r2
;;;1567     /* Write to TIMx CCMR2 register */
;;;1568     TIMx->CCMR2 = tmpccmr2;
00000e  8381              STRH     r1,[r0,#0x1c]
;;;1569   }
000010  4770              BX       lr
;;;1570   
                          ENDP


                          AREA ||i.TIM_OC4FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC4FastConfig PROC
;;;1679     */
;;;1680   void TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  460a              MOV      r2,r1
;;;1681   {
;;;1682     uint16_t tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1683     /* Check the parameters */
;;;1684     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1685     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1686     /* Get the TIMx CCMR2 register value */
;;;1687     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1688     /* Reset the OC4FE Bit */
;;;1689     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4FE);
000006  f64f33ff          MOV      r3,#0xfbff
00000a  4019              ANDS     r1,r1,r3
;;;1690     /* Enable or Disable the Output Compare Fast Bit */
;;;1691     tmpccmr2 |= (uint16_t)(TIM_OCFast << 8);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032302          AND      r3,r3,r2,LSL #8
000014  4319              ORRS     r1,r1,r3
;;;1692     /* Write to TIMx CCMR2 */
;;;1693     TIMx->CCMR2 = tmpccmr2;
000016  8381              STRH     r1,[r0,#0x1c]
;;;1694   }
000018  4770              BX       lr
;;;1695   
                          ENDP


                          AREA ||i.TIM_OC4Init||, CODE, READONLY, ALIGN=2

                  TIM_OC4Init PROC
;;;520      */
;;;521    void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;522    {
;;;523      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
000002  2200              MOVS     r2,#0
000004  2300              MOVS     r3,#0
000006  2400              MOVS     r4,#0
;;;524       
;;;525      /* Check the parameters */
;;;526      assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
;;;527      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;528      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;529      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;530      /* Disable the Channel 2: Reset the CC4E Bit */
;;;531      TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC4E));
000008  8c05              LDRH     r5,[r0,#0x20]
00000a  f64e76ff          MOV      r6,#0xefff
00000e  4035              ANDS     r5,r5,r6
000010  8405              STRH     r5,[r0,#0x20]
;;;532      
;;;533      /* Get the TIMx CCER register value */
;;;534      tmpccer = TIMx->CCER;
000012  8c03              LDRH     r3,[r0,#0x20]
;;;535      /* Get the TIMx CR2 register value */
;;;536      tmpcr2 =  TIMx->CR2;
000014  8884              LDRH     r4,[r0,#4]
;;;537      
;;;538      /* Get the TIMx CCMR2 register value */
;;;539      tmpccmrx = TIMx->CCMR2;
000016  8b82              LDRH     r2,[r0,#0x1c]
;;;540        
;;;541      /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;542      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_OC4M));
000018  f64875ff          MOV      r5,#0x8fff
00001c  402a              ANDS     r2,r2,r5
;;;543      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_CC4S));
00001e  f64f45ff          MOV      r5,#0xfcff
000022  402a              ANDS     r2,r2,r5
;;;544      
;;;545      /* Select the Output Compare Mode */
;;;546      tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
000024  880d              LDRH     r5,[r1,#0]
000026  f64f76ff          MOV      r6,#0xffff
00002a  ea062505          AND      r5,r6,r5,LSL #8
00002e  432a              ORRS     r2,r2,r5
;;;547      
;;;548      /* Reset the Output Polarity level */
;;;549      tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC4P));
000030  f64d75ff          MOV      r5,#0xdfff
000034  402b              ANDS     r3,r3,r5
;;;550      /* Set the Output Compare Polarity */
;;;551      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
000036  890d              LDRH     r5,[r1,#8]
000038  ea063505          AND      r5,r6,r5,LSL #12
00003c  432b              ORRS     r3,r3,r5
;;;552      
;;;553      /* Set the Output State */
;;;554      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);
00003e  884d              LDRH     r5,[r1,#2]
000040  ea063505          AND      r5,r6,r5,LSL #12
000044  432b              ORRS     r3,r3,r5
;;;555        
;;;556      if((TIMx == TIM1) || (TIMx == TIM8))
000046  4d0b              LDR      r5,|L61.116|
000048  42a8              CMP      r0,r5
00004a  d002              BEQ      |L61.82|
00004c  4d0a              LDR      r5,|L61.120|
00004e  42a8              CMP      r0,r5
000050  d108              BNE      |L61.100|
                  |L61.82|
;;;557      {
;;;558        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;559        /* Reset the Ouput Compare IDLE State */
;;;560        tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS4));
000052  f64b75ff          MOV      r5,#0xbfff
000056  402c              ANDS     r4,r4,r5
;;;561        /* Set the Output Idle state */
;;;562        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 6);
000058  898d              LDRH     r5,[r1,#0xc]
00005a  f64f76ff          MOV      r6,#0xffff
00005e  ea061585          AND      r5,r6,r5,LSL #6
000062  432c              ORRS     r4,r4,r5
                  |L61.100|
;;;563      }
;;;564      /* Write to TIMx CR2 */
;;;565      TIMx->CR2 = tmpcr2;
000064  8084              STRH     r4,[r0,#4]
;;;566      
;;;567      /* Write to TIMx CCMR2 */  
;;;568      TIMx->CCMR2 = tmpccmrx;
000066  8382              STRH     r2,[r0,#0x1c]
;;;569    
;;;570      /* Set the Capture Compare Register value */
;;;571      TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
000068  88cd              LDRH     r5,[r1,#6]
00006a  f8a05040          STRH     r5,[r0,#0x40]
;;;572      
;;;573      /* Write to TIMx CCER */
;;;574      TIMx->CCER = tmpccer;
00006e  8403              STRH     r3,[r0,#0x20]
;;;575    }
000070  bd70              POP      {r4-r6,pc}
;;;576    
                          ENDP

000072  0000              DCW      0x0000
                  |L61.116|
                          DCD      0x40012c00
                  |L61.120|
                          DCD      0x40013400

                          AREA ||i.TIM_OC4PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC4PolarityConfig PROC
;;;1944     */
;;;1945   void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  460a              MOV      r2,r1
;;;1946   {
;;;1947     uint16_t tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;1948     /* Check the parameters */
;;;1949     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1950     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1951     tmpccer = TIMx->CCER;
000004  8c01              LDRH     r1,[r0,#0x20]
;;;1952     /* Set or Reset the CC4P Bit */
;;;1953     tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC4P);
000006  f64d73ff          MOV      r3,#0xdfff
00000a  4019              ANDS     r1,r1,r3
;;;1954     tmpccer |= (uint16_t)(TIM_OCPolarity << 12);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea033302          AND      r3,r3,r2,LSL #12
000014  4319              ORRS     r1,r1,r3
;;;1955     /* Write to TIMx CCER register */
;;;1956     TIMx->CCER = tmpccer;
000016  8401              STRH     r1,[r0,#0x20]
;;;1957   }
000018  4770              BX       lr
;;;1958   
                          ENDP


                          AREA ||i.TIM_OC4PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC4PreloadConfig PROC
;;;1579     */
;;;1580   void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  460a              MOV      r2,r1
;;;1581   {
;;;1582     uint16_t tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1583     /* Check the parameters */
;;;1584     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1585     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1586     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1587     /* Reset the OC4PE Bit */
;;;1588     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4PE);
000006  f24f73ff          MOV      r3,#0xf7ff
00000a  4019              ANDS     r1,r1,r3
;;;1589     /* Enable or Disable the Output Compare Preload feature */
;;;1590     tmpccmr2 |= (uint16_t)(TIM_OCPreload << 8);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032302          AND      r3,r3,r2,LSL #8
000014  4319              ORRS     r1,r1,r3
;;;1591     /* Write to TIMx CCMR2 register */
;;;1592     TIMx->CCMR2 = tmpccmr2;
000016  8381              STRH     r1,[r0,#0x1c]
;;;1593   }
000018  4770              BX       lr
;;;1594   
                          ENDP


                          AREA ||i.TIM_OCStructInit||, CODE, READONLY, ALIGN=1

                  TIM_OCStructInit PROC
;;;749      */
;;;750    void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  2100              MOVS     r1,#0
;;;751    {
;;;752      /* Set the default configuration */
;;;753      TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
000002  8001              STRH     r1,[r0,#0]
;;;754      TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;
000004  8041              STRH     r1,[r0,#2]
;;;755      TIM_OCInitStruct->TIM_OutputNState = TIM_OutputNState_Disable;
000006  8081              STRH     r1,[r0,#4]
;;;756      TIM_OCInitStruct->TIM_Pulse = 0x0000;
000008  80c1              STRH     r1,[r0,#6]
;;;757      TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
00000a  8101              STRH     r1,[r0,#8]
;;;758      TIM_OCInitStruct->TIM_OCNPolarity = TIM_OCPolarity_High;
00000c  8141              STRH     r1,[r0,#0xa]
;;;759      TIM_OCInitStruct->TIM_OCIdleState = TIM_OCIdleState_Reset;
00000e  8181              STRH     r1,[r0,#0xc]
;;;760      TIM_OCInitStruct->TIM_OCNIdleState = TIM_OCNIdleState_Reset;
000010  81c1              STRH     r1,[r0,#0xe]
;;;761    }
000012  4770              BX       lr
;;;762    
                          ENDP


                          AREA ||i.TIM_PWMIConfig||, CODE, READONLY, ALIGN=1

                  TIM_PWMIConfig PROC
;;;651      */
;;;652    void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;653    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;654      uint16_t icoppositepolarity = TIM_ICPolarity_Rising;
000008  2600              MOVS     r6,#0
;;;655      uint16_t icoppositeselection = TIM_ICSelection_DirectTI;
00000a  2701              MOVS     r7,#1
;;;656      /* Check the parameters */
;;;657      assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;658      /* Select the Opposite Input Polarity */
;;;659      if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
00000c  8860              LDRH     r0,[r4,#2]
00000e  b908              CBNZ     r0,|L65.20|
;;;660      {
;;;661        icoppositepolarity = TIM_ICPolarity_Falling;
000010  2602              MOVS     r6,#2
000012  e000              B        |L65.22|
                  |L65.20|
;;;662      }
;;;663      else
;;;664      {
;;;665        icoppositepolarity = TIM_ICPolarity_Rising;
000014  2600              MOVS     r6,#0
                  |L65.22|
;;;666      }
;;;667      /* Select the Opposite Input */
;;;668      if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
000016  88a0              LDRH     r0,[r4,#4]
000018  2801              CMP      r0,#1
00001a  d101              BNE      |L65.32|
;;;669      {
;;;670        icoppositeselection = TIM_ICSelection_IndirectTI;
00001c  2702              MOVS     r7,#2
00001e  e000              B        |L65.34|
                  |L65.32|
;;;671      }
;;;672      else
;;;673      {
;;;674        icoppositeselection = TIM_ICSelection_DirectTI;
000020  2701              MOVS     r7,#1
                  |L65.34|
;;;675      }
;;;676      if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
000022  8820              LDRH     r0,[r4,#0]
000024  b9a0              CBNZ     r0,|L65.80|
;;;677      {
;;;678        /* TI1 Configuration */
;;;679        TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
000026  8923              LDRH     r3,[r4,#8]
000028  88a2              LDRH     r2,[r4,#4]
00002a  8861              LDRH     r1,[r4,#2]
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       TI1_Config
;;;680                   TIM_ICInitStruct->TIM_ICFilter);
;;;681        /* Set the Input Capture Prescaler value */
;;;682        TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000032  88e1              LDRH     r1,[r4,#6]
000034  4628              MOV      r0,r5
000036  f7fffffe          BL       TIM_SetIC1Prescaler
;;;683        /* TI2 Configuration */
;;;684        TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
00003a  8923              LDRH     r3,[r4,#8]
00003c  463a              MOV      r2,r7
00003e  4631              MOV      r1,r6
000040  4628              MOV      r0,r5
000042  f7fffffe          BL       TI2_Config
;;;685        /* Set the Input Capture Prescaler value */
;;;686        TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000046  88e1              LDRH     r1,[r4,#6]
000048  4628              MOV      r0,r5
00004a  f7fffffe          BL       TIM_SetIC2Prescaler
00004e  e013              B        |L65.120|
                  |L65.80|
;;;687      }
;;;688      else
;;;689      { 
;;;690        /* TI2 Configuration */
;;;691        TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
000050  8923              LDRH     r3,[r4,#8]
000052  88a2              LDRH     r2,[r4,#4]
000054  8861              LDRH     r1,[r4,#2]
000056  4628              MOV      r0,r5
000058  f7fffffe          BL       TI2_Config
;;;692                   TIM_ICInitStruct->TIM_ICFilter);
;;;693        /* Set the Input Capture Prescaler value */
;;;694        TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
00005c  88e1              LDRH     r1,[r4,#6]
00005e  4628              MOV      r0,r5
000060  f7fffffe          BL       TIM_SetIC2Prescaler
;;;695        /* TI1 Configuration */
;;;696        TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
000064  8923              LDRH     r3,[r4,#8]
000066  463a              MOV      r2,r7
000068  4631              MOV      r1,r6
00006a  4628              MOV      r0,r5
00006c  f7fffffe          BL       TI1_Config
;;;697        /* Set the Input Capture Prescaler value */
;;;698        TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000070  88e1              LDRH     r1,[r4,#6]
000072  4628              MOV      r0,r5
000074  f7fffffe          BL       TIM_SetIC1Prescaler
                  |L65.120|
;;;699      }
;;;700    }
000078  e8bd81f0          POP      {r4-r8,pc}
;;;701    
                          ENDP


                          AREA ||i.TIM_PrescalerConfig||, CODE, READONLY, ALIGN=1

                  TIM_PrescalerConfig PROC
;;;1173     */
;;;1174   void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode)
000000  8501              STRH     r1,[r0,#0x28]
;;;1175   {
;;;1176     /* Check the parameters */
;;;1177     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;1178     assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
;;;1179     /* Set the Prescaler value */
;;;1180     TIMx->PSC = Prescaler;
;;;1181     /* Set or reset the UG Bit */
;;;1182     TIMx->EGR = TIM_PSCReloadMode;
000002  8282              STRH     r2,[r0,#0x14]
;;;1183   }
000004  4770              BX       lr
;;;1184   
                          ENDP


                          AREA ||i.TIM_SelectCCDMA||, CODE, READONLY, ALIGN=1

                  TIM_SelectCCDMA PROC
;;;1455     */
;;;1456   void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L67.12|
;;;1457   {
;;;1458     /* Check the parameters */
;;;1459     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1460     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1461     if (NewState != DISABLE)
;;;1462     {
;;;1463       /* Set the CCDS Bit */
;;;1464       TIMx->CR2 |= TIM_CR2_CCDS;
000002  8882              LDRH     r2,[r0,#4]
000004  f0420208          ORR      r2,r2,#8
000008  8082              STRH     r2,[r0,#4]
00000a  e004              B        |L67.22|
                  |L67.12|
;;;1465     }
;;;1466     else
;;;1467     {
;;;1468       /* Reset the CCDS Bit */
;;;1469       TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_CCDS);
00000c  8882              LDRH     r2,[r0,#4]
00000e  f64f73f7          MOV      r3,#0xfff7
000012  401a              ANDS     r2,r2,r3
000014  8082              STRH     r2,[r0,#4]
                  |L67.22|
;;;1470     }
;;;1471   }
000016  4770              BX       lr
;;;1472   
                          ENDP


                          AREA ||i.TIM_SelectCOM||, CODE, READONLY, ALIGN=1

                  TIM_SelectCOM PROC
;;;1430     */
;;;1431   void TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L68.12|
;;;1432   {
;;;1433     /* Check the parameters */
;;;1434     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1435     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1436     if (NewState != DISABLE)
;;;1437     {
;;;1438       /* Set the COM Bit */
;;;1439       TIMx->CR2 |= TIM_CR2_CCUS;
000002  8882              LDRH     r2,[r0,#4]
000004  f0420204          ORR      r2,r2,#4
000008  8082              STRH     r2,[r0,#4]
00000a  e004              B        |L68.22|
                  |L68.12|
;;;1440     }
;;;1441     else
;;;1442     {
;;;1443       /* Reset the COM Bit */
;;;1444       TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_CCUS);
00000c  8882              LDRH     r2,[r0,#4]
00000e  f64f73fb          MOV      r3,#0xfffb
000012  401a              ANDS     r2,r2,r3
000014  8082              STRH     r2,[r0,#4]
                  |L68.22|
;;;1445     }
;;;1446   }
000016  4770              BX       lr
;;;1447   
                          ENDP


                          AREA ||i.TIM_SelectHallSensor||, CODE, READONLY, ALIGN=1

                  TIM_SelectHallSensor PROC
;;;2141     */
;;;2142   void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L69.12|
;;;2143   {
;;;2144     /* Check the parameters */
;;;2145     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;2146     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2147     if (NewState != DISABLE)
;;;2148     {
;;;2149       /* Set the TI1S Bit */
;;;2150       TIMx->CR2 |= TIM_CR2_TI1S;
000002  8882              LDRH     r2,[r0,#4]
000004  f0420280          ORR      r2,r2,#0x80
000008  8082              STRH     r2,[r0,#4]
00000a  e004              B        |L69.22|
                  |L69.12|
;;;2151     }
;;;2152     else
;;;2153     {
;;;2154       /* Reset the TI1S Bit */
;;;2155       TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_TI1S);
00000c  8882              LDRH     r2,[r0,#4]
00000e  f64f737f          MOV      r3,#0xff7f
000012  401a              ANDS     r2,r2,r3
000014  8082              STRH     r2,[r0,#4]
                  |L69.22|
;;;2156     }
;;;2157   }
000016  4770              BX       lr
;;;2158   
                          ENDP


                          AREA ||i.TIM_SelectInputTrigger||, CODE, READONLY, ALIGN=1

                  TIM_SelectInputTrigger PROC
;;;1226     */
;;;1227   void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
000000  460a              MOV      r2,r1
;;;1228   {
;;;1229     uint16_t tmpsmcr = 0;
000002  2100              MOVS     r1,#0
;;;1230     /* Check the parameters */
;;;1231     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;1232     assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));
;;;1233     /* Get the TIMx SMCR register value */
;;;1234     tmpsmcr = TIMx->SMCR;
000004  8901              LDRH     r1,[r0,#8]
;;;1235     /* Reset the TS Bits */
;;;1236     tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_TS));
000006  f64f738f          MOV      r3,#0xff8f
00000a  4019              ANDS     r1,r1,r3
;;;1237     /* Set the Input Trigger source */
;;;1238     tmpsmcr |= TIM_InputTriggerSource;
00000c  4311              ORRS     r1,r1,r2
;;;1239     /* Write to TIMx SMCR */
;;;1240     TIMx->SMCR = tmpsmcr;
00000e  8101              STRH     r1,[r0,#8]
;;;1241   }
000010  4770              BX       lr
;;;1242   
                          ENDP


                          AREA ||i.TIM_SelectMasterSlaveMode||, CODE, READONLY, ALIGN=1

                  TIM_SelectMasterSlaveMode PROC
;;;2243     */
;;;2244   void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode)
000000  8902              LDRH     r2,[r0,#8]
;;;2245   {
;;;2246     /* Check the parameters */
;;;2247     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;2248     assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));
;;;2249     /* Reset the MSM Bit */
;;;2250     TIMx->SMCR &= (uint16_t)~((uint16_t)TIM_SMCR_MSM);
000002  f64f737f          MOV      r3,#0xff7f
000006  401a              ANDS     r2,r2,r3
000008  8102              STRH     r2,[r0,#8]
;;;2251     
;;;2252     /* Set or Reset the MSM Bit */
;;;2253     TIMx->SMCR |= TIM_MasterSlaveMode;
00000a  8902              LDRH     r2,[r0,#8]
00000c  430a              ORRS     r2,r2,r1
00000e  8102              STRH     r2,[r0,#8]
;;;2254   }
000010  4770              BX       lr
;;;2255   
                          ENDP


                          AREA ||i.TIM_SelectOCxM||, CODE, READONLY, ALIGN=1

                  TIM_SelectOCxM PROC
;;;2042     */
;;;2043   void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode)
000000  b570              PUSH     {r4-r6,lr}
;;;2044   {
000002  4603              MOV      r3,r0
;;;2045     uint32_t tmp = 0;
000004  2000              MOVS     r0,#0
;;;2046     uint16_t tmp1 = 0;
000006  2400              MOVS     r4,#0
;;;2047   
;;;2048     /* Check the parameters */
;;;2049     assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;2050     assert_param(IS_TIM_CHANNEL(TIM_Channel));
;;;2051     assert_param(IS_TIM_OCM(TIM_OCMode));
;;;2052   
;;;2053     tmp = (uint32_t) TIMx;
000008  4618              MOV      r0,r3
;;;2054     tmp += CCMR_Offset;
00000a  3018              ADDS     r0,r0,#0x18
;;;2055   
;;;2056     tmp1 = CCER_CCE_Set << (uint16_t)TIM_Channel;
00000c  2501              MOVS     r5,#1
00000e  408d              LSLS     r5,r5,r1
000010  b2ac              UXTH     r4,r5
;;;2057   
;;;2058     /* Disable the Channel: Reset the CCxE Bit */
;;;2059     TIMx->CCER &= (uint16_t) ~tmp1;
000012  8c1d              LDRH     r5,[r3,#0x20]
000014  43a5              BICS     r5,r5,r4
000016  841d              STRH     r5,[r3,#0x20]
;;;2060   
;;;2061     if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
000018  b109              CBZ      r1,|L72.30|
00001a  2908              CMP      r1,#8
00001c  d109              BNE      |L72.50|
                  |L72.30|
;;;2062     {
;;;2063       tmp += (TIM_Channel>>1);
00001e  eb000061          ADD      r0,r0,r1,ASR #1
;;;2064   
;;;2065       /* Reset the OCxM bits in the CCMRx register */
;;;2066       *(__IO uint32_t *) tmp &= (uint32_t)~((uint32_t)TIM_CCMR1_OC1M);
000022  6805              LDR      r5,[r0,#0]
000024  f0250570          BIC      r5,r5,#0x70
000028  6005              STR      r5,[r0,#0]
;;;2067      
;;;2068       /* Configure the OCxM bits in the CCMRx register */
;;;2069       *(__IO uint32_t *) tmp |= TIM_OCMode;
00002a  6805              LDR      r5,[r0,#0]
00002c  4315              ORRS     r5,r5,r2
00002e  6005              STR      r5,[r0,#0]
000030  e00e              B        |L72.80|
                  |L72.50|
;;;2070     }
;;;2071     else
;;;2072     {
;;;2073       tmp += (uint16_t)(TIM_Channel - (uint16_t)4)>> (uint16_t)1;
000032  1f0d              SUBS     r5,r1,#4
000034  f3c5054e          UBFX     r5,r5,#1,#15
000038  4428              ADD      r0,r0,r5
;;;2074   
;;;2075       /* Reset the OCxM bits in the CCMRx register */
;;;2076       *(__IO uint32_t *) tmp &= (uint32_t)~((uint32_t)TIM_CCMR1_OC2M);
00003a  6805              LDR      r5,[r0,#0]
00003c  f42545e0          BIC      r5,r5,#0x7000
000040  6005              STR      r5,[r0,#0]
;;;2077       
;;;2078       /* Configure the OCxM bits in the CCMRx register */
;;;2079       *(__IO uint32_t *) tmp |= (uint16_t)(TIM_OCMode << 8);
000042  6805              LDR      r5,[r0,#0]
000044  f64f76ff          MOV      r6,#0xffff
000048  ea062602          AND      r6,r6,r2,LSL #8
00004c  4335              ORRS     r5,r5,r6
00004e  6005              STR      r5,[r0,#0]
                  |L72.80|
;;;2080     }
;;;2081   }
000050  bd70              POP      {r4-r6,pc}
;;;2082   
                          ENDP


                          AREA ||i.TIM_SelectOnePulseMode||, CODE, READONLY, ALIGN=1

                  TIM_SelectOnePulseMode PROC
;;;2167     */
;;;2168   void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, uint16_t TIM_OPMode)
000000  8802              LDRH     r2,[r0,#0]
;;;2169   {
;;;2170     /* Check the parameters */
;;;2171     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2172     assert_param(IS_TIM_OPM_MODE(TIM_OPMode));
;;;2173     /* Reset the OPM Bit */
;;;2174     TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_OPM);
000002  f64f73f7          MOV      r3,#0xfff7
000006  401a              ANDS     r2,r2,r3
000008  8002              STRH     r2,[r0,#0]
;;;2175     /* Configure the OPM Mode */
;;;2176     TIMx->CR1 |= TIM_OPMode;
00000a  8802              LDRH     r2,[r0,#0]
00000c  430a              ORRS     r2,r2,r1
00000e  8002              STRH     r2,[r0,#0]
;;;2177   }
000010  4770              BX       lr
;;;2178   
                          ENDP


                          AREA ||i.TIM_SelectOutputTrigger||, CODE, READONLY, ALIGN=1

                  TIM_SelectOutputTrigger PROC
;;;2199     */
;;;2200   void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource)
000000  8882              LDRH     r2,[r0,#4]
;;;2201   {
;;;2202     /* Check the parameters */
;;;2203     assert_param(IS_TIM_LIST7_PERIPH(TIMx));
;;;2204     assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));
;;;2205     /* Reset the MMS Bits */
;;;2206     TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_MMS);
000002  f64f738f          MOV      r3,#0xff8f
000006  401a              ANDS     r2,r2,r3
000008  8082              STRH     r2,[r0,#4]
;;;2207     /* Select the TRGO source */
;;;2208     TIMx->CR2 |=  TIM_TRGOSource;
00000a  8882              LDRH     r2,[r0,#4]
00000c  430a              ORRS     r2,r2,r1
00000e  8082              STRH     r2,[r0,#4]
;;;2209   }
000010  4770              BX       lr
;;;2210   
                          ENDP


                          AREA ||i.TIM_SelectSlaveMode||, CODE, READONLY, ALIGN=1

                  TIM_SelectSlaveMode PROC
;;;2222     */
;;;2223   void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode)
000000  8902              LDRH     r2,[r0,#8]
;;;2224   {
;;;2225     /* Check the parameters */
;;;2226     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;2227     assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));
;;;2228    /* Reset the SMS Bits */
;;;2229     TIMx->SMCR &= (uint16_t)~((uint16_t)TIM_SMCR_SMS);
000002  f64f73f8          MOV      r3,#0xfff8
000006  401a              ANDS     r2,r2,r3
000008  8102              STRH     r2,[r0,#8]
;;;2230     /* Select the Slave Mode */
;;;2231     TIMx->SMCR |= TIM_SlaveMode;
00000a  8902              LDRH     r2,[r0,#8]
00000c  430a              ORRS     r2,r2,r1
00000e  8102              STRH     r2,[r0,#8]
;;;2232   }
000010  4770              BX       lr
;;;2233   
                          ENDP


                          AREA ||i.TIM_SetAutoreload||, CODE, READONLY, ALIGN=1

                  TIM_SetAutoreload PROC
;;;2275     */
;;;2276   void TIM_SetAutoreload(TIM_TypeDef* TIMx, uint16_t Autoreload)
000000  8581              STRH     r1,[r0,#0x2c]
;;;2277   {
;;;2278     /* Check the parameters */
;;;2279     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2280     /* Set the Autoreload Register value */
;;;2281     TIMx->ARR = Autoreload;
;;;2282   }
000002  4770              BX       lr
;;;2283   
                          ENDP


                          AREA ||i.TIM_SetClockDivision||, CODE, READONLY, ALIGN=1

                  TIM_SetClockDivision PROC
;;;2438     */
;;;2439   void TIM_SetClockDivision(TIM_TypeDef* TIMx, uint16_t TIM_CKD)
000000  8802              LDRH     r2,[r0,#0]
;;;2440   {
;;;2441     /* Check the parameters */
;;;2442     assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;2443     assert_param(IS_TIM_CKD_DIV(TIM_CKD));
;;;2444     /* Reset the CKD Bits */
;;;2445     TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_CKD);
000002  f64f43ff          MOV      r3,#0xfcff
000006  401a              ANDS     r2,r2,r3
000008  8002              STRH     r2,[r0,#0]
;;;2446     /* Set the CKD value */
;;;2447     TIMx->CR1 |= TIM_CKD;
00000a  8802              LDRH     r2,[r0,#0]
00000c  430a              ORRS     r2,r2,r1
00000e  8002              STRH     r2,[r0,#0]
;;;2448   }
000010  4770              BX       lr
;;;2449   
                          ENDP


                          AREA ||i.TIM_SetCompare1||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare1 PROC
;;;2289     */
;;;2290   void TIM_SetCompare1(TIM_TypeDef* TIMx, uint16_t Compare1)
000000  8681              STRH     r1,[r0,#0x34]
;;;2291   {
;;;2292     /* Check the parameters */
;;;2293     assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;2294     /* Set the Capture Compare1 Register value */
;;;2295     TIMx->CCR1 = Compare1;
;;;2296   }
000002  4770              BX       lr
;;;2297   
                          ENDP


                          AREA ||i.TIM_SetCompare2||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare2 PROC
;;;2303     */
;;;2304   void TIM_SetCompare2(TIM_TypeDef* TIMx, uint16_t Compare2)
000000  8701              STRH     r1,[r0,#0x38]
;;;2305   {
;;;2306     /* Check the parameters */
;;;2307     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;2308     /* Set the Capture Compare2 Register value */
;;;2309     TIMx->CCR2 = Compare2;
;;;2310   }
000002  4770              BX       lr
;;;2311   
                          ENDP


                          AREA ||i.TIM_SetCompare3||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare3 PROC
;;;2317     */
;;;2318   void TIM_SetCompare3(TIM_TypeDef* TIMx, uint16_t Compare3)
000000  8781              STRH     r1,[r0,#0x3c]
;;;2319   {
;;;2320     /* Check the parameters */
;;;2321     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2322     /* Set the Capture Compare3 Register value */
;;;2323     TIMx->CCR3 = Compare3;
;;;2324   }
000002  4770              BX       lr
;;;2325   
                          ENDP


                          AREA ||i.TIM_SetCompare4||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare4 PROC
;;;2331     */
;;;2332   void TIM_SetCompare4(TIM_TypeDef* TIMx, uint16_t Compare4)
000000  f8a01040          STRH     r1,[r0,#0x40]
;;;2333   {
;;;2334     /* Check the parameters */
;;;2335     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2336     /* Set the Capture Compare4 Register value */
;;;2337     TIMx->CCR4 = Compare4;
;;;2338   }
000004  4770              BX       lr
;;;2339   
                          ENDP


                          AREA ||i.TIM_SetCounter||, CODE, READONLY, ALIGN=1

                  TIM_SetCounter PROC
;;;2261     */
;;;2262   void TIM_SetCounter(TIM_TypeDef* TIMx, uint16_t Counter)
000000  8481              STRH     r1,[r0,#0x24]
;;;2263   {
;;;2264     /* Check the parameters */
;;;2265     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2266     /* Set the Counter Register value */
;;;2267     TIMx->CNT = Counter;
;;;2268   }
000002  4770              BX       lr
;;;2269   
                          ENDP


                          AREA ||i.TIM_SetIC1Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC1Prescaler PROC
;;;2350     */
;;;2351   void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;2352   {
;;;2353     /* Check the parameters */
;;;2354     assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;2355     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2356     /* Reset the IC1PSC Bits */
;;;2357     TIMx->CCMR1 &= (uint16_t)~((uint16_t)TIM_CCMR1_IC1PSC);
000002  f64f73f3          MOV      r3,#0xfff3
000006  401a              ANDS     r2,r2,r3
000008  8302              STRH     r2,[r0,#0x18]
;;;2358     /* Set the IC1PSC value */
;;;2359     TIMx->CCMR1 |= TIM_ICPSC;
00000a  8b02              LDRH     r2,[r0,#0x18]
00000c  430a              ORRS     r2,r2,r1
00000e  8302              STRH     r2,[r0,#0x18]
;;;2360   }
000010  4770              BX       lr
;;;2361   
                          ENDP


                          AREA ||i.TIM_SetIC2Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC2Prescaler PROC
;;;2372     */
;;;2373   void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;2374   {
;;;2375     /* Check the parameters */
;;;2376     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;2377     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2378     /* Reset the IC2PSC Bits */
;;;2379     TIMx->CCMR1 &= (uint16_t)~((uint16_t)TIM_CCMR1_IC2PSC);
000002  f24f33ff          MOV      r3,#0xf3ff
000006  401a              ANDS     r2,r2,r3
000008  8302              STRH     r2,[r0,#0x18]
;;;2380     /* Set the IC2PSC value */
;;;2381     TIMx->CCMR1 |= (uint16_t)(TIM_ICPSC << 8);
00000a  8b02              LDRH     r2,[r0,#0x18]
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032301          AND      r3,r3,r1,LSL #8
000014  431a              ORRS     r2,r2,r3
000016  8302              STRH     r2,[r0,#0x18]
;;;2382   }
000018  4770              BX       lr
;;;2383   
                          ENDP


                          AREA ||i.TIM_SetIC3Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC3Prescaler PROC
;;;2394     */
;;;2395   void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;2396   {
;;;2397     /* Check the parameters */
;;;2398     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2399     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2400     /* Reset the IC3PSC Bits */
;;;2401     TIMx->CCMR2 &= (uint16_t)~((uint16_t)TIM_CCMR2_IC3PSC);
000002  f64f73f3          MOV      r3,#0xfff3
000006  401a              ANDS     r2,r2,r3
000008  8382              STRH     r2,[r0,#0x1c]
;;;2402     /* Set the IC3PSC value */
;;;2403     TIMx->CCMR2 |= TIM_ICPSC;
00000a  8b82              LDRH     r2,[r0,#0x1c]
00000c  430a              ORRS     r2,r2,r1
00000e  8382              STRH     r2,[r0,#0x1c]
;;;2404   }
000010  4770              BX       lr
;;;2405   
                          ENDP


                          AREA ||i.TIM_SetIC4Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC4Prescaler PROC
;;;2416     */
;;;2417   void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;2418   {  
;;;2419     /* Check the parameters */
;;;2420     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2421     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2422     /* Reset the IC4PSC Bits */
;;;2423     TIMx->CCMR2 &= (uint16_t)~((uint16_t)TIM_CCMR2_IC4PSC);
000002  f24f33ff          MOV      r3,#0xf3ff
000006  401a              ANDS     r2,r2,r3
000008  8382              STRH     r2,[r0,#0x1c]
;;;2424     /* Set the IC4PSC value */
;;;2425     TIMx->CCMR2 |= (uint16_t)(TIM_ICPSC << 8);
00000a  8b82              LDRH     r2,[r0,#0x1c]
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032301          AND      r3,r3,r1,LSL #8
000014  431a              ORRS     r2,r2,r3
000016  8382              STRH     r2,[r0,#0x1c]
;;;2426   }
000018  4770              BX       lr
;;;2427   
                          ENDP


                          AREA ||i.TIM_TIxExternalClockConfig||, CODE, READONLY, ALIGN=1

                  TIM_TIxExternalClockConfig PROC
;;;1032     */
;;;1033   void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1034                                   uint16_t TIM_ICPolarity, uint16_t ICFilter)
;;;1035   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;1036     /* Check the parameters */
;;;1037     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;1038     assert_param(IS_TIM_TIXCLK_SOURCE(TIM_TIxExternalCLKSource));
;;;1039     assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
;;;1040     assert_param(IS_TIM_IC_FILTER(ICFilter));
;;;1041     /* Configure the Timer Input Clock Source */
;;;1042     if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
00000c  2d60              CMP      r5,#0x60
00000e  d106              BNE      |L87.30|
;;;1043     {
;;;1044       TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
000010  463b              MOV      r3,r7
000012  2201              MOVS     r2,#1
000014  4631              MOV      r1,r6
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       TI2_Config
00001c  e005              B        |L87.42|
                  |L87.30|
;;;1045     }
;;;1046     else
;;;1047     {
;;;1048       TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
00001e  463b              MOV      r3,r7
000020  2201              MOVS     r2,#1
000022  4631              MOV      r1,r6
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       TI1_Config
                  |L87.42|
;;;1049     }
;;;1050     /* Select the Trigger source */
;;;1051     TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
00002a  4629              MOV      r1,r5
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       TIM_SelectInputTrigger
;;;1052     /* Select the External clock mode1 */
;;;1053     TIMx->SMCR |= TIM_SlaveMode_External1;
000032  8920              LDRH     r0,[r4,#8]
000034  f0400007          ORR      r0,r0,#7
000038  8120              STRH     r0,[r4,#8]
;;;1054   }
00003a  e8bd81f0          POP      {r4-r8,pc}
;;;1055   
                          ENDP


                          AREA ||i.TIM_TimeBaseInit||, CODE, READONLY, ALIGN=2

                  TIM_TimeBaseInit PROC
;;;223      */
;;;224    void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
000000  2200              MOVS     r2,#0
;;;225    {
;;;226      uint16_t tmpcr1 = 0;
;;;227    
;;;228      /* Check the parameters */
;;;229      assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
;;;230      assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
;;;231      assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));
;;;232    
;;;233      tmpcr1 = TIMx->CR1;  
000002  8802              LDRH     r2,[r0,#0]
;;;234    
;;;235      if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM2) || (TIMx == TIM3)||
000004  4b1d              LDR      r3,|L88.124|
000006  4298              CMP      r0,r3
000008  d00e              BEQ      |L88.40|
00000a  4b1d              LDR      r3,|L88.128|
00000c  4298              CMP      r0,r3
00000e  d00b              BEQ      |L88.40|
000010  f1b04f80          CMP      r0,#0x40000000
000014  d008              BEQ      |L88.40|
000016  4b1b              LDR      r3,|L88.132|
000018  4298              CMP      r0,r3
00001a  d005              BEQ      |L88.40|
;;;236         (TIMx == TIM4) || (TIMx == TIM5)) 
00001c  4b1a              LDR      r3,|L88.136|
00001e  4298              CMP      r0,r3
000020  d002              BEQ      |L88.40|
000022  4b1a              LDR      r3,|L88.140|
000024  4298              CMP      r0,r3
000026  d104              BNE      |L88.50|
                  |L88.40|
;;;237      {
;;;238        /* Select the Counter Mode */
;;;239        tmpcr1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));
000028  f64f738f          MOV      r3,#0xff8f
00002c  401a              ANDS     r2,r2,r3
;;;240        tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
00002e  884b              LDRH     r3,[r1,#2]
000030  431a              ORRS     r2,r2,r3
                  |L88.50|
;;;241      }
;;;242     
;;;243      if((TIMx != TIM6) && (TIMx != TIM7))
000032  4b17              LDR      r3,|L88.144|
000034  4298              CMP      r0,r3
000036  d007              BEQ      |L88.72|
000038  4b16              LDR      r3,|L88.148|
00003a  4298              CMP      r0,r3
00003c  d004              BEQ      |L88.72|
;;;244      {
;;;245        /* Set the clock division */
;;;246        tmpcr1 &= (uint16_t)(~((uint16_t)TIM_CR1_CKD));
00003e  f64f43ff          MOV      r3,#0xfcff
000042  401a              ANDS     r2,r2,r3
;;;247        tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
000044  88cb              LDRH     r3,[r1,#6]
000046  431a              ORRS     r2,r2,r3
                  |L88.72|
;;;248      }
;;;249    
;;;250      TIMx->CR1 = tmpcr1;
000048  8002              STRH     r2,[r0,#0]
;;;251    
;;;252      /* Set the Autoreload value */
;;;253      TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
00004a  888b              LDRH     r3,[r1,#4]
00004c  8583              STRH     r3,[r0,#0x2c]
;;;254     
;;;255      /* Set the Prescaler value */
;;;256      TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
00004e  880b              LDRH     r3,[r1,#0]
000050  8503              STRH     r3,[r0,#0x28]
;;;257        
;;;258      if ((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM15)|| (TIMx == TIM16) || (TIMx == TIM17))  
000052  4b0a              LDR      r3,|L88.124|
000054  4298              CMP      r0,r3
000056  d00b              BEQ      |L88.112|
000058  4b09              LDR      r3,|L88.128|
00005a  4298              CMP      r0,r3
00005c  d008              BEQ      |L88.112|
00005e  4b0e              LDR      r3,|L88.152|
000060  4298              CMP      r0,r3
000062  d005              BEQ      |L88.112|
000064  4b0d              LDR      r3,|L88.156|
000066  4298              CMP      r0,r3
000068  d002              BEQ      |L88.112|
00006a  4b0d              LDR      r3,|L88.160|
00006c  4298              CMP      r0,r3
00006e  d101              BNE      |L88.116|
                  |L88.112|
;;;259      {
;;;260        /* Set the Repetition Counter value */
;;;261        TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
000070  7a0b              LDRB     r3,[r1,#8]
000072  8603              STRH     r3,[r0,#0x30]
                  |L88.116|
;;;262      }
;;;263    
;;;264      /* Generate an update event to reload the Prescaler and the Repetition counter
;;;265         values immediately */
;;;266      TIMx->EGR = TIM_PSCReloadMode_Immediate;           
000074  2301              MOVS     r3,#1
000076  8283              STRH     r3,[r0,#0x14]
;;;267    }
000078  4770              BX       lr
;;;268    
                          ENDP

00007a  0000              DCW      0x0000
                  |L88.124|
                          DCD      0x40012c00
                  |L88.128|
                          DCD      0x40013400
                  |L88.132|
                          DCD      0x40000400
                  |L88.136|
                          DCD      0x40000800
                  |L88.140|
                          DCD      0x40000c00
                  |L88.144|
                          DCD      0x40001000
                  |L88.148|
                          DCD      0x40001400
                  |L88.152|
                          DCD      0x40014000
                  |L88.156|
                          DCD      0x40014400
                  |L88.160|
                          DCD      0x40014800

                          AREA ||i.TIM_TimeBaseStructInit||, CODE, READONLY, ALIGN=1

                  TIM_TimeBaseStructInit PROC
;;;733      */
;;;734    void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
000000  f64f71ff          MOV      r1,#0xffff
;;;735    {
;;;736      /* Set the default configuration */
;;;737      TIM_TimeBaseInitStruct->TIM_Period = 0xFFFF;
000004  8081              STRH     r1,[r0,#4]
;;;738      TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
000006  2100              MOVS     r1,#0
000008  8001              STRH     r1,[r0,#0]
;;;739      TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
00000a  80c1              STRH     r1,[r0,#6]
;;;740      TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
00000c  8041              STRH     r1,[r0,#2]
;;;741      TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;
00000e  7201              STRB     r1,[r0,#8]
;;;742    }
000010  4770              BX       lr
;;;743    
                          ENDP


                          AREA ||i.TIM_UpdateDisableConfig||, CODE, READONLY, ALIGN=1

                  TIM_UpdateDisableConfig PROC
;;;2089     */
;;;2090   void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L90.12|
;;;2091   {
;;;2092     /* Check the parameters */
;;;2093     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2094     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2095     if (NewState != DISABLE)
;;;2096     {
;;;2097       /* Set the Update Disable Bit */
;;;2098       TIMx->CR1 |= TIM_CR1_UDIS;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420202          ORR      r2,r2,#2
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L90.22|
                  |L90.12|
;;;2099     }
;;;2100     else
;;;2101     {
;;;2102       /* Reset the Update Disable Bit */
;;;2103       TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_UDIS);
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64f73fd          MOV      r3,#0xfffd
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L90.22|
;;;2104     }
;;;2105   }
000016  4770              BX       lr
;;;2106   
                          ENDP


                          AREA ||i.TIM_UpdateRequestConfig||, CODE, READONLY, ALIGN=1

                  TIM_UpdateRequestConfig PROC
;;;2117     */
;;;2118   void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, uint16_t TIM_UpdateSource)
000000  b121              CBZ      r1,|L91.12|
;;;2119   {
;;;2120     /* Check the parameters */
;;;2121     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2122     assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));
;;;2123     if (TIM_UpdateSource != TIM_UpdateSource_Global)
;;;2124     {
;;;2125       /* Set the URS Bit */
;;;2126       TIMx->CR1 |= TIM_CR1_URS;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420204          ORR      r2,r2,#4
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L91.22|
                  |L91.12|
;;;2127     }
;;;2128     else
;;;2129     {
;;;2130       /* Reset the URS Bit */
;;;2131       TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_URS);
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64f73fb          MOV      r3,#0xfffb
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L91.22|
;;;2132     }
;;;2133   }
000016  4770              BX       lr
;;;2134   
                          ENDP

