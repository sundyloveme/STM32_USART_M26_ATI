; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\stm32f10x_dac.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\stm32f10x_dac.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\startup\arm -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\Libraries\STM32F10x_StdPeriph_Driver\src -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\USER -I..\MDK-ARM -IC:\Users\Administrator\Desktop\stm32-uart-chenlong\stm32-uart-chenlong\MDK-ARM\RTE -I"D:\Program Files\keil5\ARM\PACK\ARM\CMSIS\4.2.0\CMSIS\Include" -I"D:\Program Files\keil5\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0" -D__MICROLIB -D__UVISION_VERSION=514 -D_RTE_ -DSTM32F10X_MD --omf_browse=.\obj\stm32f10x_dac.crf ..\Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_dac.c]
                          THUMB

                          AREA ||i.DAC_Cmd||, CODE, READONLY, ALIGN=2

                  DAC_Cmd PROC
;;;171      */
;;;172    void DAC_Cmd(uint32_t DAC_Channel, FunctionalState NewState)
000000  b139              CBZ      r1,|L1.18|
;;;173    {
;;;174      /* Check the parameters */
;;;175      assert_param(IS_DAC_CHANNEL(DAC_Channel));
;;;176      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;177      if (NewState != DISABLE)
;;;178      {
;;;179        /* Enable the selected DAC channel */
;;;180        DAC->CR |= (DAC_CR_EN1 << DAC_Channel);
000002  4a08              LDR      r2,|L1.36|
000004  6812              LDR      r2,[r2,#0]
000006  2301              MOVS     r3,#1
000008  4083              LSLS     r3,r3,r0
00000a  431a              ORRS     r2,r2,r3
00000c  4b05              LDR      r3,|L1.36|
00000e  601a              STR      r2,[r3,#0]
000010  e006              B        |L1.32|
                  |L1.18|
;;;181      }
;;;182      else
;;;183      {
;;;184        /* Disable the selected DAC channel */
;;;185        DAC->CR &= ~(DAC_CR_EN1 << DAC_Channel);
000012  4a04              LDR      r2,|L1.36|
000014  6812              LDR      r2,[r2,#0]
000016  2301              MOVS     r3,#1
000018  4083              LSLS     r3,r3,r0
00001a  439a              BICS     r2,r2,r3
00001c  4b01              LDR      r3,|L1.36|
00001e  601a              STR      r2,[r3,#0]
                  |L1.32|
;;;186      }
;;;187    }
000020  4770              BX       lr
;;;188    #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
                          ENDP

000022  0000              DCW      0x0000
                  |L1.36|
                          DCD      0x40007400

                          AREA ||i.DAC_DMACmd||, CODE, READONLY, ALIGN=2

                  DAC_DMACmd PROC
;;;231      */
;;;232    void DAC_DMACmd(uint32_t DAC_Channel, FunctionalState NewState)
000000  b141              CBZ      r1,|L2.20|
;;;233    {
;;;234      /* Check the parameters */
;;;235      assert_param(IS_DAC_CHANNEL(DAC_Channel));
;;;236      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;237      if (NewState != DISABLE)
;;;238      {
;;;239        /* Enable the selected DAC channel DMA request */
;;;240        DAC->CR |= (DAC_CR_DMAEN1 << DAC_Channel);
000002  4a09              LDR      r2,|L2.40|
000004  6812              LDR      r2,[r2,#0]
000006  f44f5380          MOV      r3,#0x1000
00000a  4083              LSLS     r3,r3,r0
00000c  431a              ORRS     r2,r2,r3
00000e  4b06              LDR      r3,|L2.40|
000010  601a              STR      r2,[r3,#0]
000012  e007              B        |L2.36|
                  |L2.20|
;;;241      }
;;;242      else
;;;243      {
;;;244        /* Disable the selected DAC channel DMA request */
;;;245        DAC->CR &= ~(DAC_CR_DMAEN1 << DAC_Channel);
000014  4a04              LDR      r2,|L2.40|
000016  6812              LDR      r2,[r2,#0]
000018  f44f5380          MOV      r3,#0x1000
00001c  4083              LSLS     r3,r3,r0
00001e  439a              BICS     r2,r2,r3
000020  4b01              LDR      r3,|L2.40|
000022  601a              STR      r2,[r3,#0]
                  |L2.36|
;;;246      }
;;;247    }
000024  4770              BX       lr
;;;248    
                          ENDP

000026  0000              DCW      0x0000
                  |L2.40|
                          DCD      0x40007400

                          AREA ||i.DAC_DeInit||, CODE, READONLY, ALIGN=1

                  DAC_DeInit PROC
;;;96       */
;;;97     void DAC_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;98     {
;;;99       /* Enable DAC reset state */
;;;100      RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, ENABLE);
000002  2101              MOVS     r1,#1
000004  0748              LSLS     r0,r1,#29
000006  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;101      /* Release DAC from reset state */
;;;102      RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, DISABLE);
00000a  2100              MOVS     r1,#0
00000c  f04f5000          MOV      r0,#0x20000000
000010  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;103    }
000014  bd10              POP      {r4,pc}
;;;104    
                          ENDP


                          AREA ||i.DAC_DualSoftwareTriggerCmd||, CODE, READONLY, ALIGN=2

                  DAC_DualSoftwareTriggerCmd PROC
;;;282      */
;;;283    void DAC_DualSoftwareTriggerCmd(FunctionalState NewState)
000000  b130              CBZ      r0,|L4.16|
;;;284    {
;;;285      /* Check the parameters */
;;;286      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;287      if (NewState != DISABLE)
;;;288      {
;;;289        /* Enable software trigger for both DAC channels */
;;;290        DAC->SWTRIGR |= DUAL_SWTRIG_SET ;
000002  4907              LDR      r1,|L4.32|
000004  6809              LDR      r1,[r1,#0]
000006  f0410103          ORR      r1,r1,#3
00000a  4a05              LDR      r2,|L4.32|
00000c  6011              STR      r1,[r2,#0]
00000e  e005              B        |L4.28|
                  |L4.16|
;;;291      }
;;;292      else
;;;293      {
;;;294        /* Disable software trigger for both DAC channels */
;;;295        DAC->SWTRIGR &= DUAL_SWTRIG_RESET;
000010  4903              LDR      r1,|L4.32|
000012  6809              LDR      r1,[r1,#0]
000014  f0210103          BIC      r1,r1,#3
000018  4a01              LDR      r2,|L4.32|
00001a  6011              STR      r1,[r2,#0]
                  |L4.28|
;;;296      }
;;;297    }
00001c  4770              BX       lr
;;;298    
                          ENDP

00001e  0000              DCW      0x0000
                  |L4.32|
                          DCD      0x40007404

                          AREA ||i.DAC_GetDataOutputValue||, CODE, READONLY, ALIGN=2

                  DAC_GetDataOutputValue PROC
;;;428      */
;;;429    uint16_t DAC_GetDataOutputValue(uint32_t DAC_Channel)
000000  b508              PUSH     {r3,lr}
;;;430    {
000002  4601              MOV      r1,r0
;;;431      __IO uint32_t tmp = 0;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;432      
;;;433      /* Check the parameters */
;;;434      assert_param(IS_DAC_CHANNEL(DAC_Channel));
;;;435      
;;;436      tmp = (uint32_t) DAC_BASE ;
000008  4805              LDR      r0,|L5.32|
00000a  9000              STR      r0,[sp,#0]
;;;437      tmp += DOR_OFFSET + ((uint32_t)DAC_Channel >> 2);
00000c  202c              MOVS     r0,#0x2c
00000e  eb000091          ADD      r0,r0,r1,LSR #2
000012  9a00              LDR      r2,[sp,#0]
000014  4410              ADD      r0,r0,r2
000016  9000              STR      r0,[sp,#0]
;;;438      
;;;439      /* Returns the DAC channel data output register value */
;;;440      return (uint16_t) (*(__IO uint32_t*) tmp);
000018  9800              LDR      r0,[sp,#0]
00001a  6800              LDR      r0,[r0,#0]
00001c  b280              UXTH     r0,r0
;;;441    }
00001e  bd08              POP      {r3,pc}
;;;442    
                          ENDP

                  |L5.32|
                          DCD      0x40007400

                          AREA ||i.DAC_Init||, CODE, READONLY, ALIGN=2

                  DAC_Init PROC
;;;115      */
;;;116    void DAC_Init(uint32_t DAC_Channel, DAC_InitTypeDef* DAC_InitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;117    {
;;;118      uint32_t tmpreg1 = 0, tmpreg2 = 0;
000002  2200              MOVS     r2,#0
000004  2300              MOVS     r3,#0
;;;119      /* Check the DAC parameters */
;;;120      assert_param(IS_DAC_TRIGGER(DAC_InitStruct->DAC_Trigger));
;;;121      assert_param(IS_DAC_GENERATE_WAVE(DAC_InitStruct->DAC_WaveGeneration));
;;;122      assert_param(IS_DAC_LFSR_UNMASK_TRIANGLE_AMPLITUDE(DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude));
;;;123      assert_param(IS_DAC_OUTPUT_BUFFER_STATE(DAC_InitStruct->DAC_OutputBuffer));
;;;124    /*---------------------------- DAC CR Configuration --------------------------*/
;;;125      /* Get the DAC CR value */
;;;126      tmpreg1 = DAC->CR;
000006  4c0a              LDR      r4,|L6.48|
000008  6822              LDR      r2,[r4,#0]
;;;127      /* Clear BOFFx, TENx, TSELx, WAVEx and MAMPx bits */
;;;128      tmpreg1 &= ~(CR_CLEAR_MASK << DAC_Channel);
00000a  f64074fe          MOV      r4,#0xffe
00000e  4084              LSLS     r4,r4,r0
000010  43a2              BICS     r2,r2,r4
;;;129      /* Configure for the selected DAC channel: buffer output, trigger, wave genration,
;;;130         mask/amplitude for wave genration */
;;;131      /* Set TSELx and TENx bits according to DAC_Trigger value */
;;;132      /* Set WAVEx bits according to DAC_WaveGeneration value */
;;;133      /* Set MAMPx bits according to DAC_LFSRUnmask_TriangleAmplitude value */ 
;;;134      /* Set BOFFx bit according to DAC_OutputBuffer value */   
;;;135      tmpreg2 = (DAC_InitStruct->DAC_Trigger | DAC_InitStruct->DAC_WaveGeneration |
000012  e9d14500          LDRD     r4,r5,[r1,#0]
000016  432c              ORRS     r4,r4,r5
000018  688d              LDR      r5,[r1,#8]
00001a  432c              ORRS     r4,r4,r5
00001c  68cd              LDR      r5,[r1,#0xc]
00001e  ea440305          ORR      r3,r4,r5
;;;136                 DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude | DAC_InitStruct->DAC_OutputBuffer);
;;;137      /* Calculate CR register value depending on DAC_Channel */
;;;138      tmpreg1 |= tmpreg2 << DAC_Channel;
000022  fa03f400          LSL      r4,r3,r0
000026  4322              ORRS     r2,r2,r4
;;;139      /* Write to DAC CR */
;;;140      DAC->CR = tmpreg1;
000028  4c01              LDR      r4,|L6.48|
00002a  6022              STR      r2,[r4,#0]
;;;141    }
00002c  bd30              POP      {r4,r5,pc}
;;;142    
                          ENDP

00002e  0000              DCW      0x0000
                  |L6.48|
                          DCD      0x40007400

                          AREA ||i.DAC_SetChannel1Data||, CODE, READONLY, ALIGN=2

                  DAC_SetChannel1Data PROC
;;;340      */
;;;341    void DAC_SetChannel1Data(uint32_t DAC_Align, uint16_t Data)
000000  b508              PUSH     {r3,lr}
;;;342    {  
;;;343      __IO uint32_t tmp = 0;
000002  2200              MOVS     r2,#0
000004  9200              STR      r2,[sp,#0]
;;;344      
;;;345      /* Check the parameters */
;;;346      assert_param(IS_DAC_ALIGN(DAC_Align));
;;;347      assert_param(IS_DAC_DATA(Data));
;;;348      
;;;349      tmp = (uint32_t)DAC_BASE; 
000006  4a05              LDR      r2,|L7.28|
000008  9200              STR      r2,[sp,#0]
;;;350      tmp += DHR12R1_OFFSET + DAC_Align;
00000a  f1000208          ADD      r2,r0,#8
00000e  9b00              LDR      r3,[sp,#0]
000010  441a              ADD      r2,r2,r3
000012  9200              STR      r2,[sp,#0]
;;;351    
;;;352      /* Set the DAC channel1 selected data holding register */
;;;353      *(__IO uint32_t *) tmp = Data;
000014  9a00              LDR      r2,[sp,#0]
000016  6011              STR      r1,[r2,#0]
;;;354    }
000018  bd08              POP      {r3,pc}
;;;355    
                          ENDP

00001a  0000              DCW      0x0000
                  |L7.28|
                          DCD      0x40007400

                          AREA ||i.DAC_SetChannel2Data||, CODE, READONLY, ALIGN=2

                  DAC_SetChannel2Data PROC
;;;365      */
;;;366    void DAC_SetChannel2Data(uint32_t DAC_Align, uint16_t Data)
000000  b508              PUSH     {r3,lr}
;;;367    {
;;;368      __IO uint32_t tmp = 0;
000002  2200              MOVS     r2,#0
000004  9200              STR      r2,[sp,#0]
;;;369    
;;;370      /* Check the parameters */
;;;371      assert_param(IS_DAC_ALIGN(DAC_Align));
;;;372      assert_param(IS_DAC_DATA(Data));
;;;373      
;;;374      tmp = (uint32_t)DAC_BASE;
000006  4a05              LDR      r2,|L8.28|
000008  9200              STR      r2,[sp,#0]
;;;375      tmp += DHR12R2_OFFSET + DAC_Align;
00000a  f1000214          ADD      r2,r0,#0x14
00000e  9b00              LDR      r3,[sp,#0]
000010  441a              ADD      r2,r2,r3
000012  9200              STR      r2,[sp,#0]
;;;376    
;;;377      /* Set the DAC channel2 selected data holding register */
;;;378      *(__IO uint32_t *)tmp = Data;
000014  9a00              LDR      r2,[sp,#0]
000016  6011              STR      r1,[r2,#0]
;;;379    }
000018  bd08              POP      {r3,pc}
;;;380    
                          ENDP

00001a  0000              DCW      0x0000
                  |L8.28|
                          DCD      0x40007400

                          AREA ||i.DAC_SetDualChannelData||, CODE, READONLY, ALIGN=2

                  DAC_SetDualChannelData PROC
;;;394      */
;;;395    void DAC_SetDualChannelData(uint32_t DAC_Align, uint16_t Data2, uint16_t Data1)
000000  b530              PUSH     {r4,r5,lr}
;;;396    {
;;;397      uint32_t data = 0, tmp = 0;
000002  2400              MOVS     r4,#0
000004  2300              MOVS     r3,#0
;;;398      
;;;399      /* Check the parameters */
;;;400      assert_param(IS_DAC_ALIGN(DAC_Align));
;;;401      assert_param(IS_DAC_DATA(Data1));
;;;402      assert_param(IS_DAC_DATA(Data2));
;;;403      
;;;404      /* Calculate and set dual DAC data holding register value */
;;;405      if (DAC_Align == DAC_Align_8b_R)
000006  2808              CMP      r0,#8
000008  d102              BNE      |L9.16|
;;;406      {
;;;407        data = ((uint32_t)Data2 << 8) | Data1; 
00000a  ea422401          ORR      r4,r2,r1,LSL #8
00000e  e001              B        |L9.20|
                  |L9.16|
;;;408      }
;;;409      else
;;;410      {
;;;411        data = ((uint32_t)Data2 << 16) | Data1;
000010  ea424401          ORR      r4,r2,r1,LSL #16
                  |L9.20|
;;;412      }
;;;413      
;;;414      tmp = (uint32_t)DAC_BASE;
000014  4b02              LDR      r3,|L9.32|
;;;415      tmp += DHR12RD_OFFSET + DAC_Align;
000016  f1000520          ADD      r5,r0,#0x20
00001a  442b              ADD      r3,r3,r5
;;;416    
;;;417      /* Set the dual DAC selected data holding register */
;;;418      *(__IO uint32_t *)tmp = data;
00001c  601c              STR      r4,[r3,#0]
;;;419    }
00001e  bd30              POP      {r4,r5,pc}
;;;420    
                          ENDP

                  |L9.32|
                          DCD      0x40007400

                          AREA ||i.DAC_SoftwareTriggerCmd||, CODE, READONLY, ALIGN=2

                  DAC_SoftwareTriggerCmd PROC
;;;258      */
;;;259    void DAC_SoftwareTriggerCmd(uint32_t DAC_Channel, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;260    {
;;;261      /* Check the parameters */
;;;262      assert_param(IS_DAC_CHANNEL(DAC_Channel));
;;;263      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;264      if (NewState != DISABLE)
000002  b141              CBZ      r1,|L10.22|
;;;265      {
;;;266        /* Enable software trigger for the selected DAC channel */
;;;267        DAC->SWTRIGR |= (uint32_t)DAC_SWTRIGR_SWTRIG1 << (DAC_Channel >> 4);
000004  4a08              LDR      r2,|L10.40|
000006  6812              LDR      r2,[r2,#0]
000008  0904              LSRS     r4,r0,#4
00000a  2301              MOVS     r3,#1
00000c  40a3              LSLS     r3,r3,r4
00000e  431a              ORRS     r2,r2,r3
000010  4b05              LDR      r3,|L10.40|
000012  601a              STR      r2,[r3,#0]
000014  e007              B        |L10.38|
                  |L10.22|
;;;268      }
;;;269      else
;;;270      {
;;;271        /* Disable software trigger for the selected DAC channel */
;;;272        DAC->SWTRIGR &= ~((uint32_t)DAC_SWTRIGR_SWTRIG1 << (DAC_Channel >> 4));
000016  4a04              LDR      r2,|L10.40|
000018  6812              LDR      r2,[r2,#0]
00001a  0904              LSRS     r4,r0,#4
00001c  2301              MOVS     r3,#1
00001e  40a3              LSLS     r3,r3,r4
000020  439a              BICS     r2,r2,r3
000022  4b01              LDR      r3,|L10.40|
000024  601a              STR      r2,[r3,#0]
                  |L10.38|
;;;273      }
;;;274    }
000026  bd10              POP      {r4,pc}
;;;275    
                          ENDP

                  |L10.40|
                          DCD      0x40007404

                          AREA ||i.DAC_StructInit||, CODE, READONLY, ALIGN=1

                  DAC_StructInit PROC
;;;148      */
;;;149    void DAC_StructInit(DAC_InitTypeDef* DAC_InitStruct)
000000  2100              MOVS     r1,#0
;;;150    {
;;;151    /*--------------- Reset DAC init structure parameters values -----------------*/
;;;152      /* Initialize the DAC_Trigger member */
;;;153      DAC_InitStruct->DAC_Trigger = DAC_Trigger_None;
000002  6001              STR      r1,[r0,#0]
;;;154      /* Initialize the DAC_WaveGeneration member */
;;;155      DAC_InitStruct->DAC_WaveGeneration = DAC_WaveGeneration_None;
000004  6041              STR      r1,[r0,#4]
;;;156      /* Initialize the DAC_LFSRUnmask_TriangleAmplitude member */
;;;157      DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude = DAC_LFSRUnmask_Bit0;
000006  6081              STR      r1,[r0,#8]
;;;158      /* Initialize the DAC_OutputBuffer member */
;;;159      DAC_InitStruct->DAC_OutputBuffer = DAC_OutputBuffer_Enable;
000008  60c1              STR      r1,[r0,#0xc]
;;;160    }
00000a  4770              BX       lr
;;;161    
                          ENDP


                          AREA ||i.DAC_WaveGenerationCmd||, CODE, READONLY, ALIGN=2

                  DAC_WaveGenerationCmd PROC
;;;312      */
;;;313    void DAC_WaveGenerationCmd(uint32_t DAC_Channel, uint32_t DAC_Wave, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;314    {
;;;315      /* Check the parameters */
;;;316      assert_param(IS_DAC_CHANNEL(DAC_Channel));
;;;317      assert_param(IS_DAC_WAVE(DAC_Wave)); 
;;;318      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;319      if (NewState != DISABLE)
000002  b13a              CBZ      r2,|L12.20|
;;;320      {
;;;321        /* Enable the selected wave generation for the selected DAC channel */
;;;322        DAC->CR |= DAC_Wave << DAC_Channel;
000004  4b07              LDR      r3,|L12.36|
000006  681b              LDR      r3,[r3,#0]
000008  fa01f400          LSL      r4,r1,r0
00000c  4323              ORRS     r3,r3,r4
00000e  4c05              LDR      r4,|L12.36|
000010  6023              STR      r3,[r4,#0]
000012  e006              B        |L12.34|
                  |L12.20|
;;;323      }
;;;324      else
;;;325      {
;;;326        /* Disable the selected wave generation for the selected DAC channel */
;;;327        DAC->CR &= ~(DAC_Wave << DAC_Channel);
000014  4b03              LDR      r3,|L12.36|
000016  681b              LDR      r3,[r3,#0]
000018  fa01f400          LSL      r4,r1,r0
00001c  43a3              BICS     r3,r3,r4
00001e  4c01              LDR      r4,|L12.36|
000020  6023              STR      r3,[r4,#0]
                  |L12.34|
;;;328      }
;;;329    }
000022  bd10              POP      {r4,pc}
;;;330    
                          ENDP

                  |L12.36|
                          DCD      0x40007400
