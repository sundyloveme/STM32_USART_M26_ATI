; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\stm32f10x_rcc.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\stm32f10x_rcc.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\startup\arm -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\Libraries\STM32F10x_StdPeriph_Driver\src -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\USER -I..\MDK-ARM -IC:\Users\Administrator\Desktop\stm32-uart-chenlong\stm32-uart-chenlong\MDK-ARM\RTE -I"D:\Program Files\keil5\ARM\PACK\ARM\CMSIS\4.2.0\CMSIS\Include" -I"D:\Program Files\keil5\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0" -D__MICROLIB -D__UVISION_VERSION=514 -D_RTE_ -DSTM32F10X_MD --omf_browse=.\obj\stm32f10x_rcc.crf ..\Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_rcc.c]
                          THUMB

                          AREA ||i.RCC_ADCCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_ADCCLKConfig PROC
;;;764      */
;;;765    void RCC_ADCCLKConfig(uint32_t RCC_PCLK2)
000000  4601              MOV      r1,r0
;;;766    {
;;;767      uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;768      /* Check the parameters */
;;;769      assert_param(IS_RCC_ADCCLK(RCC_PCLK2));
;;;770      tmpreg = RCC->CFGR;
000004  4a03              LDR      r2,|L1.20|
000006  6850              LDR      r0,[r2,#4]
;;;771      /* Clear ADCPRE[1:0] bits */
;;;772      tmpreg &= CFGR_ADCPRE_Reset_Mask;
000008  f4204040          BIC      r0,r0,#0xc000
;;;773      /* Set ADCPRE[1:0] bits according to RCC_PCLK2 value */
;;;774      tmpreg |= RCC_PCLK2;
00000c  4308              ORRS     r0,r0,r1
;;;775      /* Store the new value */
;;;776      RCC->CFGR = tmpreg;
00000e  6050              STR      r0,[r2,#4]
;;;777    }
000010  4770              BX       lr
;;;778    
                          ENDP

000012  0000              DCW      0x0000
                  |L1.20|
                          DCD      0x40021000

                          AREA ||i.RCC_AHBPeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHBPeriphClockCmd PROC
;;;1062     */
;;;1063   void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
000000  b129              CBZ      r1,|L2.14|
;;;1064   {
;;;1065     /* Check the parameters */
;;;1066     assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
;;;1067     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1068   
;;;1069     if (NewState != DISABLE)
;;;1070     {
;;;1071       RCC->AHBENR |= RCC_AHBPeriph;
000002  4a06              LDR      r2,|L2.28|
000004  6952              LDR      r2,[r2,#0x14]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L2.28|
00000a  615a              STR      r2,[r3,#0x14]
00000c  e004              B        |L2.24|
                  |L2.14|
;;;1072     }
;;;1073     else
;;;1074     {
;;;1075       RCC->AHBENR &= ~RCC_AHBPeriph;
00000e  4a03              LDR      r2,|L2.28|
000010  6952              LDR      r2,[r2,#0x14]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L2.28|
000016  615a              STR      r2,[r3,#0x14]
                  |L2.24|
;;;1076     }
;;;1077   }
000018  4770              BX       lr
;;;1078   
                          ENDP

00001a  0000              DCW      0x0000
                  |L2.28|
                          DCD      0x40021000

                          AREA ||i.RCC_APB1PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphClockCmd PROC
;;;1124     */
;;;1125   void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L3.14|
;;;1126   {
;;;1127     /* Check the parameters */
;;;1128     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
;;;1129     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1130     if (NewState != DISABLE)
;;;1131     {
;;;1132       RCC->APB1ENR |= RCC_APB1Periph;
000002  4a06              LDR      r2,|L3.28|
000004  69d2              LDR      r2,[r2,#0x1c]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L3.28|
00000a  61da              STR      r2,[r3,#0x1c]
00000c  e004              B        |L3.24|
                  |L3.14|
;;;1133     }
;;;1134     else
;;;1135     {
;;;1136       RCC->APB1ENR &= ~RCC_APB1Periph;
00000e  4a03              LDR      r2,|L3.28|
000010  69d2              LDR      r2,[r2,#0x1c]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L3.28|
000016  61da              STR      r2,[r3,#0x1c]
                  |L3.24|
;;;1137     }
;;;1138   }
000018  4770              BX       lr
;;;1139   
                          ENDP

00001a  0000              DCW      0x0000
                  |L3.28|
                          DCD      0x40021000

                          AREA ||i.RCC_APB1PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphResetCmd PROC
;;;1214     */
;;;1215   void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L4.14|
;;;1216   {
;;;1217     /* Check the parameters */
;;;1218     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
;;;1219     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1220     if (NewState != DISABLE)
;;;1221     {
;;;1222       RCC->APB1RSTR |= RCC_APB1Periph;
000002  4a06              LDR      r2,|L4.28|
000004  6912              LDR      r2,[r2,#0x10]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L4.28|
00000a  611a              STR      r2,[r3,#0x10]
00000c  e004              B        |L4.24|
                  |L4.14|
;;;1223     }
;;;1224     else
;;;1225     {
;;;1226       RCC->APB1RSTR &= ~RCC_APB1Periph;
00000e  4a03              LDR      r2,|L4.28|
000010  6912              LDR      r2,[r2,#0x10]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L4.28|
000016  611a              STR      r2,[r3,#0x10]
                  |L4.24|
;;;1227     }
;;;1228   }
000018  4770              BX       lr
;;;1229   
                          ENDP

00001a  0000              DCW      0x0000
                  |L4.28|
                          DCD      0x40021000

                          AREA ||i.RCC_APB2PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphClockCmd PROC
;;;1093     */
;;;1094   void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L5.14|
;;;1095   {
;;;1096     /* Check the parameters */
;;;1097     assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
;;;1098     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1099     if (NewState != DISABLE)
;;;1100     {
;;;1101       RCC->APB2ENR |= RCC_APB2Periph;
000002  4a06              LDR      r2,|L5.28|
000004  6992              LDR      r2,[r2,#0x18]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L5.28|
00000a  619a              STR      r2,[r3,#0x18]
00000c  e004              B        |L5.24|
                  |L5.14|
;;;1102     }
;;;1103     else
;;;1104     {
;;;1105       RCC->APB2ENR &= ~RCC_APB2Periph;
00000e  4a03              LDR      r2,|L5.28|
000010  6992              LDR      r2,[r2,#0x18]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L5.28|
000016  619a              STR      r2,[r3,#0x18]
                  |L5.24|
;;;1106     }
;;;1107   }
000018  4770              BX       lr
;;;1108   
                          ENDP

00001a  0000              DCW      0x0000
                  |L5.28|
                          DCD      0x40021000

                          AREA ||i.RCC_APB2PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphResetCmd PROC
;;;1183     */
;;;1184   void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L6.14|
;;;1185   {
;;;1186     /* Check the parameters */
;;;1187     assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
;;;1188     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1189     if (NewState != DISABLE)
;;;1190     {
;;;1191       RCC->APB2RSTR |= RCC_APB2Periph;
000002  4a06              LDR      r2,|L6.28|
000004  68d2              LDR      r2,[r2,#0xc]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L6.28|
00000a  60da              STR      r2,[r3,#0xc]
00000c  e004              B        |L6.24|
                  |L6.14|
;;;1192     }
;;;1193     else
;;;1194     {
;;;1195       RCC->APB2RSTR &= ~RCC_APB2Periph;
00000e  4a03              LDR      r2,|L6.28|
000010  68d2              LDR      r2,[r2,#0xc]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L6.28|
000016  60da              STR      r2,[r3,#0xc]
                  |L6.24|
;;;1196     }
;;;1197   }
000018  4770              BX       lr
;;;1198   
                          ENDP

00001a  0000              DCW      0x0000
                  |L6.28|
                          DCD      0x40021000

                          AREA ||i.RCC_AdjustHSICalibrationValue||, CODE, READONLY, ALIGN=2

                  RCC_AdjustHSICalibrationValue PROC
;;;332      */
;;;333    void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue)
000000  4601              MOV      r1,r0
;;;334    {
;;;335      uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;336      /* Check the parameters */
;;;337      assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));
;;;338      tmpreg = RCC->CR;
000004  4a03              LDR      r2,|L7.20|
000006  6810              LDR      r0,[r2,#0]
;;;339      /* Clear HSITRIM[4:0] bits */
;;;340      tmpreg &= CR_HSITRIM_Mask;
000008  f02000f8          BIC      r0,r0,#0xf8
;;;341      /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
;;;342      tmpreg |= (uint32_t)HSICalibrationValue << 3;
00000c  ea4000c1          ORR      r0,r0,r1,LSL #3
;;;343      /* Store the new value */
;;;344      RCC->CR = tmpreg;
000010  6010              STR      r0,[r2,#0]
;;;345    }
000012  4770              BX       lr
;;;346    
                          ENDP

                  |L7.20|
                          DCD      0x40021000

                          AREA ||i.RCC_BackupResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_BackupResetCmd PROC
;;;1235     */
;;;1236   void RCC_BackupResetCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L8.8|
;;;1237   {
;;;1238     /* Check the parameters */
;;;1239     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1240     *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;1241   }
000004  4770              BX       lr
;;;1242   
                          ENDP

000006  0000              DCW      0x0000
                  |L8.8|
                          DCD      0x42420440

                          AREA ||i.RCC_ClearFlag||, CODE, READONLY, ALIGN=2

                  RCC_ClearFlag PROC
;;;1369     */
;;;1370   void RCC_ClearFlag(void)
000000  4803              LDR      r0,|L9.16|
;;;1371   {
;;;1372     /* Set RMVF bit to clear the reset flags */
;;;1373     RCC->CSR |= CSR_RMVF_Set;
000002  6a40              LDR      r0,[r0,#0x24]
000004  f0407080          ORR      r0,r0,#0x1000000
000008  4901              LDR      r1,|L9.16|
00000a  6248              STR      r0,[r1,#0x24]
;;;1374   }
00000c  4770              BX       lr
;;;1375   
                          ENDP

00000e  0000              DCW      0x0000
                  |L9.16|
                          DCD      0x40021000

                          AREA ||i.RCC_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  RCC_ClearITPendingBit PROC
;;;1446     */
;;;1447   void RCC_ClearITPendingBit(uint8_t RCC_IT)
000000  4901              LDR      r1,|L10.8|
;;;1448   {
;;;1449     /* Check the parameters */
;;;1450     assert_param(IS_RCC_CLEAR_IT(RCC_IT));
;;;1451   
;;;1452     /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
;;;1453        pending bits */
;;;1454     *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
000002  7288              STRB     r0,[r1,#0xa]
;;;1455   }
000004  4770              BX       lr
;;;1456   
                          ENDP

000006  0000              DCW      0x0000
                  |L10.8|
                          DCD      0x40021000

                          AREA ||i.RCC_ClockSecuritySystemCmd||, CODE, READONLY, ALIGN=2

                  RCC_ClockSecuritySystemCmd PROC
;;;1248     */
;;;1249   void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L11.8|
;;;1250   {
;;;1251     /* Check the parameters */
;;;1252     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1253     *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
000002  64c8              STR      r0,[r1,#0x4c]
;;;1254   }
000004  4770              BX       lr
;;;1255   
                          ENDP

000006  0000              DCW      0x0000
                  |L11.8|
                          DCD      0x42420000

                          AREA ||i.RCC_DeInit||, CODE, READONLY, ALIGN=2

                  RCC_DeInit PROC
;;;215      */
;;;216    void RCC_DeInit(void)
000000  480f              LDR      r0,|L12.64|
;;;217    {
;;;218      /* Set HSION bit */
;;;219      RCC->CR |= (uint32_t)0x00000001;
000002  6800              LDR      r0,[r0,#0]
000004  f0400001          ORR      r0,r0,#1
000008  490d              LDR      r1,|L12.64|
00000a  6008              STR      r0,[r1,#0]
;;;220    
;;;221      /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
;;;222    #ifndef STM32F10X_CL
;;;223      RCC->CFGR &= (uint32_t)0xF8FF0000;
00000c  4608              MOV      r0,r1
00000e  6840              LDR      r0,[r0,#4]
000010  490c              LDR      r1,|L12.68|
000012  4008              ANDS     r0,r0,r1
000014  490a              LDR      r1,|L12.64|
000016  6048              STR      r0,[r1,#4]
;;;224    #else
;;;225      RCC->CFGR &= (uint32_t)0xF0FF0000;
;;;226    #endif /* STM32F10X_CL */   
;;;227      
;;;228      /* Reset HSEON, CSSON and PLLON bits */
;;;229      RCC->CR &= (uint32_t)0xFEF6FFFF;
000018  4608              MOV      r0,r1
00001a  6800              LDR      r0,[r0,#0]
00001c  490a              LDR      r1,|L12.72|
00001e  4008              ANDS     r0,r0,r1
000020  4907              LDR      r1,|L12.64|
000022  6008              STR      r0,[r1,#0]
;;;230    
;;;231      /* Reset HSEBYP bit */
;;;232      RCC->CR &= (uint32_t)0xFFFBFFFF;
000024  4608              MOV      r0,r1
000026  6800              LDR      r0,[r0,#0]
000028  f4202080          BIC      r0,r0,#0x40000
00002c  6008              STR      r0,[r1,#0]
;;;233    
;;;234      /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
;;;235      RCC->CFGR &= (uint32_t)0xFF80FFFF;
00002e  4608              MOV      r0,r1
000030  6840              LDR      r0,[r0,#4]
000032  f42000fe          BIC      r0,r0,#0x7f0000
000036  6048              STR      r0,[r1,#4]
;;;236    
;;;237    #ifdef STM32F10X_CL
;;;238      /* Reset PLL2ON and PLL3ON bits */
;;;239      RCC->CR &= (uint32_t)0xEBFFFFFF;
;;;240    
;;;241      /* Disable all interrupts and clear pending bits  */
;;;242      RCC->CIR = 0x00FF0000;
;;;243    
;;;244      /* Reset CFGR2 register */
;;;245      RCC->CFGR2 = 0x00000000;
;;;246    #elif defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
;;;247      /* Disable all interrupts and clear pending bits  */
;;;248      RCC->CIR = 0x009F0000;
;;;249    
;;;250      /* Reset CFGR2 register */
;;;251      RCC->CFGR2 = 0x00000000;      
;;;252    #else
;;;253      /* Disable all interrupts and clear pending bits  */
;;;254      RCC->CIR = 0x009F0000;
000038  f44f001f          MOV      r0,#0x9f0000
00003c  6088              STR      r0,[r1,#8]
;;;255    #endif /* STM32F10X_CL */
;;;256    
;;;257    }
00003e  4770              BX       lr
;;;258    
                          ENDP

                  |L12.64|
                          DCD      0x40021000
                  |L12.68|
                          DCD      0xf8ff0000
                  |L12.72|
                          DCD      0xfef6ffff

                          AREA ||i.RCC_GetClocksFreq||, CODE, READONLY, ALIGN=2

                  RCC_GetClocksFreq PROC
;;;906      */
;;;907    void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
000000  b530              PUSH     {r4,r5,lr}
;;;908    {
;;;909      uint32_t tmp = 0, pllmull = 0, pllsource = 0, presc = 0;
000002  2100              MOVS     r1,#0
000004  2200              MOVS     r2,#0
000006  2400              MOVS     r4,#0
000008  2300              MOVS     r3,#0
;;;910    
;;;911    #ifdef  STM32F10X_CL
;;;912      uint32_t prediv1source = 0, prediv1factor = 0, prediv2factor = 0, pll2mull = 0;
;;;913    #endif /* STM32F10X_CL */
;;;914    
;;;915    #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
;;;916      uint32_t prediv1factor = 0;
;;;917    #endif
;;;918        
;;;919      /* Get SYSCLK source -------------------------------------------------------*/
;;;920      tmp = RCC->CFGR & CFGR_SWS_Mask;
00000a  4d2d              LDR      r5,|L13.192|
00000c  686d              LDR      r5,[r5,#4]
00000e  f005010c          AND      r1,r5,#0xc
;;;921      
;;;922      switch (tmp)
000012  b121              CBZ      r1,|L13.30|
000014  2904              CMP      r1,#4
000016  d005              BEQ      |L13.36|
000018  2908              CMP      r1,#8
00001a  d123              BNE      |L13.100|
00001c  e005              B        |L13.42|
                  |L13.30|
;;;923      {
;;;924        case 0x00:  /* HSI used as system clock */
;;;925          RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
00001e  4d29              LDR      r5,|L13.196|
000020  6005              STR      r5,[r0,#0]
;;;926          break;
000022  e022              B        |L13.106|
                  |L13.36|
;;;927        case 0x04:  /* HSE used as system clock */
;;;928          RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
000024  4d27              LDR      r5,|L13.196|
000026  6005              STR      r5,[r0,#0]
;;;929          break;
000028  e01f              B        |L13.106|
                  |L13.42|
;;;930        case 0x08:  /* PLL used as system clock */
;;;931    
;;;932          /* Get PLL clock source and multiplication factor ----------------------*/
;;;933          pllmull = RCC->CFGR & CFGR_PLLMull_Mask;
00002a  4d25              LDR      r5,|L13.192|
00002c  686d              LDR      r5,[r5,#4]
00002e  f4051270          AND      r2,r5,#0x3c0000
;;;934          pllsource = RCC->CFGR & CFGR_PLLSRC_Mask;
000032  4d23              LDR      r5,|L13.192|
000034  686d              LDR      r5,[r5,#4]
000036  f4053480          AND      r4,r5,#0x10000
;;;935          
;;;936    #ifndef STM32F10X_CL      
;;;937          pllmull = ( pllmull >> 18) + 2;
00003a  2502              MOVS     r5,#2
00003c  eb054292          ADD      r2,r5,r2,LSR #18
;;;938          
;;;939          if (pllsource == 0x00)
000040  b91c              CBNZ     r4,|L13.74|
;;;940          {/* HSI oscillator clock divided by 2 selected as PLL clock entry */
;;;941            RCC_Clocks->SYSCLK_Frequency = (HSI_VALUE >> 1) * pllmull;
000042  4d21              LDR      r5,|L13.200|
000044  4355              MULS     r5,r2,r5
000046  6005              STR      r5,[r0,#0]
000048  e00b              B        |L13.98|
                  |L13.74|
;;;942          }
;;;943          else
;;;944          {
;;;945     #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
;;;946           prediv1factor = (RCC->CFGR2 & CFGR2_PREDIV1) + 1;
;;;947           /* HSE oscillator clock selected as PREDIV1 clock entry */
;;;948           RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE / prediv1factor) * pllmull; 
;;;949     #else
;;;950            /* HSE selected as PLL clock entry */
;;;951            if ((RCC->CFGR & CFGR_PLLXTPRE_Mask) != (uint32_t)RESET)
00004a  4d1d              LDR      r5,|L13.192|
00004c  686d              LDR      r5,[r5,#4]
00004e  f4053500          AND      r5,r5,#0x20000
000052  b11d              CBZ      r5,|L13.92|
;;;952            {/* HSE oscillator clock divided by 2 */
;;;953              RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE >> 1) * pllmull;
000054  4d1c              LDR      r5,|L13.200|
000056  4355              MULS     r5,r2,r5
000058  6005              STR      r5,[r0,#0]
00005a  e002              B        |L13.98|
                  |L13.92|
;;;954            }
;;;955            else
;;;956            {
;;;957              RCC_Clocks->SYSCLK_Frequency = HSE_VALUE * pllmull;
00005c  4d19              LDR      r5,|L13.196|
00005e  4355              MULS     r5,r2,r5
000060  6005              STR      r5,[r0,#0]
                  |L13.98|
;;;958            }
;;;959     #endif
;;;960          }
;;;961    #else
;;;962          pllmull = pllmull >> 18;
;;;963          
;;;964          if (pllmull != 0x0D)
;;;965          {
;;;966             pllmull += 2;
;;;967          }
;;;968          else
;;;969          { /* PLL multiplication factor = PLL input clock * 6.5 */
;;;970            pllmull = 13 / 2; 
;;;971          }
;;;972                
;;;973          if (pllsource == 0x00)
;;;974          {/* HSI oscillator clock divided by 2 selected as PLL clock entry */
;;;975            RCC_Clocks->SYSCLK_Frequency = (HSI_VALUE >> 1) * pllmull;
;;;976          }
;;;977          else
;;;978          {/* PREDIV1 selected as PLL clock entry */
;;;979            
;;;980            /* Get PREDIV1 clock source and division factor */
;;;981            prediv1source = RCC->CFGR2 & CFGR2_PREDIV1SRC;
;;;982            prediv1factor = (RCC->CFGR2 & CFGR2_PREDIV1) + 1;
;;;983            
;;;984            if (prediv1source == 0)
;;;985            { /* HSE oscillator clock selected as PREDIV1 clock entry */
;;;986              RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE / prediv1factor) * pllmull;          
;;;987            }
;;;988            else
;;;989            {/* PLL2 clock selected as PREDIV1 clock entry */
;;;990              
;;;991              /* Get PREDIV2 division factor and PLL2 multiplication factor */
;;;992              prediv2factor = ((RCC->CFGR2 & CFGR2_PREDIV2) >> 4) + 1;
;;;993              pll2mull = ((RCC->CFGR2 & CFGR2_PLL2MUL) >> 8 ) + 2; 
;;;994              RCC_Clocks->SYSCLK_Frequency = (((HSE_VALUE / prediv2factor) * pll2mull) / prediv1factor) * pllmull;                         
;;;995            }
;;;996          }
;;;997    #endif /* STM32F10X_CL */ 
;;;998          break;
000062  e002              B        |L13.106|
                  |L13.100|
;;;999    
;;;1000       default:
;;;1001         RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
000064  4d17              LDR      r5,|L13.196|
000066  6005              STR      r5,[r0,#0]
;;;1002         break;
000068  bf00              NOP      
                  |L13.106|
00006a  bf00              NOP                            ;926
;;;1003     }
;;;1004   
;;;1005     /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
;;;1006     /* Get HCLK prescaler */
;;;1007     tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
00006c  4d14              LDR      r5,|L13.192|
00006e  686d              LDR      r5,[r5,#4]
000070  f00501f0          AND      r1,r5,#0xf0
;;;1008     tmp = tmp >> 4;
000074  0909              LSRS     r1,r1,#4
;;;1009     presc = APBAHBPrescTable[tmp];
000076  4d15              LDR      r5,|L13.204|
000078  5c6b              LDRB     r3,[r5,r1]
;;;1010     /* HCLK clock frequency */
;;;1011     RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
00007a  6805              LDR      r5,[r0,#0]
00007c  40dd              LSRS     r5,r5,r3
00007e  6045              STR      r5,[r0,#4]
;;;1012     /* Get PCLK1 prescaler */
;;;1013     tmp = RCC->CFGR & CFGR_PPRE1_Set_Mask;
000080  4d0f              LDR      r5,|L13.192|
000082  686d              LDR      r5,[r5,#4]
000084  f40561e0          AND      r1,r5,#0x700
;;;1014     tmp = tmp >> 8;
000088  0a09              LSRS     r1,r1,#8
;;;1015     presc = APBAHBPrescTable[tmp];
00008a  4d10              LDR      r5,|L13.204|
00008c  5c6b              LDRB     r3,[r5,r1]
;;;1016     /* PCLK1 clock frequency */
;;;1017     RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
00008e  6845              LDR      r5,[r0,#4]
000090  40dd              LSRS     r5,r5,r3
000092  6085              STR      r5,[r0,#8]
;;;1018     /* Get PCLK2 prescaler */
;;;1019     tmp = RCC->CFGR & CFGR_PPRE2_Set_Mask;
000094  4d0a              LDR      r5,|L13.192|
000096  686d              LDR      r5,[r5,#4]
000098  f4055160          AND      r1,r5,#0x3800
;;;1020     tmp = tmp >> 11;
00009c  0ac9              LSRS     r1,r1,#11
;;;1021     presc = APBAHBPrescTable[tmp];
00009e  4d0b              LDR      r5,|L13.204|
0000a0  5c6b              LDRB     r3,[r5,r1]
;;;1022     /* PCLK2 clock frequency */
;;;1023     RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
0000a2  6845              LDR      r5,[r0,#4]
0000a4  40dd              LSRS     r5,r5,r3
0000a6  60c5              STR      r5,[r0,#0xc]
;;;1024     /* Get ADCCLK prescaler */
;;;1025     tmp = RCC->CFGR & CFGR_ADCPRE_Set_Mask;
0000a8  4d05              LDR      r5,|L13.192|
0000aa  686d              LDR      r5,[r5,#4]
0000ac  f4054140          AND      r1,r5,#0xc000
;;;1026     tmp = tmp >> 14;
0000b0  0b89              LSRS     r1,r1,#14
;;;1027     presc = ADCPrescTable[tmp];
0000b2  4d07              LDR      r5,|L13.208|
0000b4  5c6b              LDRB     r3,[r5,r1]
;;;1028     /* ADCCLK clock frequency */
;;;1029     RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK2_Frequency / presc;
0000b6  68c5              LDR      r5,[r0,#0xc]
0000b8  fbb5f5f3          UDIV     r5,r5,r3
0000bc  6105              STR      r5,[r0,#0x10]
;;;1030   }
0000be  bd30              POP      {r4,r5,pc}
;;;1031   
                          ENDP

                  |L13.192|
                          DCD      0x40021000
                  |L13.196|
                          DCD      0x007a1200
                  |L13.200|
                          DCD      0x003d0900
                  |L13.204|
                          DCD      APBAHBPrescTable
                  |L13.208|
                          DCD      ADCPrescTable

                          AREA ||i.RCC_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  RCC_GetFlagStatus PROC
;;;1324     */
;;;1325   FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)
000000  b510              PUSH     {r4,lr}
;;;1326   {
000002  4601              MOV      r1,r0
;;;1327     uint32_t tmp = 0;
000004  2200              MOVS     r2,#0
;;;1328     uint32_t statusreg = 0;
000006  2300              MOVS     r3,#0
;;;1329     FlagStatus bitstatus = RESET;
000008  2000              MOVS     r0,#0
;;;1330     /* Check the parameters */
;;;1331     assert_param(IS_RCC_FLAG(RCC_FLAG));
;;;1332   
;;;1333     /* Get the RCC register index */
;;;1334     tmp = RCC_FLAG >> 5;
00000a  114a              ASRS     r2,r1,#5
;;;1335     if (tmp == 1)               /* The flag to check is in CR register */
00000c  2a01              CMP      r2,#1
00000e  d102              BNE      |L14.22|
;;;1336     {
;;;1337       statusreg = RCC->CR;
000010  4c09              LDR      r4,|L14.56|
000012  6823              LDR      r3,[r4,#0]
000014  e006              B        |L14.36|
                  |L14.22|
;;;1338     }
;;;1339     else if (tmp == 2)          /* The flag to check is in BDCR register */
000016  2a02              CMP      r2,#2
000018  d102              BNE      |L14.32|
;;;1340     {
;;;1341       statusreg = RCC->BDCR;
00001a  4c07              LDR      r4,|L14.56|
00001c  6a23              LDR      r3,[r4,#0x20]
00001e  e001              B        |L14.36|
                  |L14.32|
;;;1342     }
;;;1343     else                       /* The flag to check is in CSR register */
;;;1344     {
;;;1345       statusreg = RCC->CSR;
000020  4c05              LDR      r4,|L14.56|
000022  6a63              LDR      r3,[r4,#0x24]
                  |L14.36|
;;;1346     }
;;;1347   
;;;1348     /* Get the flag position */
;;;1349     tmp = RCC_FLAG & FLAG_Mask;
000024  f001021f          AND      r2,r1,#0x1f
;;;1350     if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
000028  2401              MOVS     r4,#1
00002a  4094              LSLS     r4,r4,r2
00002c  401c              ANDS     r4,r4,r3
00002e  b10c              CBZ      r4,|L14.52|
;;;1351     {
;;;1352       bitstatus = SET;
000030  2001              MOVS     r0,#1
000032  e000              B        |L14.54|
                  |L14.52|
;;;1353     }
;;;1354     else
;;;1355     {
;;;1356       bitstatus = RESET;
000034  2000              MOVS     r0,#0
                  |L14.54|
;;;1357     }
;;;1358   
;;;1359     /* Return the flag status */
;;;1360     return bitstatus;
;;;1361   }
000036  bd10              POP      {r4,pc}
;;;1362   
                          ENDP

                  |L14.56|
                          DCD      0x40021000

                          AREA ||i.RCC_GetITStatus||, CODE, READONLY, ALIGN=2

                  RCC_GetITStatus PROC
;;;1400     */
;;;1401   ITStatus RCC_GetITStatus(uint8_t RCC_IT)
000000  4601              MOV      r1,r0
;;;1402   {
;;;1403     ITStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1404     /* Check the parameters */
;;;1405     assert_param(IS_RCC_GET_IT(RCC_IT));
;;;1406   
;;;1407     /* Check the status of the specified RCC interrupt */
;;;1408     if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
000004  4a03              LDR      r2,|L15.20|
000006  6892              LDR      r2,[r2,#8]
000008  400a              ANDS     r2,r2,r1
00000a  b10a              CBZ      r2,|L15.16|
;;;1409     {
;;;1410       bitstatus = SET;
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L15.18|
                  |L15.16|
;;;1411     }
;;;1412     else
;;;1413     {
;;;1414       bitstatus = RESET;
000010  2000              MOVS     r0,#0
                  |L15.18|
;;;1415     }
;;;1416   
;;;1417     /* Return the RCC_IT status */
;;;1418     return  bitstatus;
;;;1419   }
000012  4770              BX       lr
;;;1420   
                          ENDP

                  |L15.20|
                          DCD      0x40021000

                          AREA ||i.RCC_GetSYSCLKSource||, CODE, READONLY, ALIGN=2

                  RCC_GetSYSCLKSource PROC
;;;585      */
;;;586    uint8_t RCC_GetSYSCLKSource(void)
000000  4802              LDR      r0,|L16.12|
;;;587    {
;;;588      return ((uint8_t)(RCC->CFGR & CFGR_SWS_Mask));
000002  6840              LDR      r0,[r0,#4]
000004  f000000c          AND      r0,r0,#0xc
;;;589    }
000008  4770              BX       lr
;;;590    
                          ENDP

00000a  0000              DCW      0x0000
                  |L16.12|
                          DCD      0x40021000

                          AREA ||i.RCC_HCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_HCLKConfig PROC
;;;606      */
;;;607    void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
000000  4601              MOV      r1,r0
;;;608    {
;;;609      uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;610      /* Check the parameters */
;;;611      assert_param(IS_RCC_HCLK(RCC_SYSCLK));
;;;612      tmpreg = RCC->CFGR;
000004  4a03              LDR      r2,|L17.20|
000006  6850              LDR      r0,[r2,#4]
;;;613      /* Clear HPRE[3:0] bits */
;;;614      tmpreg &= CFGR_HPRE_Reset_Mask;
000008  f02000f0          BIC      r0,r0,#0xf0
;;;615      /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
;;;616      tmpreg |= RCC_SYSCLK;
00000c  4308              ORRS     r0,r0,r1
;;;617      /* Store the new value */
;;;618      RCC->CFGR = tmpreg;
00000e  6050              STR      r0,[r2,#4]
;;;619    }
000010  4770              BX       lr
;;;620    
                          ENDP

000012  0000              DCW      0x0000
                  |L17.20|
                          DCD      0x40021000

                          AREA ||i.RCC_HSEConfig||, CODE, READONLY, ALIGN=2

                  RCC_HSEConfig PROC
;;;268      */
;;;269    void RCC_HSEConfig(uint32_t RCC_HSE)
000000  4911              LDR      r1,|L18.72|
;;;270    {
;;;271      /* Check the parameters */
;;;272      assert_param(IS_RCC_HSE(RCC_HSE));
;;;273      /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
;;;274      /* Reset HSEON bit */
;;;275      RCC->CR &= CR_HSEON_Reset;
000002  6809              LDR      r1,[r1,#0]
000004  f4213180          BIC      r1,r1,#0x10000
000008  4a0f              LDR      r2,|L18.72|
00000a  6011              STR      r1,[r2,#0]
;;;276      /* Reset HSEBYP bit */
;;;277      RCC->CR &= CR_HSEBYP_Reset;
00000c  4611              MOV      r1,r2
00000e  6809              LDR      r1,[r1,#0]
000010  f4212180          BIC      r1,r1,#0x40000
000014  6011              STR      r1,[r2,#0]
;;;278      /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
;;;279      switch(RCC_HSE)
000016  f5b03f80          CMP      r0,#0x10000
00001a  d003              BEQ      |L18.36|
00001c  f5b02f80          CMP      r0,#0x40000
000020  d10e              BNE      |L18.64|
000022  e006              B        |L18.50|
                  |L18.36|
;;;280      {
;;;281        case RCC_HSE_ON:
;;;282          /* Set HSEON bit */
;;;283          RCC->CR |= CR_HSEON_Set;
000024  4908              LDR      r1,|L18.72|
000026  6809              LDR      r1,[r1,#0]
000028  f4413180          ORR      r1,r1,#0x10000
00002c  4a06              LDR      r2,|L18.72|
00002e  6011              STR      r1,[r2,#0]
;;;284          break;
000030  e007              B        |L18.66|
                  |L18.50|
;;;285          
;;;286        case RCC_HSE_Bypass:
;;;287          /* Set HSEBYP and HSEON bits */
;;;288          RCC->CR |= CR_HSEBYP_Set | CR_HSEON_Set;
000032  4905              LDR      r1,|L18.72|
000034  6809              LDR      r1,[r1,#0]
000036  f44121a0          ORR      r1,r1,#0x50000
00003a  4a03              LDR      r2,|L18.72|
00003c  6011              STR      r1,[r2,#0]
;;;289          break;
00003e  e000              B        |L18.66|
                  |L18.64|
;;;290          
;;;291        default:
;;;292          break;
000040  bf00              NOP      
                  |L18.66|
000042  bf00              NOP                            ;284
;;;293      }
;;;294    }
000044  4770              BX       lr
;;;295    
                          ENDP

000046  0000              DCW      0x0000
                  |L18.72|
                          DCD      0x40021000

                          AREA ||i.RCC_HSICmd||, CODE, READONLY, ALIGN=2

                  RCC_HSICmd PROC
;;;352      */
;;;353    void RCC_HSICmd(FunctionalState NewState)
000000  4901              LDR      r1,|L19.8|
;;;354    {
;;;355      /* Check the parameters */
;;;356      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;357      *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;358    }
000004  4770              BX       lr
;;;359    
                          ENDP

000006  0000              DCW      0x0000
                  |L19.8|
                          DCD      0x42420000

                          AREA ||i.RCC_ITConfig||, CODE, READONLY, ALIGN=2

                  RCC_ITConfig PROC
;;;698      */
;;;699    void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
000000  b129              CBZ      r1,|L20.14|
;;;700    {
;;;701      /* Check the parameters */
;;;702      assert_param(IS_RCC_IT(RCC_IT));
;;;703      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;704      if (NewState != DISABLE)
;;;705      {
;;;706        /* Perform Byte access to RCC_CIR bits to enable the selected interrupts */
;;;707        *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
000002  4a06              LDR      r2,|L20.28|
000004  7a52              LDRB     r2,[r2,#9]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L20.28|
00000a  725a              STRB     r2,[r3,#9]
00000c  e004              B        |L20.24|
                  |L20.14|
;;;708      }
;;;709      else
;;;710      {
;;;711        /* Perform Byte access to RCC_CIR bits to disable the selected interrupts */
;;;712        *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
00000e  4a03              LDR      r2,|L20.28|
000010  7a52              LDRB     r2,[r2,#9]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L20.28|
000016  725a              STRB     r2,[r3,#9]
                  |L20.24|
;;;713      }
;;;714    }
000018  4770              BX       lr
;;;715    
                          ENDP

00001a  0000              DCW      0x0000
                  |L20.28|
                          DCD      0x40021000

                          AREA ||i.RCC_LSEConfig||, CODE, READONLY, ALIGN=2

                  RCC_LSEConfig PROC
;;;827      */
;;;828    void RCC_LSEConfig(uint8_t RCC_LSE)
000000  2100              MOVS     r1,#0
;;;829    {
;;;830      /* Check the parameters */
;;;831      assert_param(IS_RCC_LSE(RCC_LSE));
;;;832      /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
;;;833      /* Reset LSEON bit */
;;;834      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
000002  4a0b              LDR      r2,|L21.48|
000004  7011              STRB     r1,[r2,#0]
;;;835      /* Reset LSEBYP bit */
;;;836      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
000006  4a0a              LDR      r2,|L21.48|
000008  3a20              SUBS     r2,r2,#0x20
00000a  f8821020          STRB     r1,[r2,#0x20]
;;;837      /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
;;;838      switch(RCC_LSE)
00000e  2801              CMP      r0,#1
000010  d002              BEQ      |L21.24|
000012  2804              CMP      r0,#4
000014  d108              BNE      |L21.40|
000016  e003              B        |L21.32|
                  |L21.24|
;;;839      {
;;;840        case RCC_LSE_ON:
;;;841          /* Set LSEON bit */
;;;842          *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
000018  2101              MOVS     r1,#1
00001a  4a05              LDR      r2,|L21.48|
00001c  7011              STRB     r1,[r2,#0]
;;;843          break;
00001e  e004              B        |L21.42|
                  |L21.32|
;;;844          
;;;845        case RCC_LSE_Bypass:
;;;846          /* Set LSEBYP and LSEON bits */
;;;847          *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
000020  2105              MOVS     r1,#5
000022  4a03              LDR      r2,|L21.48|
000024  7011              STRB     r1,[r2,#0]
;;;848          break;            
000026  e000              B        |L21.42|
                  |L21.40|
;;;849          
;;;850        default:
;;;851          break;      
000028  bf00              NOP      
                  |L21.42|
00002a  bf00              NOP                            ;843
;;;852      }
;;;853    }
00002c  4770              BX       lr
;;;854    
                          ENDP

00002e  0000              DCW      0x0000
                  |L21.48|
                          DCD      0x40021020

                          AREA ||i.RCC_LSICmd||, CODE, READONLY, ALIGN=2

                  RCC_LSICmd PROC
;;;860      */
;;;861    void RCC_LSICmd(FunctionalState NewState)
000000  4901              LDR      r1,|L22.8|
;;;862    {
;;;863      /* Check the parameters */
;;;864      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;865      *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;866    }
000004  4770              BX       lr
;;;867    
                          ENDP

000006  0000              DCW      0x0000
                  |L22.8|
                          DCD      0x42420480

                          AREA ||i.RCC_MCOConfig||, CODE, READONLY, ALIGN=2

                  RCC_MCOConfig PROC
;;;1280     */
;;;1281   void RCC_MCOConfig(uint8_t RCC_MCO)
000000  4901              LDR      r1,|L23.8|
;;;1282   {
;;;1283     /* Check the parameters */
;;;1284     assert_param(IS_RCC_MCO(RCC_MCO));
;;;1285   
;;;1286     /* Perform Byte access to MCO bits to select the MCO source */
;;;1287     *(__IO uint8_t *) CFGR_BYTE4_ADDRESS = RCC_MCO;
000002  71c8              STRB     r0,[r1,#7]
;;;1288   }
000004  4770              BX       lr
;;;1289   
                          ENDP

000006  0000              DCW      0x0000
                  |L23.8|
                          DCD      0x40021000

                          AREA ||i.RCC_PCLK1Config||, CODE, READONLY, ALIGN=2

                  RCC_PCLK1Config PROC
;;;632      */
;;;633    void RCC_PCLK1Config(uint32_t RCC_HCLK)
000000  4601              MOV      r1,r0
;;;634    {
;;;635      uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;636      /* Check the parameters */
;;;637      assert_param(IS_RCC_PCLK(RCC_HCLK));
;;;638      tmpreg = RCC->CFGR;
000004  4a03              LDR      r2,|L24.20|
000006  6850              LDR      r0,[r2,#4]
;;;639      /* Clear PPRE1[2:0] bits */
;;;640      tmpreg &= CFGR_PPRE1_Reset_Mask;
000008  f42060e0          BIC      r0,r0,#0x700
;;;641      /* Set PPRE1[2:0] bits according to RCC_HCLK value */
;;;642      tmpreg |= RCC_HCLK;
00000c  4308              ORRS     r0,r0,r1
;;;643      /* Store the new value */
;;;644      RCC->CFGR = tmpreg;
00000e  6050              STR      r0,[r2,#4]
;;;645    }
000010  4770              BX       lr
;;;646    
                          ENDP

000012  0000              DCW      0x0000
                  |L24.20|
                          DCD      0x40021000

                          AREA ||i.RCC_PCLK2Config||, CODE, READONLY, ALIGN=2

                  RCC_PCLK2Config PROC
;;;658      */
;;;659    void RCC_PCLK2Config(uint32_t RCC_HCLK)
000000  4601              MOV      r1,r0
;;;660    {
;;;661      uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;662      /* Check the parameters */
;;;663      assert_param(IS_RCC_PCLK(RCC_HCLK));
;;;664      tmpreg = RCC->CFGR;
000004  4a03              LDR      r2,|L25.20|
000006  6850              LDR      r0,[r2,#4]
;;;665      /* Clear PPRE2[2:0] bits */
;;;666      tmpreg &= CFGR_PPRE2_Reset_Mask;
000008  f4205060          BIC      r0,r0,#0x3800
;;;667      /* Set PPRE2[2:0] bits according to RCC_HCLK value */
;;;668      tmpreg |= RCC_HCLK << 3;
00000c  ea4000c1          ORR      r0,r0,r1,LSL #3
;;;669      /* Store the new value */
;;;670      RCC->CFGR = tmpreg;
000010  6050              STR      r0,[r2,#4]
;;;671    }
000012  4770              BX       lr
;;;672    
                          ENDP

                  |L25.20|
                          DCD      0x40021000

                          AREA ||i.RCC_PLLCmd||, CODE, READONLY, ALIGN=2

                  RCC_PLLCmd PROC
;;;399      */
;;;400    void RCC_PLLCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L26.8|
;;;401    {
;;;402      /* Check the parameters */
;;;403      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;404    
;;;405      *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
000002  6608              STR      r0,[r1,#0x60]
;;;406    }
000004  4770              BX       lr
;;;407    
                          ENDP

000006  0000              DCW      0x0000
                  |L26.8|
                          DCD      0x42420000

                          AREA ||i.RCC_PLLConfig||, CODE, READONLY, ALIGN=2

                  RCC_PLLConfig PROC
;;;376      */
;;;377    void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t RCC_PLLMul)
000000  4602              MOV      r2,r0
;;;378    {
;;;379      uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;380    
;;;381      /* Check the parameters */
;;;382      assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
;;;383      assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));
;;;384    
;;;385      tmpreg = RCC->CFGR;
000004  4b04              LDR      r3,|L27.24|
000006  6858              LDR      r0,[r3,#4]
;;;386      /* Clear PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
;;;387      tmpreg &= CFGR_PLL_Mask;
000008  f420107c          BIC      r0,r0,#0x3f0000
;;;388      /* Set the PLL configuration bits */
;;;389      tmpreg |= RCC_PLLSource | RCC_PLLMul;
00000c  ea420301          ORR      r3,r2,r1
000010  4318              ORRS     r0,r0,r3
;;;390      /* Store the new value */
;;;391      RCC->CFGR = tmpreg;
000012  4b01              LDR      r3,|L27.24|
000014  6058              STR      r0,[r3,#4]
;;;392    }
000016  4770              BX       lr
;;;393    
                          ENDP

                  |L27.24|
                          DCD      0x40021000

                          AREA ||i.RCC_RTCCLKCmd||, CODE, READONLY, ALIGN=2

                  RCC_RTCCLKCmd PROC
;;;891      */
;;;892    void RCC_RTCCLKCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L28.8|
;;;893    {
;;;894      /* Check the parameters */
;;;895      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;896      *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;897    }
000004  4770              BX       lr
;;;898    
                          ENDP

000006  0000              DCW      0x0000
                  |L28.8|
                          DCD      0x4242043c

                          AREA ||i.RCC_RTCCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_RTCCLKConfig PROC
;;;877      */
;;;878    void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
000000  4902              LDR      r1,|L29.12|
;;;879    {
;;;880      /* Check the parameters */
;;;881      assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
;;;882      /* Select the RTC clock source */
;;;883      RCC->BDCR |= RCC_RTCCLKSource;
000002  6a09              LDR      r1,[r1,#0x20]
000004  4301              ORRS     r1,r1,r0
000006  4a01              LDR      r2,|L29.12|
000008  6211              STR      r1,[r2,#0x20]
;;;884    }
00000a  4770              BX       lr
;;;885    
                          ENDP

                  |L29.12|
                          DCD      0x40021000

                          AREA ||i.RCC_SYSCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_SYSCLKConfig PROC
;;;562      */
;;;563    void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
000000  4601              MOV      r1,r0
;;;564    {
;;;565      uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;566      /* Check the parameters */
;;;567      assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
;;;568      tmpreg = RCC->CFGR;
000004  4a03              LDR      r2,|L30.20|
000006  6850              LDR      r0,[r2,#4]
;;;569      /* Clear SW[1:0] bits */
;;;570      tmpreg &= CFGR_SW_Mask;
000008  f0200003          BIC      r0,r0,#3
;;;571      /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
;;;572      tmpreg |= RCC_SYSCLKSource;
00000c  4308              ORRS     r0,r0,r1
;;;573      /* Store the new value */
;;;574      RCC->CFGR = tmpreg;
00000e  6050              STR      r0,[r2,#4]
;;;575    }
000010  4770              BX       lr
;;;576    
                          ENDP

000012  0000              DCW      0x0000
                  |L30.20|
                          DCD      0x40021000

                          AREA ||i.RCC_USBCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_USBCLKConfig PROC
;;;726      */
;;;727    void RCC_USBCLKConfig(uint32_t RCC_USBCLKSource)
000000  4901              LDR      r1,|L31.8|
;;;728    {
;;;729      /* Check the parameters */
;;;730      assert_param(IS_RCC_USBCLK_SOURCE(RCC_USBCLKSource));
;;;731    
;;;732      *(__IO uint32_t *) CFGR_USBPRE_BB = RCC_USBCLKSource;
000002  6008              STR      r0,[r1,#0]
;;;733    }
000004  4770              BX       lr
;;;734    #else
                          ENDP

000006  0000              DCW      0x0000
                  |L31.8|
                          DCD      0x424200d8

                          AREA ||i.RCC_WaitForHSEStartUp||, CODE, READONLY, ALIGN=1

                  RCC_WaitForHSEStartUp PROC
;;;302      */
;;;303    ErrorStatus RCC_WaitForHSEStartUp(void)
000000  b538              PUSH     {r3-r5,lr}
;;;304    {
;;;305      __IO uint32_t StartUpCounter = 0;
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
;;;306      ErrorStatus status = ERROR;
000006  2400              MOVS     r4,#0
;;;307      FlagStatus HSEStatus = RESET;
000008  2500              MOVS     r5,#0
;;;308      
;;;309      /* Wait till HSE is ready and if Time out is reached exit */
;;;310      do
00000a  bf00              NOP      
                  |L32.12|
;;;311      {
;;;312        HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
00000c  2031              MOVS     r0,#0x31
00000e  f7fffffe          BL       RCC_GetFlagStatus
000012  4605              MOV      r5,r0
;;;313        StartUpCounter++;  
000014  9800              LDR      r0,[sp,#0]
000016  1c40              ADDS     r0,r0,#1
000018  9000              STR      r0,[sp,#0]
;;;314      } while((StartUpCounter != HSE_STARTUP_TIMEOUT) && (HSEStatus == RESET));
00001a  9800              LDR      r0,[sp,#0]
00001c  f5b06fa0          CMP      r0,#0x500
000020  d001              BEQ      |L32.38|
000022  2d00              CMP      r5,#0
000024  d0f2              BEQ      |L32.12|
                  |L32.38|
;;;315      
;;;316      if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
000026  2031              MOVS     r0,#0x31
000028  f7fffffe          BL       RCC_GetFlagStatus
00002c  b108              CBZ      r0,|L32.50|
;;;317      {
;;;318        status = SUCCESS;
00002e  2401              MOVS     r4,#1
000030  e000              B        |L32.52|
                  |L32.50|
;;;319      }
;;;320      else
;;;321      {
;;;322        status = ERROR;
000032  2400              MOVS     r4,#0
                  |L32.52|
;;;323      }  
;;;324      return (status);
000034  4620              MOV      r0,r4
;;;325    }
000036  bd38              POP      {r3-r5,pc}
;;;326    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=0

                  APBAHBPrescTable
000000  00000000          DCB      0x00,0x00,0x00,0x00
000004  01020304          DCB      0x01,0x02,0x03,0x04
000008  01020304          DCB      0x01,0x02,0x03,0x04
00000c  06070809          DCB      0x06,0x07,0x08,0x09
                  ADCPrescTable
000010  02040608          DCB      0x02,0x04,0x06,0x08
