; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\stm32f10x_flash.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\stm32f10x_flash.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\startup\arm -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\Libraries\STM32F10x_StdPeriph_Driver\src -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\USER -I..\MDK-ARM -IC:\Users\Administrator\Desktop\stm32-uart-chenlong\stm32-uart-chenlong\MDK-ARM\RTE -I"D:\Program Files\keil5\ARM\PACK\ARM\CMSIS\4.2.0\CMSIS\Include" -I"D:\Program Files\keil5\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0" -D__MICROLIB -D__UVISION_VERSION=514 -D_RTE_ -DSTM32F10X_MD --omf_browse=.\obj\stm32f10x_flash.crf ..\Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_flash.c]
                          THUMB

                          AREA ||i.FLASH_ClearFlag||, CODE, READONLY, ALIGN=2

                  FLASH_ClearFlag PROC
;;;1441     */
;;;1442   void FLASH_ClearFlag(uint32_t FLASH_FLAG)
000000  4901              LDR      r1,|L1.8|
;;;1443   {
;;;1444   #ifdef STM32F10X_XL
;;;1445     /* Check the parameters */
;;;1446     assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG)) ;
;;;1447   
;;;1448     if((FLASH_FLAG & 0x80000000) != 0x0)
;;;1449     {
;;;1450       /* Clear the flags */
;;;1451       FLASH->SR2 = FLASH_FLAG;
;;;1452     }
;;;1453     else
;;;1454     {
;;;1455       /* Clear the flags */
;;;1456       FLASH->SR = FLASH_FLAG;
;;;1457     }  
;;;1458   
;;;1459   #else
;;;1460     /* Check the parameters */
;;;1461     assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG)) ;
;;;1462     
;;;1463     /* Clear the flags */
;;;1464     FLASH->SR = FLASH_FLAG;
000002  60c8              STR      r0,[r1,#0xc]
;;;1465   #endif /* STM32F10X_XL */
;;;1466   }
000004  4770              BX       lr
;;;1467   
                          ENDP

000006  0000              DCW      0x0000
                  |L1.8|
                          DCD      0x40022000

                          AREA ||i.FLASH_EnableWriteProtection||, CODE, READONLY, ALIGN=2

                  FLASH_EnableWriteProtection PROC
;;;973      */
;;;974    FLASH_Status FLASH_EnableWriteProtection(uint32_t FLASH_Pages)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;975    {
000004  4604              MOV      r4,r0
;;;976      uint16_t WRP0_Data = 0xFFFF, WRP1_Data = 0xFFFF, WRP2_Data = 0xFFFF, WRP3_Data = 0xFFFF;
000006  f64f76ff          MOV      r6,#0xffff
00000a  4637              MOV      r7,r6
00000c  46b0              MOV      r8,r6
00000e  46b1              MOV      r9,r6
;;;977      
;;;978      FLASH_Status status = FLASH_COMPLETE;
000010  2504              MOVS     r5,#4
;;;979      
;;;980      /* Check the parameters */
;;;981      assert_param(IS_FLASH_WRPROT_PAGE(FLASH_Pages));
;;;982      
;;;983      FLASH_Pages = (uint32_t)(~FLASH_Pages);
000012  43e4              MVNS     r4,r4
;;;984      WRP0_Data = (uint16_t)(FLASH_Pages & WRP0_Mask);
000014  b2e6              UXTB     r6,r4
;;;985      WRP1_Data = (uint16_t)((FLASH_Pages & WRP1_Mask) >> 8);
000016  f3c42707          UBFX     r7,r4,#8,#8
;;;986      WRP2_Data = (uint16_t)((FLASH_Pages & WRP2_Mask) >> 16);
00001a  f3c44807          UBFX     r8,r4,#16,#8
;;;987      WRP3_Data = (uint16_t)((FLASH_Pages & WRP3_Mask) >> 24);
00001e  ea4f6914          LSR      r9,r4,#24
;;;988      
;;;989      /* Wait for last operation to be completed */
;;;990      status = FLASH_WaitForLastOperation(ProgramTimeout);
000022  02e8              LSLS     r0,r5,#11
000024  f7fffffe          BL       FLASH_WaitForLastOperation
000028  4605              MOV      r5,r0
;;;991      
;;;992      if(status == FLASH_COMPLETE)
00002a  2d04              CMP      r5,#4
00002c  d13f              BNE      |L2.174|
;;;993      {
;;;994        /* Authorizes the small information block programming */
;;;995        FLASH->OPTKEYR = FLASH_KEY1;
00002e  4821              LDR      r0,|L2.180|
000030  4921              LDR      r1,|L2.184|
000032  6088              STR      r0,[r1,#8]
;;;996        FLASH->OPTKEYR = FLASH_KEY2;
000034  4821              LDR      r0,|L2.188|
000036  6088              STR      r0,[r1,#8]
;;;997        FLASH->CR |= CR_OPTPG_Set;
000038  4608              MOV      r0,r1
00003a  6900              LDR      r0,[r0,#0x10]
00003c  f0400010          ORR      r0,r0,#0x10
000040  6108              STR      r0,[r1,#0x10]
;;;998        if(WRP0_Data != 0xFF)
000042  2eff              CMP      r6,#0xff
000044  d005              BEQ      |L2.82|
;;;999        {
;;;1000         OB->WRP0 = WRP0_Data;
000046  481e              LDR      r0,|L2.192|
000048  8006              STRH     r6,[r0,#0]
;;;1001         
;;;1002         /* Wait for last operation to be completed */
;;;1003         status = FLASH_WaitForLastOperation(ProgramTimeout);
00004a  02e8              LSLS     r0,r5,#11
00004c  f7fffffe          BL       FLASH_WaitForLastOperation
000050  4605              MOV      r5,r0
                  |L2.82|
;;;1004       }
;;;1005       if((status == FLASH_COMPLETE) && (WRP1_Data != 0xFF))
000052  2d04              CMP      r5,#4
000054  d108              BNE      |L2.104|
000056  2fff              CMP      r7,#0xff
000058  d006              BEQ      |L2.104|
;;;1006       {
;;;1007         OB->WRP1 = WRP1_Data;
00005a  4819              LDR      r0,|L2.192|
00005c  1c80              ADDS     r0,r0,#2
00005e  8007              STRH     r7,[r0,#0]
;;;1008         
;;;1009         /* Wait for last operation to be completed */
;;;1010         status = FLASH_WaitForLastOperation(ProgramTimeout);
000060  02e8              LSLS     r0,r5,#11
000062  f7fffffe          BL       FLASH_WaitForLastOperation
000066  4605              MOV      r5,r0
                  |L2.104|
;;;1011       }
;;;1012       if((status == FLASH_COMPLETE) && (WRP2_Data != 0xFF))
000068  2d04              CMP      r5,#4
00006a  d10a              BNE      |L2.130|
00006c  f1b80fff          CMP      r8,#0xff
000070  d007              BEQ      |L2.130|
;;;1013       {
;;;1014         OB->WRP2 = WRP2_Data;
000072  4813              LDR      r0,|L2.192|
000074  1d00              ADDS     r0,r0,#4
000076  f8a08000          STRH     r8,[r0,#0]
;;;1015         
;;;1016         /* Wait for last operation to be completed */
;;;1017         status = FLASH_WaitForLastOperation(ProgramTimeout);
00007a  02e8              LSLS     r0,r5,#11
00007c  f7fffffe          BL       FLASH_WaitForLastOperation
000080  4605              MOV      r5,r0
                  |L2.130|
;;;1018       }
;;;1019       
;;;1020       if((status == FLASH_COMPLETE)&& (WRP3_Data != 0xFF))
000082  2d04              CMP      r5,#4
000084  d10a              BNE      |L2.156|
000086  f1b90fff          CMP      r9,#0xff
00008a  d007              BEQ      |L2.156|
;;;1021       {
;;;1022         OB->WRP3 = WRP3_Data;
00008c  480c              LDR      r0,|L2.192|
00008e  1d80              ADDS     r0,r0,#6
000090  f8a09000          STRH     r9,[r0,#0]
;;;1023        
;;;1024         /* Wait for last operation to be completed */
;;;1025         status = FLASH_WaitForLastOperation(ProgramTimeout);
000094  02e8              LSLS     r0,r5,#11
000096  f7fffffe          BL       FLASH_WaitForLastOperation
00009a  4605              MOV      r5,r0
                  |L2.156|
;;;1026       }
;;;1027             
;;;1028       if(status != FLASH_TIMEOUT)
00009c  2d05              CMP      r5,#5
00009e  d006              BEQ      |L2.174|
;;;1029       {
;;;1030         /* if the program operation is completed, disable the OPTPG Bit */
;;;1031         FLASH->CR &= CR_OPTPG_Reset;
0000a0  4805              LDR      r0,|L2.184|
0000a2  6900              LDR      r0,[r0,#0x10]
0000a4  f64171ef          MOV      r1,#0x1fef
0000a8  4008              ANDS     r0,r0,r1
0000aa  4903              LDR      r1,|L2.184|
0000ac  6108              STR      r0,[r1,#0x10]
                  |L2.174|
;;;1032       }
;;;1033     } 
;;;1034     /* Return the write protection operation Status */
;;;1035     return status;       
0000ae  4628              MOV      r0,r5
;;;1036   }
0000b0  e8bd83f0          POP      {r4-r9,pc}
;;;1037   
                          ENDP

                  |L2.180|
                          DCD      0x45670123
                  |L2.184|
                          DCD      0x40022000
                  |L2.188|
                          DCD      0xcdef89ab
                  |L2.192|
                          DCD      0x1ffff808

                          AREA ||i.FLASH_EraseAllBank1Pages||, CODE, READONLY, ALIGN=2

                  FLASH_EraseAllBank1Pages PROC
;;;553      */
;;;554    FLASH_Status FLASH_EraseAllBank1Pages(void)
000000  b510              PUSH     {r4,lr}
;;;555    {
;;;556      FLASH_Status status = FLASH_COMPLETE;
000002  2404              MOVS     r4,#4
;;;557      /* Wait for last operation to be completed */
;;;558      status = FLASH_WaitForLastBank1Operation(EraseTimeout);
000004  f44f2030          MOV      r0,#0xb0000
000008  f7fffffe          BL       FLASH_WaitForLastBank1Operation
00000c  4604              MOV      r4,r0
;;;559      
;;;560      if(status == FLASH_COMPLETE)
00000e  2c04              CMP      r4,#4
000010  d116              BNE      |L3.64|
;;;561      {
;;;562        /* if the previous operation is completed, proceed to erase all pages */
;;;563         FLASH->CR |= CR_MER_Set;
000012  480c              LDR      r0,|L3.68|
000014  6900              LDR      r0,[r0,#0x10]
000016  f0400004          ORR      r0,r0,#4
00001a  490a              LDR      r1,|L3.68|
00001c  6108              STR      r0,[r1,#0x10]
;;;564         FLASH->CR |= CR_STRT_Set;
00001e  4608              MOV      r0,r1
000020  6900              LDR      r0,[r0,#0x10]
000022  f0400040          ORR      r0,r0,#0x40
000026  6108              STR      r0,[r1,#0x10]
;;;565        
;;;566        /* Wait for last operation to be completed */
;;;567        status = FLASH_WaitForLastBank1Operation(EraseTimeout);
000028  f44f2030          MOV      r0,#0xb0000
00002c  f7fffffe          BL       FLASH_WaitForLastBank1Operation
000030  4604              MOV      r4,r0
;;;568        
;;;569        /* Disable the MER Bit */
;;;570        FLASH->CR &= CR_MER_Reset;
000032  4804              LDR      r0,|L3.68|
000034  6900              LDR      r0,[r0,#0x10]
000036  f64171fb          MOV      r1,#0x1ffb
00003a  4008              ANDS     r0,r0,r1
00003c  4901              LDR      r1,|L3.68|
00003e  6108              STR      r0,[r1,#0x10]
                  |L3.64|
;;;571      }    
;;;572      /* Return the Erase Status */
;;;573      return status;
000040  4620              MOV      r0,r4
;;;574    }
000042  bd10              POP      {r4,pc}
;;;575    
                          ENDP

                  |L3.68|
                          DCD      0x40022000

                          AREA ||i.FLASH_EraseAllPages||, CODE, READONLY, ALIGN=2

                  FLASH_EraseAllPages PROC
;;;490      */
;;;491    FLASH_Status FLASH_EraseAllPages(void)
000000  b510              PUSH     {r4,lr}
;;;492    {
;;;493      FLASH_Status status = FLASH_COMPLETE;
000002  2404              MOVS     r4,#4
;;;494    
;;;495    #ifdef STM32F10X_XL
;;;496      /* Wait for last operation to be completed */
;;;497      status = FLASH_WaitForLastBank1Operation(EraseTimeout);
;;;498      
;;;499      if(status == FLASH_COMPLETE)
;;;500      {
;;;501        /* if the previous operation is completed, proceed to erase all pages */
;;;502         FLASH->CR |= CR_MER_Set;
;;;503         FLASH->CR |= CR_STRT_Set;
;;;504        
;;;505        /* Wait for last operation to be completed */
;;;506        status = FLASH_WaitForLastBank1Operation(EraseTimeout);
;;;507        
;;;508        /* Disable the MER Bit */
;;;509        FLASH->CR &= CR_MER_Reset;
;;;510      }    
;;;511      if(status == FLASH_COMPLETE)
;;;512      {
;;;513        /* if the previous operation is completed, proceed to erase all pages */
;;;514         FLASH->CR2 |= CR_MER_Set;
;;;515         FLASH->CR2 |= CR_STRT_Set;
;;;516        
;;;517        /* Wait for last operation to be completed */
;;;518        status = FLASH_WaitForLastBank2Operation(EraseTimeout);
;;;519        
;;;520        /* Disable the MER Bit */
;;;521        FLASH->CR2 &= CR_MER_Reset;
;;;522      }
;;;523    #else
;;;524      /* Wait for last operation to be completed */
;;;525      status = FLASH_WaitForLastOperation(EraseTimeout);
000004  f44f2030          MOV      r0,#0xb0000
000008  f7fffffe          BL       FLASH_WaitForLastOperation
00000c  4604              MOV      r4,r0
;;;526      if(status == FLASH_COMPLETE)
00000e  2c04              CMP      r4,#4
000010  d116              BNE      |L4.64|
;;;527      {
;;;528        /* if the previous operation is completed, proceed to erase all pages */
;;;529         FLASH->CR |= CR_MER_Set;
000012  480c              LDR      r0,|L4.68|
000014  6900              LDR      r0,[r0,#0x10]
000016  f0400004          ORR      r0,r0,#4
00001a  490a              LDR      r1,|L4.68|
00001c  6108              STR      r0,[r1,#0x10]
;;;530         FLASH->CR |= CR_STRT_Set;
00001e  4608              MOV      r0,r1
000020  6900              LDR      r0,[r0,#0x10]
000022  f0400040          ORR      r0,r0,#0x40
000026  6108              STR      r0,[r1,#0x10]
;;;531        
;;;532        /* Wait for last operation to be completed */
;;;533        status = FLASH_WaitForLastOperation(EraseTimeout);
000028  f44f2030          MOV      r0,#0xb0000
00002c  f7fffffe          BL       FLASH_WaitForLastOperation
000030  4604              MOV      r4,r0
;;;534    
;;;535        /* Disable the MER Bit */
;;;536        FLASH->CR &= CR_MER_Reset;
000032  4804              LDR      r0,|L4.68|
000034  6900              LDR      r0,[r0,#0x10]
000036  f64171fb          MOV      r1,#0x1ffb
00003a  4008              ANDS     r0,r0,r1
00003c  4901              LDR      r1,|L4.68|
00003e  6108              STR      r0,[r1,#0x10]
                  |L4.64|
;;;537      }
;;;538    #endif /* STM32F10X_XL */
;;;539    
;;;540      /* Return the Erase Status */
;;;541      return status;
000040  4620              MOV      r0,r4
;;;542    }
000042  bd10              POP      {r4,pc}
;;;543    
                          ENDP

                  |L4.68|
                          DCD      0x40022000

                          AREA ||i.FLASH_EraseOptionBytes||, CODE, READONLY, ALIGN=2

                  FLASH_EraseOptionBytes PROC
;;;614      */
;;;615    FLASH_Status FLASH_EraseOptionBytes(void)
000000  b530              PUSH     {r4,r5,lr}
;;;616    {
;;;617      uint16_t rdptmp = RDP_Key;
000002  25a5              MOVS     r5,#0xa5
;;;618    
;;;619      FLASH_Status status = FLASH_COMPLETE;
000004  2404              MOVS     r4,#4
;;;620    
;;;621      /* Get the actual read protection Option Byte value */ 
;;;622      if(FLASH_GetReadOutProtectionStatus() != RESET)
000006  f7fffffe          BL       FLASH_GetReadOutProtectionStatus
00000a  b100              CBZ      r0,|L5.14|
;;;623      {
;;;624        rdptmp = 0x00;  
00000c  2500              MOVS     r5,#0
                  |L5.14|
;;;625      }
;;;626    
;;;627      /* Wait for last operation to be completed */
;;;628      status = FLASH_WaitForLastOperation(EraseTimeout);
00000e  f44f2030          MOV      r0,#0xb0000
000012  f7fffffe          BL       FLASH_WaitForLastOperation
000016  4604              MOV      r4,r0
;;;629      if(status == FLASH_COMPLETE)
000018  2c04              CMP      r4,#4
00001a  d13a              BNE      |L5.146|
;;;630      {
;;;631        /* Authorize the small information block programming */
;;;632        FLASH->OPTKEYR = FLASH_KEY1;
00001c  481e              LDR      r0,|L5.152|
00001e  491f              LDR      r1,|L5.156|
000020  6088              STR      r0,[r1,#8]
;;;633        FLASH->OPTKEYR = FLASH_KEY2;
000022  481f              LDR      r0,|L5.160|
000024  6088              STR      r0,[r1,#8]
;;;634        
;;;635        /* if the previous operation is completed, proceed to erase the option bytes */
;;;636        FLASH->CR |= CR_OPTER_Set;
000026  4608              MOV      r0,r1
000028  6900              LDR      r0,[r0,#0x10]
00002a  f0400020          ORR      r0,r0,#0x20
00002e  6108              STR      r0,[r1,#0x10]
;;;637        FLASH->CR |= CR_STRT_Set;
000030  4608              MOV      r0,r1
000032  6900              LDR      r0,[r0,#0x10]
000034  f0400040          ORR      r0,r0,#0x40
000038  6108              STR      r0,[r1,#0x10]
;;;638        /* Wait for last operation to be completed */
;;;639        status = FLASH_WaitForLastOperation(EraseTimeout);
00003a  f44f2030          MOV      r0,#0xb0000
00003e  f7fffffe          BL       FLASH_WaitForLastOperation
000042  4604              MOV      r4,r0
;;;640        
;;;641        if(status == FLASH_COMPLETE)
000044  2c04              CMP      r4,#4
000046  d11b              BNE      |L5.128|
;;;642        {
;;;643          /* if the erase operation is completed, disable the OPTER Bit */
;;;644          FLASH->CR &= CR_OPTER_Reset;
000048  4814              LDR      r0,|L5.156|
00004a  6900              LDR      r0,[r0,#0x10]
00004c  f64171df          MOV      r1,#0x1fdf
000050  4008              ANDS     r0,r0,r1
000052  4912              LDR      r1,|L5.156|
000054  6108              STR      r0,[r1,#0x10]
;;;645           
;;;646          /* Enable the Option Bytes Programming operation */
;;;647          FLASH->CR |= CR_OPTPG_Set;
000056  4608              MOV      r0,r1
000058  6900              LDR      r0,[r0,#0x10]
00005a  f0400010          ORR      r0,r0,#0x10
00005e  6108              STR      r0,[r1,#0x10]
;;;648          /* Restore the last read protection Option Byte value */
;;;649          OB->RDP = (uint16_t)rdptmp; 
000060  4810              LDR      r0,|L5.164|
000062  8005              STRH     r5,[r0,#0]
;;;650          /* Wait for last operation to be completed */
;;;651          status = FLASH_WaitForLastOperation(ProgramTimeout);
000064  02e0              LSLS     r0,r4,#11
000066  f7fffffe          BL       FLASH_WaitForLastOperation
00006a  4604              MOV      r4,r0
;;;652     
;;;653          if(status != FLASH_TIMEOUT)
00006c  2c05              CMP      r4,#5
00006e  d010              BEQ      |L5.146|
;;;654          {
;;;655            /* if the program operation is completed, disable the OPTPG Bit */
;;;656            FLASH->CR &= CR_OPTPG_Reset;
000070  480a              LDR      r0,|L5.156|
000072  6900              LDR      r0,[r0,#0x10]
000074  f64171ef          MOV      r1,#0x1fef
000078  4008              ANDS     r0,r0,r1
00007a  4908              LDR      r1,|L5.156|
00007c  6108              STR      r0,[r1,#0x10]
00007e  e008              B        |L5.146|
                  |L5.128|
;;;657          }
;;;658        }
;;;659        else
;;;660        {
;;;661          if (status != FLASH_TIMEOUT)
000080  2c05              CMP      r4,#5
000082  d006              BEQ      |L5.146|
;;;662          {
;;;663            /* Disable the OPTPG Bit */
;;;664            FLASH->CR &= CR_OPTPG_Reset;
000084  4805              LDR      r0,|L5.156|
000086  6900              LDR      r0,[r0,#0x10]
000088  f64171ef          MOV      r1,#0x1fef
00008c  4008              ANDS     r0,r0,r1
00008e  4903              LDR      r1,|L5.156|
000090  6108              STR      r0,[r1,#0x10]
                  |L5.146|
;;;665          }
;;;666        }  
;;;667      }
;;;668      /* Return the erase status */
;;;669      return status;
000092  4620              MOV      r0,r4
;;;670    }
000094  bd30              POP      {r4,r5,pc}
;;;671    
                          ENDP

000096  0000              DCW      0x0000
                  |L5.152|
                          DCD      0x45670123
                  |L5.156|
                          DCD      0x40022000
                  |L5.160|
                          DCD      0xcdef89ab
                  |L5.164|
                          DCD      0x1ffff800

                          AREA ||i.FLASH_ErasePage||, CODE, READONLY, ALIGN=2

                  FLASH_ErasePage PROC
;;;417      */
;;;418    FLASH_Status FLASH_ErasePage(uint32_t Page_Address)
000000  b530              PUSH     {r4,r5,lr}
;;;419    {
000002  4604              MOV      r4,r0
;;;420      FLASH_Status status = FLASH_COMPLETE;
000004  2504              MOVS     r5,#4
;;;421      /* Check the parameters */
;;;422      assert_param(IS_FLASH_ADDRESS(Page_Address));
;;;423    
;;;424    #ifdef STM32F10X_XL
;;;425      if(Page_Address < FLASH_BANK1_END_ADDRESS)  
;;;426      {
;;;427        /* Wait for last operation to be completed */
;;;428        status = FLASH_WaitForLastBank1Operation(EraseTimeout);
;;;429        if(status == FLASH_COMPLETE)
;;;430        { 
;;;431          /* if the previous operation is completed, proceed to erase the page */
;;;432          FLASH->CR|= CR_PER_Set;
;;;433          FLASH->AR = Page_Address; 
;;;434          FLASH->CR|= CR_STRT_Set;
;;;435        
;;;436          /* Wait for last operation to be completed */
;;;437          status = FLASH_WaitForLastBank1Operation(EraseTimeout);
;;;438    
;;;439          /* Disable the PER Bit */
;;;440          FLASH->CR &= CR_PER_Reset;
;;;441        }
;;;442      }
;;;443      else
;;;444      {
;;;445        /* Wait for last operation to be completed */
;;;446        status = FLASH_WaitForLastBank2Operation(EraseTimeout);
;;;447        if(status == FLASH_COMPLETE)
;;;448        { 
;;;449          /* if the previous operation is completed, proceed to erase the page */
;;;450          FLASH->CR2|= CR_PER_Set;
;;;451          FLASH->AR2 = Page_Address; 
;;;452          FLASH->CR2|= CR_STRT_Set;
;;;453        
;;;454          /* Wait for last operation to be completed */
;;;455          status = FLASH_WaitForLastBank2Operation(EraseTimeout);
;;;456          
;;;457          /* Disable the PER Bit */
;;;458          FLASH->CR2 &= CR_PER_Reset;
;;;459        }
;;;460      }
;;;461    #else
;;;462      /* Wait for last operation to be completed */
;;;463      status = FLASH_WaitForLastOperation(EraseTimeout);
000006  f44f2030          MOV      r0,#0xb0000
00000a  f7fffffe          BL       FLASH_WaitForLastOperation
00000e  4605              MOV      r5,r0
;;;464      
;;;465      if(status == FLASH_COMPLETE)
000010  2d04              CMP      r5,#4
000012  d117              BNE      |L6.68|
;;;466      { 
;;;467        /* if the previous operation is completed, proceed to erase the page */
;;;468        FLASH->CR|= CR_PER_Set;
000014  480c              LDR      r0,|L6.72|
000016  6900              LDR      r0,[r0,#0x10]
000018  f0400002          ORR      r0,r0,#2
00001c  490a              LDR      r1,|L6.72|
00001e  6108              STR      r0,[r1,#0x10]
;;;469        FLASH->AR = Page_Address; 
000020  4608              MOV      r0,r1
000022  6144              STR      r4,[r0,#0x14]
;;;470        FLASH->CR|= CR_STRT_Set;
000024  6900              LDR      r0,[r0,#0x10]
000026  f0400040          ORR      r0,r0,#0x40
00002a  6108              STR      r0,[r1,#0x10]
;;;471        
;;;472        /* Wait for last operation to be completed */
;;;473        status = FLASH_WaitForLastOperation(EraseTimeout);
00002c  f44f2030          MOV      r0,#0xb0000
000030  f7fffffe          BL       FLASH_WaitForLastOperation
000034  4605              MOV      r5,r0
;;;474        
;;;475        /* Disable the PER Bit */
;;;476        FLASH->CR &= CR_PER_Reset;
000036  4804              LDR      r0,|L6.72|
000038  6900              LDR      r0,[r0,#0x10]
00003a  f64171fd          MOV      r1,#0x1ffd
00003e  4008              ANDS     r0,r0,r1
000040  4901              LDR      r1,|L6.72|
000042  6108              STR      r0,[r1,#0x10]
                  |L6.68|
;;;477      }
;;;478    #endif /* STM32F10X_XL */
;;;479    
;;;480      /* Return the Erase Status */
;;;481      return status;
000044  4628              MOV      r0,r5
;;;482    }
000046  bd30              POP      {r4,r5,pc}
;;;483    
                          ENDP

                  |L6.72|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetBank1Status||, CODE, READONLY, ALIGN=2

                  FLASH_GetBank1Status PROC
;;;1513     */
;;;1514   FLASH_Status FLASH_GetBank1Status(void)
000000  2004              MOVS     r0,#4
;;;1515   {
;;;1516     FLASH_Status flashstatus = FLASH_COMPLETE;
;;;1517     
;;;1518     if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
000002  490b              LDR      r1,|L7.48|
000004  68c9              LDR      r1,[r1,#0xc]
000006  f0010101          AND      r1,r1,#1
00000a  b109              CBZ      r1,|L7.16|
;;;1519     {
;;;1520       flashstatus = FLASH_BUSY;
00000c  2001              MOVS     r0,#1
00000e  e00e              B        |L7.46|
                  |L7.16|
;;;1521     }
;;;1522     else 
;;;1523     {  
;;;1524       if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
000010  4907              LDR      r1,|L7.48|
000012  68c9              LDR      r1,[r1,#0xc]
000014  f0010104          AND      r1,r1,#4
000018  b109              CBZ      r1,|L7.30|
;;;1525       { 
;;;1526         flashstatus = FLASH_ERROR_PG;
00001a  2002              MOVS     r0,#2
00001c  e007              B        |L7.46|
                  |L7.30|
;;;1527       }
;;;1528       else 
;;;1529       {
;;;1530         if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
00001e  4904              LDR      r1,|L7.48|
000020  68c9              LDR      r1,[r1,#0xc]
000022  f0010110          AND      r1,r1,#0x10
000026  b109              CBZ      r1,|L7.44|
;;;1531         {
;;;1532           flashstatus = FLASH_ERROR_WRP;
000028  2003              MOVS     r0,#3
00002a  e000              B        |L7.46|
                  |L7.44|
;;;1533         }
;;;1534         else
;;;1535         {
;;;1536           flashstatus = FLASH_COMPLETE;
00002c  2004              MOVS     r0,#4
                  |L7.46|
;;;1537         }
;;;1538       }
;;;1539     }
;;;1540     /* Return the Flash Status */
;;;1541     return flashstatus;
;;;1542   }
00002e  4770              BX       lr
;;;1543   
                          ENDP

                  |L7.48|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetFlagStatus PROC
;;;1355     */
;;;1356   FlagStatus FLASH_GetFlagStatus(uint32_t FLASH_FLAG)
000000  4601              MOV      r1,r0
;;;1357   {
;;;1358     FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1359   
;;;1360   #ifdef STM32F10X_XL
;;;1361     /* Check the parameters */
;;;1362     assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG)) ;
;;;1363     if(FLASH_FLAG == FLASH_FLAG_OPTERR) 
;;;1364     {
;;;1365       if((FLASH->OBR & FLASH_FLAG_OPTERR) != (uint32_t)RESET)
;;;1366       {
;;;1367         bitstatus = SET;
;;;1368       }
;;;1369       else
;;;1370       {
;;;1371         bitstatus = RESET;
;;;1372       }
;;;1373     }
;;;1374     else
;;;1375     {
;;;1376       if((FLASH_FLAG & 0x80000000) != 0x0)
;;;1377       {
;;;1378         if((FLASH->SR2 & FLASH_FLAG) != (uint32_t)RESET)
;;;1379         {
;;;1380           bitstatus = SET;
;;;1381         }
;;;1382         else
;;;1383         {
;;;1384           bitstatus = RESET;
;;;1385         }
;;;1386       }
;;;1387       else
;;;1388       {
;;;1389         if((FLASH->SR & FLASH_FLAG) != (uint32_t)RESET)
;;;1390         {
;;;1391           bitstatus = SET;
;;;1392         }
;;;1393         else
;;;1394         {
;;;1395           bitstatus = RESET;
;;;1396         }
;;;1397       }
;;;1398     }
;;;1399   #else
;;;1400     /* Check the parameters */
;;;1401     assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG)) ;
;;;1402     if(FLASH_FLAG == FLASH_FLAG_OPTERR) 
000004  2901              CMP      r1,#1
000006  d108              BNE      |L8.26|
;;;1403     {
;;;1404       if((FLASH->OBR & FLASH_FLAG_OPTERR) != (uint32_t)RESET)
000008  4a08              LDR      r2,|L8.44|
00000a  69d2              LDR      r2,[r2,#0x1c]
00000c  f0020201          AND      r2,r2,#1
000010  b10a              CBZ      r2,|L8.22|
;;;1405       {
;;;1406         bitstatus = SET;
000012  2001              MOVS     r0,#1
000014  e008              B        |L8.40|
                  |L8.22|
;;;1407       }
;;;1408       else
;;;1409       {
;;;1410         bitstatus = RESET;
000016  2000              MOVS     r0,#0
000018  e006              B        |L8.40|
                  |L8.26|
;;;1411       }
;;;1412     }
;;;1413     else
;;;1414     {
;;;1415      if((FLASH->SR & FLASH_FLAG) != (uint32_t)RESET)
00001a  4a04              LDR      r2,|L8.44|
00001c  68d2              LDR      r2,[r2,#0xc]
00001e  400a              ANDS     r2,r2,r1
000020  b10a              CBZ      r2,|L8.38|
;;;1416       {
;;;1417         bitstatus = SET;
000022  2001              MOVS     r0,#1
000024  e000              B        |L8.40|
                  |L8.38|
;;;1418       }
;;;1419       else
;;;1420       {
;;;1421         bitstatus = RESET;
000026  2000              MOVS     r0,#0
                  |L8.40|
;;;1422       }
;;;1423     }
;;;1424   #endif /* STM32F10X_XL */
;;;1425   
;;;1426     /* Return the new state of FLASH_FLAG (SET or RESET) */
;;;1427     return bitstatus;
;;;1428   }
000028  4770              BX       lr
;;;1429   
                          ENDP

00002a  0000              DCW      0x0000
                  |L8.44|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetPrefetchBufferStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetPrefetchBufferStatus PROC
;;;1258     */
;;;1259   FlagStatus FLASH_GetPrefetchBufferStatus(void)
000000  2000              MOVS     r0,#0
;;;1260   {
;;;1261     FlagStatus bitstatus = RESET;
;;;1262     
;;;1263     if ((FLASH->ACR & ACR_PRFTBS_Mask) != (uint32_t)RESET)
000002  4904              LDR      r1,|L9.20|
000004  6809              LDR      r1,[r1,#0]
000006  f0010120          AND      r1,r1,#0x20
00000a  b109              CBZ      r1,|L9.16|
;;;1264     {
;;;1265       bitstatus = SET;
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L9.18|
                  |L9.16|
;;;1266     }
;;;1267     else
;;;1268     {
;;;1269       bitstatus = RESET;
000010  2000              MOVS     r0,#0
                  |L9.18|
;;;1270     }
;;;1271     /* Return the new state of FLASH Prefetch Buffer Status (SET or RESET) */
;;;1272     return bitstatus; 
;;;1273   }
000012  4770              BX       lr
;;;1274   
                          ENDP

                  |L9.20|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetReadOutProtectionStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetReadOutProtectionStatus PROC
;;;1238     */
;;;1239   FlagStatus FLASH_GetReadOutProtectionStatus(void)
000000  2000              MOVS     r0,#0
;;;1240   {
;;;1241     FlagStatus readoutstatus = RESET;
;;;1242     if ((FLASH->OBR & RDPRT_Mask) != (uint32_t)RESET)
000002  4904              LDR      r1,|L10.20|
000004  69c9              LDR      r1,[r1,#0x1c]
000006  f0010102          AND      r1,r1,#2
00000a  b109              CBZ      r1,|L10.16|
;;;1243     {
;;;1244       readoutstatus = SET;
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L10.18|
                  |L10.16|
;;;1245     }
;;;1246     else
;;;1247     {
;;;1248       readoutstatus = RESET;
000010  2000              MOVS     r0,#0
                  |L10.18|
;;;1249     }
;;;1250     return readoutstatus;
;;;1251   }
000012  4770              BX       lr
;;;1252   
                          ENDP

                  |L10.20|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetStatus PROC
;;;1475     */
;;;1476   FLASH_Status FLASH_GetStatus(void)
000000  2004              MOVS     r0,#4
;;;1477   {
;;;1478     FLASH_Status flashstatus = FLASH_COMPLETE;
;;;1479     
;;;1480     if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
000002  490b              LDR      r1,|L11.48|
000004  68c9              LDR      r1,[r1,#0xc]
000006  f0010101          AND      r1,r1,#1
00000a  b109              CBZ      r1,|L11.16|
;;;1481     {
;;;1482       flashstatus = FLASH_BUSY;
00000c  2001              MOVS     r0,#1
00000e  e00e              B        |L11.46|
                  |L11.16|
;;;1483     }
;;;1484     else 
;;;1485     {  
;;;1486       if((FLASH->SR & FLASH_FLAG_PGERR) != 0)
000010  4907              LDR      r1,|L11.48|
000012  68c9              LDR      r1,[r1,#0xc]
000014  f0010104          AND      r1,r1,#4
000018  b109              CBZ      r1,|L11.30|
;;;1487       { 
;;;1488         flashstatus = FLASH_ERROR_PG;
00001a  2002              MOVS     r0,#2
00001c  e007              B        |L11.46|
                  |L11.30|
;;;1489       }
;;;1490       else 
;;;1491       {
;;;1492         if((FLASH->SR & FLASH_FLAG_WRPRTERR) != 0 )
00001e  4904              LDR      r1,|L11.48|
000020  68c9              LDR      r1,[r1,#0xc]
000022  f0010110          AND      r1,r1,#0x10
000026  b109              CBZ      r1,|L11.44|
;;;1493         {
;;;1494           flashstatus = FLASH_ERROR_WRP;
000028  2003              MOVS     r0,#3
00002a  e000              B        |L11.46|
                  |L11.44|
;;;1495         }
;;;1496         else
;;;1497         {
;;;1498           flashstatus = FLASH_COMPLETE;
00002c  2004              MOVS     r0,#4
                  |L11.46|
;;;1499         }
;;;1500       }
;;;1501     }
;;;1502     /* Return the Flash Status */
;;;1503     return flashstatus;
;;;1504   }
00002e  4770              BX       lr
;;;1505   
                          ENDP

                  |L11.48|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetUserOptionByte||, CODE, READONLY, ALIGN=2

                  FLASH_GetUserOptionByte PROC
;;;1214     */
;;;1215   uint32_t FLASH_GetUserOptionByte(void)
000000  4801              LDR      r0,|L12.8|
;;;1216   {
;;;1217     /* Return the User Option Byte */
;;;1218     return (uint32_t)(FLASH->OBR >> 2);
000002  69c0              LDR      r0,[r0,#0x1c]
000004  0880              LSRS     r0,r0,#2
;;;1219   }
000006  4770              BX       lr
;;;1220   
                          ENDP

                  |L12.8|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetWriteProtectionOptionByte||, CODE, READONLY, ALIGN=2

                  FLASH_GetWriteProtectionOptionByte PROC
;;;1226     */
;;;1227   uint32_t FLASH_GetWriteProtectionOptionByte(void)
000000  4801              LDR      r0,|L13.8|
;;;1228   {
;;;1229     /* Return the Falsh write protection Register value */
;;;1230     return (uint32_t)(FLASH->WRPR);
000002  6a00              LDR      r0,[r0,#0x20]
;;;1231   }
000004  4770              BX       lr
;;;1232   
                          ENDP

000006  0000              DCW      0x0000
                  |L13.8|
                          DCD      0x40022000

                          AREA ||i.FLASH_HalfCycleAccessCmd||, CODE, READONLY, ALIGN=2

                  FLASH_HalfCycleAccessCmd PROC
;;;279      */
;;;280    void FLASH_HalfCycleAccessCmd(uint32_t FLASH_HalfCycleAccess)
000000  4905              LDR      r1,|L14.24|
;;;281    {
;;;282      /* Check the parameters */
;;;283      assert_param(IS_FLASH_HALFCYCLEACCESS_STATE(FLASH_HalfCycleAccess));
;;;284      
;;;285      /* Enable or disable the Half cycle access */
;;;286      FLASH->ACR &= ACR_HLFCYA_Mask;
000002  6809              LDR      r1,[r1,#0]
000004  f0210108          BIC      r1,r1,#8
000008  4a03              LDR      r2,|L14.24|
00000a  6011              STR      r1,[r2,#0]
;;;287      FLASH->ACR |= FLASH_HalfCycleAccess;
00000c  4611              MOV      r1,r2
00000e  6809              LDR      r1,[r1,#0]
000010  4301              ORRS     r1,r1,r0
000012  6011              STR      r1,[r2,#0]
;;;288    }
000014  4770              BX       lr
;;;289    
                          ENDP

000016  0000              DCW      0x0000
                  |L14.24|
                          DCD      0x40022000

                          AREA ||i.FLASH_ITConfig||, CODE, READONLY, ALIGN=2

                  FLASH_ITConfig PROC
;;;1288     */
;;;1289   void FLASH_ITConfig(uint32_t FLASH_IT, FunctionalState NewState)
000000  b129              CBZ      r1,|L15.14|
;;;1290   {
;;;1291   #ifdef STM32F10X_XL
;;;1292     /* Check the parameters */
;;;1293     assert_param(IS_FLASH_IT(FLASH_IT)); 
;;;1294     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1295   
;;;1296     if((FLASH_IT & 0x80000000) != 0x0)
;;;1297     {
;;;1298       if(NewState != DISABLE)
;;;1299       {
;;;1300         /* Enable the interrupt sources */
;;;1301         FLASH->CR2 |= (FLASH_IT & 0x7FFFFFFF);
;;;1302       }
;;;1303       else
;;;1304       {
;;;1305         /* Disable the interrupt sources */
;;;1306         FLASH->CR2 &= ~(uint32_t)(FLASH_IT & 0x7FFFFFFF);
;;;1307       }
;;;1308     }
;;;1309     else
;;;1310     {
;;;1311       if(NewState != DISABLE)
;;;1312       {
;;;1313         /* Enable the interrupt sources */
;;;1314         FLASH->CR |= FLASH_IT;
;;;1315       }
;;;1316       else
;;;1317       {
;;;1318         /* Disable the interrupt sources */
;;;1319         FLASH->CR &= ~(uint32_t)FLASH_IT;
;;;1320       }
;;;1321     }
;;;1322   #else
;;;1323     /* Check the parameters */
;;;1324     assert_param(IS_FLASH_IT(FLASH_IT)); 
;;;1325     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1326   
;;;1327     if(NewState != DISABLE)
;;;1328     {
;;;1329       /* Enable the interrupt sources */
;;;1330       FLASH->CR |= FLASH_IT;
000002  4a06              LDR      r2,|L15.28|
000004  6912              LDR      r2,[r2,#0x10]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L15.28|
00000a  611a              STR      r2,[r3,#0x10]
00000c  e004              B        |L15.24|
                  |L15.14|
;;;1331     }
;;;1332     else
;;;1333     {
;;;1334       /* Disable the interrupt sources */
;;;1335       FLASH->CR &= ~(uint32_t)FLASH_IT;
00000e  4a03              LDR      r2,|L15.28|
000010  6912              LDR      r2,[r2,#0x10]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L15.28|
000016  611a              STR      r2,[r3,#0x10]
                  |L15.24|
;;;1336     }
;;;1337   #endif /* STM32F10X_XL */
;;;1338   }
000018  4770              BX       lr
;;;1339   
                          ENDP

00001a  0000              DCW      0x0000
                  |L15.28|
                          DCD      0x40022000

                          AREA ||i.FLASH_Lock||, CODE, READONLY, ALIGN=2

                  FLASH_Lock PROC
;;;370      */
;;;371    void FLASH_Lock(void)
000000  4803              LDR      r0,|L16.16|
;;;372    {
;;;373      /* Set the Lock Bit to lock the FPEC and the CR of  Bank1 */
;;;374      FLASH->CR |= CR_LOCK_Set;
000002  6900              LDR      r0,[r0,#0x10]
000004  f0400080          ORR      r0,r0,#0x80
000008  4901              LDR      r1,|L16.16|
00000a  6108              STR      r0,[r1,#0x10]
;;;375    
;;;376    #ifdef STM32F10X_XL
;;;377      /* Set the Lock Bit to lock the FPEC and the CR of  Bank2 */
;;;378      FLASH->CR2 |= CR_LOCK_Set;
;;;379    #endif /* STM32F10X_XL */
;;;380    }
00000c  4770              BX       lr
;;;381    
                          ENDP

00000e  0000              DCW      0x0000
                  |L16.16|
                          DCD      0x40022000

                          AREA ||i.FLASH_LockBank1||, CODE, READONLY, ALIGN=2

                  FLASH_LockBank1 PROC
;;;390      */
;;;391    void FLASH_LockBank1(void)
000000  4803              LDR      r0,|L17.16|
;;;392    {
;;;393      /* Set the Lock Bit to lock the FPEC and the CR of  Bank1 */
;;;394      FLASH->CR |= CR_LOCK_Set;
000002  6900              LDR      r0,[r0,#0x10]
000004  f0400080          ORR      r0,r0,#0x80
000008  4901              LDR      r1,|L17.16|
00000a  6108              STR      r0,[r1,#0x10]
;;;395    }
00000c  4770              BX       lr
;;;396    
                          ENDP

00000e  0000              DCW      0x0000
                  |L17.16|
                          DCD      0x40022000

                          AREA ||i.FLASH_PrefetchBufferCmd||, CODE, READONLY, ALIGN=2

                  FLASH_PrefetchBufferCmd PROC
;;;298      */
;;;299    void FLASH_PrefetchBufferCmd(uint32_t FLASH_PrefetchBuffer)
000000  4905              LDR      r1,|L18.24|
;;;300    {
;;;301      /* Check the parameters */
;;;302      assert_param(IS_FLASH_PREFETCHBUFFER_STATE(FLASH_PrefetchBuffer));
;;;303      
;;;304      /* Enable or disable the Prefetch Buffer */
;;;305      FLASH->ACR &= ACR_PRFTBE_Mask;
000002  6809              LDR      r1,[r1,#0]
000004  f0210110          BIC      r1,r1,#0x10
000008  4a03              LDR      r2,|L18.24|
00000a  6011              STR      r1,[r2,#0]
;;;306      FLASH->ACR |= FLASH_PrefetchBuffer;
00000c  4611              MOV      r1,r2
00000e  6809              LDR      r1,[r1,#0]
000010  4301              ORRS     r1,r1,r0
000012  6011              STR      r1,[r2,#0]
;;;307    }
000014  4770              BX       lr
;;;308    
                          ENDP

000016  0000              DCW      0x0000
                  |L18.24|
                          DCD      0x40022000

                          AREA ||i.FLASH_ProgramHalfWord||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramHalfWord PROC
;;;856      */
;;;857    FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data)
000000  b570              PUSH     {r4-r6,lr}
;;;858    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;859      FLASH_Status status = FLASH_COMPLETE;
000006  2604              MOVS     r6,#4
;;;860      /* Check the parameters */
;;;861      assert_param(IS_FLASH_ADDRESS(Address));
;;;862    
;;;863    #ifdef STM32F10X_XL
;;;864      /* Wait for last operation to be completed */
;;;865      status = FLASH_WaitForLastOperation(ProgramTimeout);
;;;866      
;;;867      if(Address < FLASH_BANK1_END_ADDRESS)
;;;868      {
;;;869        if(status == FLASH_COMPLETE)
;;;870        {
;;;871          /* if the previous operation is completed, proceed to program the new data */
;;;872          FLASH->CR |= CR_PG_Set;
;;;873      
;;;874          *(__IO uint16_t*)Address = Data;
;;;875          /* Wait for last operation to be completed */
;;;876          status = FLASH_WaitForLastBank1Operation(ProgramTimeout);
;;;877    
;;;878          /* Disable the PG Bit */
;;;879          FLASH->CR &= CR_PG_Reset;
;;;880        }
;;;881      }
;;;882      else
;;;883      {
;;;884        if(status == FLASH_COMPLETE)
;;;885        {
;;;886          /* if the previous operation is completed, proceed to program the new data */
;;;887          FLASH->CR2 |= CR_PG_Set;
;;;888      
;;;889          *(__IO uint16_t*)Address = Data;
;;;890          /* Wait for last operation to be completed */
;;;891          status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
;;;892    
;;;893          /* Disable the PG Bit */
;;;894          FLASH->CR2 &= CR_PG_Reset;
;;;895        }
;;;896      }
;;;897    #else
;;;898      /* Wait for last operation to be completed */
;;;899      status = FLASH_WaitForLastOperation(ProgramTimeout);
000008  02f0              LSLS     r0,r6,#11
00000a  f7fffffe          BL       FLASH_WaitForLastOperation
00000e  4606              MOV      r6,r0
;;;900      
;;;901      if(status == FLASH_COMPLETE)
000010  2e04              CMP      r6,#4
000012  d111              BNE      |L19.56|
;;;902      {
;;;903        /* if the previous operation is completed, proceed to program the new data */
;;;904        FLASH->CR |= CR_PG_Set;
000014  4809              LDR      r0,|L19.60|
000016  6900              LDR      r0,[r0,#0x10]
000018  f0400001          ORR      r0,r0,#1
00001c  4907              LDR      r1,|L19.60|
00001e  6108              STR      r0,[r1,#0x10]
;;;905      
;;;906        *(__IO uint16_t*)Address = Data;
000020  8025              STRH     r5,[r4,#0]
;;;907        /* Wait for last operation to be completed */
;;;908        status = FLASH_WaitForLastOperation(ProgramTimeout);
000022  02f0              LSLS     r0,r6,#11
000024  f7fffffe          BL       FLASH_WaitForLastOperation
000028  4606              MOV      r6,r0
;;;909        
;;;910        /* Disable the PG Bit */
;;;911        FLASH->CR &= CR_PG_Reset;
00002a  4804              LDR      r0,|L19.60|
00002c  6900              LDR      r0,[r0,#0x10]
00002e  f64171fe          MOV      r1,#0x1ffe
000032  4008              ANDS     r0,r0,r1
000034  4901              LDR      r1,|L19.60|
000036  6108              STR      r0,[r1,#0x10]
                  |L19.56|
;;;912      } 
;;;913    #endif  /* STM32F10X_XL */
;;;914      
;;;915      /* Return the Program Status */
;;;916      return status;
000038  4630              MOV      r0,r6
;;;917    }
00003a  bd70              POP      {r4-r6,pc}
;;;918    
                          ENDP

                  |L19.60|
                          DCD      0x40022000

                          AREA ||i.FLASH_ProgramOptionByteData||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramOptionByteData PROC
;;;927      */
;;;928    FLASH_Status FLASH_ProgramOptionByteData(uint32_t Address, uint8_t Data)
000000  b570              PUSH     {r4-r6,lr}
;;;929    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;930      FLASH_Status status = FLASH_COMPLETE;
000006  2404              MOVS     r4,#4
;;;931      /* Check the parameters */
;;;932      assert_param(IS_OB_DATA_ADDRESS(Address));
;;;933      status = FLASH_WaitForLastOperation(ProgramTimeout);
000008  02e0              LSLS     r0,r4,#11
00000a  f7fffffe          BL       FLASH_WaitForLastOperation
00000e  4604              MOV      r4,r0
;;;934    
;;;935      if(status == FLASH_COMPLETE)
000010  2c04              CMP      r4,#4
000012  d117              BNE      |L20.68|
;;;936      {
;;;937        /* Authorize the small information block programming */
;;;938        FLASH->OPTKEYR = FLASH_KEY1;
000014  480c              LDR      r0,|L20.72|
000016  490d              LDR      r1,|L20.76|
000018  6088              STR      r0,[r1,#8]
;;;939        FLASH->OPTKEYR = FLASH_KEY2;
00001a  480d              LDR      r0,|L20.80|
00001c  6088              STR      r0,[r1,#8]
;;;940        /* Enables the Option Bytes Programming operation */
;;;941        FLASH->CR |= CR_OPTPG_Set; 
00001e  4608              MOV      r0,r1
000020  6900              LDR      r0,[r0,#0x10]
000022  f0400010          ORR      r0,r0,#0x10
000026  6108              STR      r0,[r1,#0x10]
;;;942        *(__IO uint16_t*)Address = Data;
000028  802e              STRH     r6,[r5,#0]
;;;943        
;;;944        /* Wait for last operation to be completed */
;;;945        status = FLASH_WaitForLastOperation(ProgramTimeout);
00002a  02e0              LSLS     r0,r4,#11
00002c  f7fffffe          BL       FLASH_WaitForLastOperation
000030  4604              MOV      r4,r0
;;;946        if(status != FLASH_TIMEOUT)
000032  2c05              CMP      r4,#5
000034  d006              BEQ      |L20.68|
;;;947        {
;;;948          /* if the program operation is completed, disable the OPTPG Bit */
;;;949          FLASH->CR &= CR_OPTPG_Reset;
000036  4805              LDR      r0,|L20.76|
000038  6900              LDR      r0,[r0,#0x10]
00003a  f64171ef          MOV      r1,#0x1fef
00003e  4008              ANDS     r0,r0,r1
000040  4902              LDR      r1,|L20.76|
000042  6108              STR      r0,[r1,#0x10]
                  |L20.68|
;;;950        }
;;;951      }
;;;952      /* Return the Option Byte Data Program Status */
;;;953      return status;
000044  4620              MOV      r0,r4
;;;954    }
000046  bd70              POP      {r4-r6,pc}
;;;955    
                          ENDP

                  |L20.72|
                          DCD      0x45670123
                  |L20.76|
                          DCD      0x40022000
                  |L20.80|
                          DCD      0xcdef89ab

                          AREA ||i.FLASH_ProgramWord||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramWord PROC
;;;679      */
;;;680    FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
000000  b578              PUSH     {r3-r6,lr}
;;;681    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;682      FLASH_Status status = FLASH_COMPLETE;
000006  2504              MOVS     r5,#4
;;;683      __IO uint32_t tmp = 0;
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;684    
;;;685      /* Check the parameters */
;;;686      assert_param(IS_FLASH_ADDRESS(Address));
;;;687    
;;;688    #ifdef STM32F10X_XL
;;;689      if(Address < FLASH_BANK1_END_ADDRESS - 2)
;;;690      { 
;;;691        /* Wait for last operation to be completed */
;;;692        status = FLASH_WaitForLastBank1Operation(ProgramTimeout); 
;;;693        if(status == FLASH_COMPLETE)
;;;694        {
;;;695          /* if the previous operation is completed, proceed to program the new first 
;;;696            half word */
;;;697          FLASH->CR |= CR_PG_Set;
;;;698      
;;;699          *(__IO uint16_t*)Address = (uint16_t)Data;
;;;700          /* Wait for last operation to be completed */
;;;701          status = FLASH_WaitForLastOperation(ProgramTimeout);
;;;702     
;;;703          if(status == FLASH_COMPLETE)
;;;704          {
;;;705            /* if the previous operation is completed, proceed to program the new second 
;;;706            half word */
;;;707            tmp = Address + 2;
;;;708    
;;;709            *(__IO uint16_t*) tmp = Data >> 16;
;;;710        
;;;711            /* Wait for last operation to be completed */
;;;712            status = FLASH_WaitForLastOperation(ProgramTimeout);
;;;713            
;;;714            /* Disable the PG Bit */
;;;715            FLASH->CR &= CR_PG_Reset;
;;;716          }
;;;717          else
;;;718          {
;;;719            /* Disable the PG Bit */
;;;720            FLASH->CR &= CR_PG_Reset;
;;;721           }
;;;722        }
;;;723      }
;;;724      else if(Address == (FLASH_BANK1_END_ADDRESS - 1))
;;;725      {
;;;726        /* Wait for last operation to be completed */
;;;727        status = FLASH_WaitForLastBank1Operation(ProgramTimeout);
;;;728    
;;;729        if(status == FLASH_COMPLETE)
;;;730        {
;;;731          /* if the previous operation is completed, proceed to program the new first 
;;;732            half word */
;;;733          FLASH->CR |= CR_PG_Set;
;;;734      
;;;735          *(__IO uint16_t*)Address = (uint16_t)Data;
;;;736    
;;;737          /* Wait for last operation to be completed */
;;;738          status = FLASH_WaitForLastBank1Operation(ProgramTimeout);
;;;739          
;;;740    	  /* Disable the PG Bit */
;;;741          FLASH->CR &= CR_PG_Reset;
;;;742        }
;;;743        else
;;;744        {
;;;745          /* Disable the PG Bit */
;;;746          FLASH->CR &= CR_PG_Reset;
;;;747        }
;;;748    
;;;749        /* Wait for last operation to be completed */
;;;750        status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
;;;751    
;;;752        if(status == FLASH_COMPLETE)
;;;753        {
;;;754          /* if the previous operation is completed, proceed to program the new second 
;;;755          half word */
;;;756          FLASH->CR2 |= CR_PG_Set;
;;;757          tmp = Address + 2;
;;;758    
;;;759          *(__IO uint16_t*) tmp = Data >> 16;
;;;760        
;;;761          /* Wait for last operation to be completed */
;;;762          status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
;;;763            
;;;764          /* Disable the PG Bit */
;;;765          FLASH->CR2 &= CR_PG_Reset;
;;;766        }
;;;767        else
;;;768        {
;;;769          /* Disable the PG Bit */
;;;770          FLASH->CR2 &= CR_PG_Reset;
;;;771        }
;;;772      }
;;;773      else
;;;774      {
;;;775        /* Wait for last operation to be completed */
;;;776        status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
;;;777    
;;;778        if(status == FLASH_COMPLETE)
;;;779        {
;;;780          /* if the previous operation is completed, proceed to program the new first 
;;;781            half word */
;;;782          FLASH->CR2 |= CR_PG_Set;
;;;783      
;;;784          *(__IO uint16_t*)Address = (uint16_t)Data;
;;;785          /* Wait for last operation to be completed */
;;;786          status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
;;;787     
;;;788          if(status == FLASH_COMPLETE)
;;;789          {
;;;790            /* if the previous operation is completed, proceed to program the new second 
;;;791            half word */
;;;792            tmp = Address + 2;
;;;793    
;;;794            *(__IO uint16_t*) tmp = Data >> 16;
;;;795        
;;;796            /* Wait for last operation to be completed */
;;;797            status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
;;;798            
;;;799            /* Disable the PG Bit */
;;;800            FLASH->CR2 &= CR_PG_Reset;
;;;801          }
;;;802          else
;;;803          {
;;;804            /* Disable the PG Bit */
;;;805            FLASH->CR2 &= CR_PG_Reset;
;;;806          }
;;;807        }
;;;808      }
;;;809    #else
;;;810      /* Wait for last operation to be completed */
;;;811      status = FLASH_WaitForLastOperation(ProgramTimeout);
00000c  02e8              LSLS     r0,r5,#11
00000e  f7fffffe          BL       FLASH_WaitForLastOperation
000012  4605              MOV      r5,r0
;;;812      
;;;813      if(status == FLASH_COMPLETE)
000014  2d04              CMP      r5,#4
000016  d124              BNE      |L21.98|
;;;814      {
;;;815        /* if the previous operation is completed, proceed to program the new first 
;;;816        half word */
;;;817        FLASH->CR |= CR_PG_Set;
000018  4813              LDR      r0,|L21.104|
00001a  6900              LDR      r0,[r0,#0x10]
00001c  f0400001          ORR      r0,r0,#1
000020  4911              LDR      r1,|L21.104|
000022  6108              STR      r0,[r1,#0x10]
;;;818      
;;;819        *(__IO uint16_t*)Address = (uint16_t)Data;
000024  8034              STRH     r4,[r6,#0]
;;;820        /* Wait for last operation to be completed */
;;;821        status = FLASH_WaitForLastOperation(ProgramTimeout);
000026  02e8              LSLS     r0,r5,#11
000028  f7fffffe          BL       FLASH_WaitForLastOperation
00002c  4605              MOV      r5,r0
;;;822     
;;;823        if(status == FLASH_COMPLETE)
00002e  2d04              CMP      r5,#4
000030  d110              BNE      |L21.84|
;;;824        {
;;;825          /* if the previous operation is completed, proceed to program the new second 
;;;826          half word */
;;;827          tmp = Address + 2;
000032  1cb0              ADDS     r0,r6,#2
000034  9000              STR      r0,[sp,#0]
;;;828    
;;;829          *(__IO uint16_t*) tmp = Data >> 16;
000036  0c20              LSRS     r0,r4,#16
000038  9900              LDR      r1,[sp,#0]
00003a  8008              STRH     r0,[r1,#0]
;;;830        
;;;831          /* Wait for last operation to be completed */
;;;832          status = FLASH_WaitForLastOperation(ProgramTimeout);
00003c  02e8              LSLS     r0,r5,#11
00003e  f7fffffe          BL       FLASH_WaitForLastOperation
000042  4605              MOV      r5,r0
;;;833            
;;;834          /* Disable the PG Bit */
;;;835          FLASH->CR &= CR_PG_Reset;
000044  4808              LDR      r0,|L21.104|
000046  6900              LDR      r0,[r0,#0x10]
000048  f64171fe          MOV      r1,#0x1ffe
00004c  4008              ANDS     r0,r0,r1
00004e  4906              LDR      r1,|L21.104|
000050  6108              STR      r0,[r1,#0x10]
000052  e006              B        |L21.98|
                  |L21.84|
;;;836        }
;;;837        else
;;;838        {
;;;839          /* Disable the PG Bit */
;;;840          FLASH->CR &= CR_PG_Reset;
000054  4804              LDR      r0,|L21.104|
000056  6900              LDR      r0,[r0,#0x10]
000058  f64171fe          MOV      r1,#0x1ffe
00005c  4008              ANDS     r0,r0,r1
00005e  4902              LDR      r1,|L21.104|
000060  6108              STR      r0,[r1,#0x10]
                  |L21.98|
;;;841        }
;;;842      }         
;;;843    #endif /* STM32F10X_XL */
;;;844       
;;;845      /* Return the Program Status */
;;;846      return status;
000062  4628              MOV      r0,r5
;;;847    }
000064  bd78              POP      {r3-r6,pc}
;;;848    
                          ENDP

000066  0000              DCW      0x0000
                  |L21.104|
                          DCD      0x40022000

                          AREA ||i.FLASH_ReadOutProtection||, CODE, READONLY, ALIGN=2

                  FLASH_ReadOutProtection PROC
;;;1047     */
;;;1048   FLASH_Status FLASH_ReadOutProtection(FunctionalState NewState)
000000  b530              PUSH     {r4,r5,lr}
;;;1049   {
000002  4605              MOV      r5,r0
;;;1050     FLASH_Status status = FLASH_COMPLETE;
000004  2404              MOVS     r4,#4
;;;1051     /* Check the parameters */
;;;1052     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1053     status = FLASH_WaitForLastOperation(EraseTimeout);
000006  f44f2030          MOV      r0,#0xb0000
00000a  f7fffffe          BL       FLASH_WaitForLastOperation
00000e  4604              MOV      r4,r0
;;;1054     if(status == FLASH_COMPLETE)
000010  2c04              CMP      r4,#4
000012  d141              BNE      |L22.152|
;;;1055     {
;;;1056       /* Authorizes the small information block programming */
;;;1057       FLASH->OPTKEYR = FLASH_KEY1;
000014  4821              LDR      r0,|L22.156|
000016  4922              LDR      r1,|L22.160|
000018  6088              STR      r0,[r1,#8]
;;;1058       FLASH->OPTKEYR = FLASH_KEY2;
00001a  4822              LDR      r0,|L22.164|
00001c  6088              STR      r0,[r1,#8]
;;;1059       FLASH->CR |= CR_OPTER_Set;
00001e  4608              MOV      r0,r1
000020  6900              LDR      r0,[r0,#0x10]
000022  f0400020          ORR      r0,r0,#0x20
000026  6108              STR      r0,[r1,#0x10]
;;;1060       FLASH->CR |= CR_STRT_Set;
000028  4608              MOV      r0,r1
00002a  6900              LDR      r0,[r0,#0x10]
00002c  f0400040          ORR      r0,r0,#0x40
000030  6108              STR      r0,[r1,#0x10]
;;;1061       /* Wait for last operation to be completed */
;;;1062       status = FLASH_WaitForLastOperation(EraseTimeout);
000032  f44f2030          MOV      r0,#0xb0000
000036  f7fffffe          BL       FLASH_WaitForLastOperation
00003a  4604              MOV      r4,r0
;;;1063       if(status == FLASH_COMPLETE)
00003c  2c04              CMP      r4,#4
00003e  d122              BNE      |L22.134|
;;;1064       {
;;;1065         /* if the erase operation is completed, disable the OPTER Bit */
;;;1066         FLASH->CR &= CR_OPTER_Reset;
000040  4817              LDR      r0,|L22.160|
000042  6900              LDR      r0,[r0,#0x10]
000044  f64171df          MOV      r1,#0x1fdf
000048  4008              ANDS     r0,r0,r1
00004a  4915              LDR      r1,|L22.160|
00004c  6108              STR      r0,[r1,#0x10]
;;;1067         /* Enable the Option Bytes Programming operation */
;;;1068         FLASH->CR |= CR_OPTPG_Set; 
00004e  4608              MOV      r0,r1
000050  6900              LDR      r0,[r0,#0x10]
000052  f0400010          ORR      r0,r0,#0x10
000056  6108              STR      r0,[r1,#0x10]
;;;1069         if(NewState != DISABLE)
000058  b11d              CBZ      r5,|L22.98|
;;;1070         {
;;;1071           OB->RDP = 0x00;
00005a  2000              MOVS     r0,#0
00005c  4912              LDR      r1,|L22.168|
00005e  8008              STRH     r0,[r1,#0]
000060  e002              B        |L22.104|
                  |L22.98|
;;;1072         }
;;;1073         else
;;;1074         {
;;;1075           OB->RDP = RDP_Key;  
000062  20a5              MOVS     r0,#0xa5
000064  4910              LDR      r1,|L22.168|
000066  8008              STRH     r0,[r1,#0]
                  |L22.104|
;;;1076         }
;;;1077         /* Wait for last operation to be completed */
;;;1078         status = FLASH_WaitForLastOperation(EraseTimeout); 
000068  f44f2030          MOV      r0,#0xb0000
00006c  f7fffffe          BL       FLASH_WaitForLastOperation
000070  4604              MOV      r4,r0
;;;1079       
;;;1080         if(status != FLASH_TIMEOUT)
000072  2c05              CMP      r4,#5
000074  d010              BEQ      |L22.152|
;;;1081         {
;;;1082           /* if the program operation is completed, disable the OPTPG Bit */
;;;1083           FLASH->CR &= CR_OPTPG_Reset;
000076  480a              LDR      r0,|L22.160|
000078  6900              LDR      r0,[r0,#0x10]
00007a  f64171ef          MOV      r1,#0x1fef
00007e  4008              ANDS     r0,r0,r1
000080  4907              LDR      r1,|L22.160|
000082  6108              STR      r0,[r1,#0x10]
000084  e008              B        |L22.152|
                  |L22.134|
;;;1084         }
;;;1085       }
;;;1086       else 
;;;1087       {
;;;1088         if(status != FLASH_TIMEOUT)
000086  2c05              CMP      r4,#5
000088  d006              BEQ      |L22.152|
;;;1089         {
;;;1090           /* Disable the OPTER Bit */
;;;1091           FLASH->CR &= CR_OPTER_Reset;
00008a  4805              LDR      r0,|L22.160|
00008c  6900              LDR      r0,[r0,#0x10]
00008e  f64171df          MOV      r1,#0x1fdf
000092  4008              ANDS     r0,r0,r1
000094  4902              LDR      r1,|L22.160|
000096  6108              STR      r0,[r1,#0x10]
                  |L22.152|
;;;1092         }
;;;1093       }
;;;1094     }
;;;1095     /* Return the protection operation Status */
;;;1096     return status;       
000098  4620              MOV      r0,r4
;;;1097   }
00009a  bd30              POP      {r4,r5,pc}
;;;1098   
                          ENDP

                  |L22.156|
                          DCD      0x45670123
                  |L22.160|
                          DCD      0x40022000
                  |L22.164|
                          DCD      0xcdef89ab
                  |L22.168|
                          DCD      0x1ffff800

                          AREA ||i.FLASH_SetLatency||, CODE, READONLY, ALIGN=2

                  FLASH_SetLatency PROC
;;;252      */
;;;253    void FLASH_SetLatency(uint32_t FLASH_Latency)
000000  4601              MOV      r1,r0
;;;254    {
;;;255      uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;256      
;;;257      /* Check the parameters */
;;;258      assert_param(IS_FLASH_LATENCY(FLASH_Latency));
;;;259      
;;;260      /* Read the ACR register */
;;;261      tmpreg = FLASH->ACR;  
000004  4a03              LDR      r2,|L23.20|
000006  6810              LDR      r0,[r2,#0]
;;;262      
;;;263      /* Sets the Latency value */
;;;264      tmpreg &= ACR_LATENCY_Mask;
000008  f0000038          AND      r0,r0,#0x38
;;;265      tmpreg |= FLASH_Latency;
00000c  4308              ORRS     r0,r0,r1
;;;266      
;;;267      /* Write the ACR register */
;;;268      FLASH->ACR = tmpreg;
00000e  6010              STR      r0,[r2,#0]
;;;269    }
000010  4770              BX       lr
;;;270    
                          ENDP

000012  0000              DCW      0x0000
                  |L23.20|
                          DCD      0x40022000

                          AREA ||i.FLASH_Unlock||, CODE, READONLY, ALIGN=2

                  FLASH_Unlock PROC
;;;317      */
;;;318    void FLASH_Unlock(void)
000000  4802              LDR      r0,|L24.12|
;;;319    {
;;;320      /* Authorize the FPEC of Bank1 Access */
;;;321      FLASH->KEYR = FLASH_KEY1;
000002  4903              LDR      r1,|L24.16|
000004  6048              STR      r0,[r1,#4]
;;;322      FLASH->KEYR = FLASH_KEY2;
000006  4803              LDR      r0,|L24.20|
000008  6048              STR      r0,[r1,#4]
;;;323    
;;;324    #ifdef STM32F10X_XL
;;;325      /* Authorize the FPEC of Bank2 Access */
;;;326      FLASH->KEYR2 = FLASH_KEY1;
;;;327      FLASH->KEYR2 = FLASH_KEY2;
;;;328    #endif /* STM32F10X_XL */
;;;329    }
00000a  4770              BX       lr
;;;330    /**
                          ENDP

                  |L24.12|
                          DCD      0x45670123
                  |L24.16|
                          DCD      0x40022000
                  |L24.20|
                          DCD      0xcdef89ab

                          AREA ||i.FLASH_UnlockBank1||, CODE, READONLY, ALIGN=2

                  FLASH_UnlockBank1 PROC
;;;338      */
;;;339    void FLASH_UnlockBank1(void)
000000  4802              LDR      r0,|L25.12|
;;;340    {
;;;341      /* Authorize the FPEC of Bank1 Access */
;;;342      FLASH->KEYR = FLASH_KEY1;
000002  4903              LDR      r1,|L25.16|
000004  6048              STR      r0,[r1,#4]
;;;343      FLASH->KEYR = FLASH_KEY2;
000006  4803              LDR      r0,|L25.20|
000008  6048              STR      r0,[r1,#4]
;;;344    }
00000a  4770              BX       lr
;;;345    
                          ENDP

                  |L25.12|
                          DCD      0x45670123
                  |L25.16|
                          DCD      0x40022000
                  |L25.20|
                          DCD      0xcdef89ab

                          AREA ||i.FLASH_UserOptionByteConfig||, CODE, READONLY, ALIGN=2

                  FLASH_UserOptionByteConfig PROC
;;;1116     */
;;;1117   FLASH_Status FLASH_UserOptionByteConfig(uint16_t OB_IWDG, uint16_t OB_STOP, uint16_t OB_STDBY)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1118   {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4617              MOV      r7,r2
;;;1119     FLASH_Status status = FLASH_COMPLETE; 
000008  2404              MOVS     r4,#4
;;;1120   
;;;1121     /* Check the parameters */
;;;1122     assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
;;;1123     assert_param(IS_OB_STOP_SOURCE(OB_STOP));
;;;1124     assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));
;;;1125   
;;;1126     /* Authorize the small information block programming */
;;;1127     FLASH->OPTKEYR = FLASH_KEY1;
00000a  4813              LDR      r0,|L26.88|
00000c  4913              LDR      r1,|L26.92|
00000e  6088              STR      r0,[r1,#8]
;;;1128     FLASH->OPTKEYR = FLASH_KEY2;
000010  4813              LDR      r0,|L26.96|
000012  6088              STR      r0,[r1,#8]
;;;1129     
;;;1130     /* Wait for last operation to be completed */
;;;1131     status = FLASH_WaitForLastOperation(ProgramTimeout);
000014  02e0              LSLS     r0,r4,#11
000016  f7fffffe          BL       FLASH_WaitForLastOperation
00001a  4604              MOV      r4,r0
;;;1132     
;;;1133     if(status == FLASH_COMPLETE)
00001c  2c04              CMP      r4,#4
00001e  d118              BNE      |L26.82|
;;;1134     {  
;;;1135       /* Enable the Option Bytes Programming operation */
;;;1136       FLASH->CR |= CR_OPTPG_Set; 
000020  480e              LDR      r0,|L26.92|
000022  6900              LDR      r0,[r0,#0x10]
000024  f0400010          ORR      r0,r0,#0x10
000028  490c              LDR      r1,|L26.92|
00002a  6108              STR      r0,[r1,#0x10]
;;;1137              
;;;1138       OB->USER = OB_IWDG | (uint16_t)(OB_STOP | (uint16_t)(OB_STDBY | ((uint16_t)0xF8))); 
00002c  f04700f8          ORR      r0,r7,#0xf8
000030  4330              ORRS     r0,r0,r6
000032  4328              ORRS     r0,r0,r5
000034  490b              LDR      r1,|L26.100|
000036  8008              STRH     r0,[r1,#0]
;;;1139     
;;;1140       /* Wait for last operation to be completed */
;;;1141       status = FLASH_WaitForLastOperation(ProgramTimeout);
000038  02e0              LSLS     r0,r4,#11
00003a  f7fffffe          BL       FLASH_WaitForLastOperation
00003e  4604              MOV      r4,r0
;;;1142       if(status != FLASH_TIMEOUT)
000040  2c05              CMP      r4,#5
000042  d006              BEQ      |L26.82|
;;;1143       {
;;;1144         /* if the program operation is completed, disable the OPTPG Bit */
;;;1145         FLASH->CR &= CR_OPTPG_Reset;
000044  4805              LDR      r0,|L26.92|
000046  6900              LDR      r0,[r0,#0x10]
000048  f64171ef          MOV      r1,#0x1fef
00004c  4008              ANDS     r0,r0,r1
00004e  4903              LDR      r1,|L26.92|
000050  6108              STR      r0,[r1,#0x10]
                  |L26.82|
;;;1146       }
;;;1147     }    
;;;1148     /* Return the Option Byte program Status */
;;;1149     return status;
000052  4620              MOV      r0,r4
;;;1150   }
000054  bdf0              POP      {r4-r7,pc}
;;;1151   
                          ENDP

000056  0000              DCW      0x0000
                  |L26.88|
                          DCD      0x45670123
                  |L26.92|
                          DCD      0x40022000
                  |L26.96|
                          DCD      0xcdef89ab
                  |L26.100|
                          DCD      0x1ffff802

                          AREA ||i.FLASH_WaitForLastBank1Operation||, CODE, READONLY, ALIGN=1

                  FLASH_WaitForLastBank1Operation PROC
;;;1621     */
;;;1622   FLASH_Status FLASH_WaitForLastBank1Operation(uint32_t Timeout)
000000  b500              PUSH     {lr}
;;;1623   { 
000002  4602              MOV      r2,r0
;;;1624     FLASH_Status status = FLASH_COMPLETE;
000004  2304              MOVS     r3,#4
;;;1625      
;;;1626     /* Check for the Flash Status */
;;;1627     status = FLASH_GetBank1Status();
000006  f7fffffe          BL       FLASH_GetBank1Status
00000a  4603              MOV      r3,r0
;;;1628     /* Wait for a Flash operation to complete or a TIMEOUT to occur */
;;;1629     while((status == FLASH_FLAG_BANK1_BSY) && (Timeout != 0x00))
00000c  e003              B        |L27.22|
                  |L27.14|
;;;1630     {
;;;1631       status = FLASH_GetBank1Status();
00000e  f7fffffe          BL       FLASH_GetBank1Status
000012  4603              MOV      r3,r0
;;;1632       Timeout--;
000014  1e52              SUBS     r2,r2,#1
                  |L27.22|
000016  2b01              CMP      r3,#1                 ;1629
000018  d101              BNE      |L27.30|
00001a  2a00              CMP      r2,#0                 ;1629
00001c  d1f7              BNE      |L27.14|
                  |L27.30|
;;;1633     }
;;;1634     if(Timeout == 0x00 )
00001e  b902              CBNZ     r2,|L27.34|
;;;1635     {
;;;1636       status = FLASH_TIMEOUT;
000020  2305              MOVS     r3,#5
                  |L27.34|
;;;1637     }
;;;1638     /* Return the operation status */
;;;1639     return status;
000022  4618              MOV      r0,r3
;;;1640   }
000024  bd00              POP      {pc}
;;;1641   
                          ENDP


                          AREA ||i.FLASH_WaitForLastOperation||, CODE, READONLY, ALIGN=1

                  FLASH_WaitForLastOperation PROC
;;;1593     */
;;;1594   FLASH_Status FLASH_WaitForLastOperation(uint32_t Timeout)
000000  b500              PUSH     {lr}
;;;1595   { 
000002  4602              MOV      r2,r0
;;;1596     FLASH_Status status = FLASH_COMPLETE;
000004  2304              MOVS     r3,#4
;;;1597      
;;;1598     /* Check for the Flash Status */
;;;1599     status = FLASH_GetBank1Status();
000006  f7fffffe          BL       FLASH_GetBank1Status
00000a  4603              MOV      r3,r0
;;;1600     /* Wait for a Flash operation to complete or a TIMEOUT to occur */
;;;1601     while((status == FLASH_BUSY) && (Timeout != 0x00))
00000c  e003              B        |L28.22|
                  |L28.14|
;;;1602     {
;;;1603       status = FLASH_GetBank1Status();
00000e  f7fffffe          BL       FLASH_GetBank1Status
000012  4603              MOV      r3,r0
;;;1604       Timeout--;
000014  1e52              SUBS     r2,r2,#1
                  |L28.22|
000016  2b01              CMP      r3,#1                 ;1601
000018  d101              BNE      |L28.30|
00001a  2a00              CMP      r2,#0                 ;1601
00001c  d1f7              BNE      |L28.14|
                  |L28.30|
;;;1605     }
;;;1606     if(Timeout == 0x00 )
00001e  b902              CBNZ     r2,|L28.34|
;;;1607     {
;;;1608       status = FLASH_TIMEOUT;
000020  2305              MOVS     r3,#5
                  |L28.34|
;;;1609     }
;;;1610     /* Return the operation status */
;;;1611     return status;
000022  4618              MOV      r0,r3
;;;1612   }
000024  bd00              POP      {pc}
;;;1613   
                          ENDP

